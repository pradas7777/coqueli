{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/three-stdlib@2.36.1_three@0.182.0/node_modules/three-stdlib/loaders/FontLoader.js","sources":["file:///C:/coqueli/frontend/node_modules/.pnpm/three-stdlib%402.36.1_three%400.182.0/node_modules/src/loaders/FontLoader.ts"],"sourcesContent":["import { Loader, FileLoader, ShapePath } from 'three'\n\nimport type { LoadingManager, Shape } from 'three'\n\ntype Options = {\n  lineHeight: number\n  letterSpacing: number\n}\n\nexport class FontLoader extends Loader {\n  constructor(manager?: LoadingManager) {\n    super(manager)\n  }\n\n  public load(\n    url: string,\n    onLoad?: (responseFont: Font) => void,\n    onProgress?: (event: ProgressEvent) => void,\n    onError?: (event: ErrorEvent) => void,\n  ): void {\n    const loader = new FileLoader(this.manager)\n\n    loader.setPath(this.path)\n    loader.setRequestHeader(this.requestHeader)\n    loader.setWithCredentials(this.withCredentials)\n\n    loader.load(\n      url,\n      (response) => {\n        if (typeof response !== 'string') throw new Error('unsupported data type')\n\n        const json = JSON.parse(response)\n\n        const font = this.parse(json)\n\n        if (onLoad) onLoad(font)\n      },\n      onProgress,\n      onError as (event: unknown) => void,\n    )\n  }\n\n  loadAsync(url: string, onProgress?: (event: ProgressEvent) => void): Promise<Font> {\n    // @ts-ignore\n    return super.loadAsync(url, onProgress)\n  }\n\n  public parse(json: FontData): Font {\n    return new Font(json)\n  }\n}\n\ntype Glyph = {\n  _cachedOutline: string[]\n  ha: number\n  o: string\n}\n\ntype FontData = {\n  boundingBox: { yMax: number; yMin: number }\n  familyName: string\n  glyphs: { [k: string]: Glyph }\n  resolution: number\n  underlineThickness: number\n}\n\nexport class Font {\n  public data: FontData\n  public isFont = true\n  public type = 'Font'\n\n  constructor(data: FontData) {\n    this.data = data\n  }\n\n  public generateShapes(text: string, size = 100, _options?: Partial<Options>): Shape[] {\n    const shapes: Shape[] = []\n    const options = { letterSpacing: 0, lineHeight: 1, ..._options }\n    const paths = createPaths(text, size, this.data, options)\n    for (let p = 0, pl = paths.length; p < pl; p++) {\n      Array.prototype.push.apply(shapes, paths[p].toShapes(false))\n    }\n    return shapes\n  }\n}\n\nfunction createPaths(text: string, size: number, data: FontData, options: Options): ShapePath[] {\n  const chars = Array.from(text)\n  const scale = size / data.resolution\n  const line_height = (data.boundingBox.yMax - data.boundingBox.yMin + data.underlineThickness) * scale\n\n  const paths: ShapePath[] = []\n\n  let offsetX = 0,\n    offsetY = 0\n\n  for (let i = 0; i < chars.length; i++) {\n    const char = chars[i]\n\n    if (char === '\\n') {\n      offsetX = 0\n      offsetY -= line_height * options.lineHeight\n    } else {\n      const ret = createPath(char, scale, offsetX, offsetY, data)\n      if (ret) {\n        offsetX += ret.offsetX + options.letterSpacing\n        paths.push(ret.path)\n      }\n    }\n  }\n\n  return paths\n}\n\nfunction createPath(\n  char: string,\n  scale: number,\n  offsetX: number,\n  offsetY: number,\n  data: FontData,\n): { offsetX: number; path: ShapePath } | undefined {\n  const glyph = data.glyphs[char] || data.glyphs['?']\n\n  if (!glyph) {\n    console.error('THREE.Font: character \"' + char + '\" does not exists in font family ' + data.familyName + '.')\n    return\n  }\n\n  const path = new ShapePath()\n\n  let x, y, cpx, cpy, cpx1, cpy1, cpx2, cpy2\n\n  if (glyph.o) {\n    const outline = glyph._cachedOutline || (glyph._cachedOutline = glyph.o.split(' '))\n\n    for (let i = 0, l = outline.length; i < l; ) {\n      const action = outline[i++]\n\n      switch (action) {\n        case 'm': // moveTo\n          x = parseInt(outline[i++]) * scale + offsetX\n          y = parseInt(outline[i++]) * scale + offsetY\n\n          path.moveTo(x, y)\n\n          break\n\n        case 'l': // lineTo\n          x = parseInt(outline[i++]) * scale + offsetX\n          y = parseInt(outline[i++]) * scale + offsetY\n\n          path.lineTo(x, y)\n\n          break\n\n        case 'q': // quadraticCurveTo\n          cpx = parseInt(outline[i++]) * scale + offsetX\n          cpy = parseInt(outline[i++]) * scale + offsetY\n          cpx1 = parseInt(outline[i++]) * scale + offsetX\n          cpy1 = parseInt(outline[i++]) * scale + offsetY\n\n          path.quadraticCurveTo(cpx1, cpy1, cpx, cpy)\n\n          break\n\n        case 'b': // bezierCurveTo\n          cpx = parseInt(outline[i++]) * scale + offsetX\n          cpy = parseInt(outline[i++]) * scale + offsetY\n          cpx1 = parseInt(outline[i++]) * scale + offsetX\n          cpy1 = parseInt(outline[i++]) * scale + offsetY\n          cpx2 = parseInt(outline[i++]) * scale + offsetX\n          cpy2 = parseInt(outline[i++]) * scale + offsetY\n\n          path.bezierCurveTo(cpx1, cpy1, cpx2, cpy2, cpx, cpy)\n\n          break\n      }\n    }\n  }\n\n  return { offsetX: glyph.ha * scale, path }\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 141, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/three-stdlib@2.36.1_three@0.182.0/node_modules/three-stdlib/loaders/SVGLoader.js","sources":["file:///C:/coqueli/frontend/node_modules/.pnpm/three-stdlib%402.36.1_three%400.182.0/node_modules/src/loaders/SVGLoader.js"],"sourcesContent":["import {\n  Box2,\n  BufferGeometry,\n  FileLoader,\n  Float32BufferAttribute,\n  Loader,\n  Matrix3,\n  Path,\n  Shape,\n  ShapePath,\n  ShapeUtils,\n  Vector2,\n  Vector3,\n} from 'three'\n\nconst COLOR_SPACE_SVG = 'srgb'\n\nconst SVGLoader = /* @__PURE__ */ (() => {\n  class SVGLoader extends Loader {\n    constructor(manager) {\n      super(manager)\n\n      // Default dots per inch\n      this.defaultDPI = 90\n\n      // Accepted units: 'mm', 'cm', 'in', 'pt', 'pc', 'px'\n      this.defaultUnit = 'px'\n    }\n\n    load(url, onLoad, onProgress, onError) {\n      const scope = this\n\n      const loader = new FileLoader(scope.manager)\n      loader.setPath(scope.path)\n      loader.setRequestHeader(scope.requestHeader)\n      loader.setWithCredentials(scope.withCredentials)\n      loader.load(\n        url,\n        function (text) {\n          try {\n            onLoad(scope.parse(text))\n          } catch (e) {\n            if (onError) {\n              onError(e)\n            } else {\n              console.error(e)\n            }\n\n            scope.manager.itemError(url)\n          }\n        },\n        onProgress,\n        onError,\n      )\n    }\n\n    parse(text) {\n      const scope = this\n\n      function parseNode(node, style) {\n        if (node.nodeType !== 1) return\n\n        const transform = getNodeTransform(node)\n\n        let isDefsNode = false\n\n        let path = null\n\n        switch (node.nodeName) {\n          case 'svg':\n            style = parseStyle(node, style)\n            break\n\n          case 'style':\n            parseCSSStylesheet(node)\n            break\n\n          case 'g':\n            style = parseStyle(node, style)\n            break\n\n          case 'path':\n            style = parseStyle(node, style)\n            if (node.hasAttribute('d')) path = parsePathNode(node)\n            break\n\n          case 'rect':\n            style = parseStyle(node, style)\n            path = parseRectNode(node)\n            break\n\n          case 'polygon':\n            style = parseStyle(node, style)\n            path = parsePolygonNode(node)\n            break\n\n          case 'polyline':\n            style = parseStyle(node, style)\n            path = parsePolylineNode(node)\n            break\n\n          case 'circle':\n            style = parseStyle(node, style)\n            path = parseCircleNode(node)\n            break\n\n          case 'ellipse':\n            style = parseStyle(node, style)\n            path = parseEllipseNode(node)\n            break\n\n          case 'line':\n            style = parseStyle(node, style)\n            path = parseLineNode(node)\n            break\n\n          case 'defs':\n            isDefsNode = true\n            break\n\n          case 'use':\n            style = parseStyle(node, style)\n\n            const href = node.getAttributeNS('http://www.w3.org/1999/xlink', 'href') || ''\n            const usedNodeId = href.substring(1)\n            const usedNode = node.viewportElement.getElementById(usedNodeId)\n            if (usedNode) {\n              parseNode(usedNode, style)\n            } else {\n              console.warn(\"SVGLoader: 'use node' references non-existent node id: \" + usedNodeId)\n            }\n\n            break\n\n          default:\n          // console.log( node );\n        }\n\n        if (path) {\n          if (style.fill !== undefined && style.fill !== 'none') {\n            path.color.setStyle(style.fill, COLOR_SPACE_SVG)\n          }\n\n          transformPath(path, currentTransform)\n\n          paths.push(path)\n\n          path.userData = { node: node, style: style }\n        }\n\n        const childNodes = node.childNodes\n\n        for (let i = 0; i < childNodes.length; i++) {\n          const node = childNodes[i]\n\n          if (isDefsNode && node.nodeName !== 'style' && node.nodeName !== 'defs') {\n            // Ignore everything in defs except CSS style definitions\n            // and nested defs, because it is OK by the standard to have\n            // <style/> there.\n            continue\n          }\n\n          parseNode(node, style)\n        }\n\n        if (transform) {\n          transformStack.pop()\n\n          if (transformStack.length > 0) {\n            currentTransform.copy(transformStack[transformStack.length - 1])\n          } else {\n            currentTransform.identity()\n          }\n        }\n      }\n\n      function parsePathNode(node) {\n        const path = new ShapePath()\n\n        const point = new Vector2()\n        const control = new Vector2()\n\n        const firstPoint = new Vector2()\n        let isFirstPoint = true\n        let doSetFirstPoint = false\n\n        const d = node.getAttribute('d')\n\n        if (d === '' || d === 'none') return null\n\n        // console.log( d );\n\n        const commands = d.match(/[a-df-z][^a-df-z]*/gi)\n\n        for (let i = 0, l = commands.length; i < l; i++) {\n          const command = commands[i]\n\n          const type = command.charAt(0)\n          const data = command.slice(1).trim()\n\n          if (isFirstPoint === true) {\n            doSetFirstPoint = true\n            isFirstPoint = false\n          }\n\n          let numbers\n\n          switch (type) {\n            case 'M':\n              numbers = parseFloats(data)\n              for (let j = 0, jl = numbers.length; j < jl; j += 2) {\n                point.x = numbers[j + 0]\n                point.y = numbers[j + 1]\n                control.x = point.x\n                control.y = point.y\n\n                if (j === 0) {\n                  path.moveTo(point.x, point.y)\n                } else {\n                  path.lineTo(point.x, point.y)\n                }\n\n                if (j === 0) firstPoint.copy(point)\n              }\n\n              break\n\n            case 'H':\n              numbers = parseFloats(data)\n\n              for (let j = 0, jl = numbers.length; j < jl; j++) {\n                point.x = numbers[j]\n                control.x = point.x\n                control.y = point.y\n                path.lineTo(point.x, point.y)\n\n                if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point)\n              }\n\n              break\n\n            case 'V':\n              numbers = parseFloats(data)\n\n              for (let j = 0, jl = numbers.length; j < jl; j++) {\n                point.y = numbers[j]\n                control.x = point.x\n                control.y = point.y\n                path.lineTo(point.x, point.y)\n\n                if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point)\n              }\n\n              break\n\n            case 'L':\n              numbers = parseFloats(data)\n\n              for (let j = 0, jl = numbers.length; j < jl; j += 2) {\n                point.x = numbers[j + 0]\n                point.y = numbers[j + 1]\n                control.x = point.x\n                control.y = point.y\n                path.lineTo(point.x, point.y)\n\n                if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point)\n              }\n\n              break\n\n            case 'C':\n              numbers = parseFloats(data)\n\n              for (let j = 0, jl = numbers.length; j < jl; j += 6) {\n                path.bezierCurveTo(\n                  numbers[j + 0],\n                  numbers[j + 1],\n                  numbers[j + 2],\n                  numbers[j + 3],\n                  numbers[j + 4],\n                  numbers[j + 5],\n                )\n                control.x = numbers[j + 2]\n                control.y = numbers[j + 3]\n                point.x = numbers[j + 4]\n                point.y = numbers[j + 5]\n\n                if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point)\n              }\n\n              break\n\n            case 'S':\n              numbers = parseFloats(data)\n\n              for (let j = 0, jl = numbers.length; j < jl; j += 4) {\n                path.bezierCurveTo(\n                  getReflection(point.x, control.x),\n                  getReflection(point.y, control.y),\n                  numbers[j + 0],\n                  numbers[j + 1],\n                  numbers[j + 2],\n                  numbers[j + 3],\n                )\n                control.x = numbers[j + 0]\n                control.y = numbers[j + 1]\n                point.x = numbers[j + 2]\n                point.y = numbers[j + 3]\n\n                if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point)\n              }\n\n              break\n\n            case 'Q':\n              numbers = parseFloats(data)\n\n              for (let j = 0, jl = numbers.length; j < jl; j += 4) {\n                path.quadraticCurveTo(numbers[j + 0], numbers[j + 1], numbers[j + 2], numbers[j + 3])\n                control.x = numbers[j + 0]\n                control.y = numbers[j + 1]\n                point.x = numbers[j + 2]\n                point.y = numbers[j + 3]\n\n                if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point)\n              }\n\n              break\n\n            case 'T':\n              numbers = parseFloats(data)\n\n              for (let j = 0, jl = numbers.length; j < jl; j += 2) {\n                const rx = getReflection(point.x, control.x)\n                const ry = getReflection(point.y, control.y)\n                path.quadraticCurveTo(rx, ry, numbers[j + 0], numbers[j + 1])\n                control.x = rx\n                control.y = ry\n                point.x = numbers[j + 0]\n                point.y = numbers[j + 1]\n\n                if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point)\n              }\n\n              break\n\n            case 'A':\n              numbers = parseFloats(data, [3, 4], 7)\n\n              for (let j = 0, jl = numbers.length; j < jl; j += 7) {\n                // skip command if start point == end point\n                if (numbers[j + 5] == point.x && numbers[j + 6] == point.y) continue\n\n                const start = point.clone()\n                point.x = numbers[j + 5]\n                point.y = numbers[j + 6]\n                control.x = point.x\n                control.y = point.y\n                parseArcCommand(\n                  path,\n                  numbers[j],\n                  numbers[j + 1],\n                  numbers[j + 2],\n                  numbers[j + 3],\n                  numbers[j + 4],\n                  start,\n                  point,\n                )\n\n                if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point)\n              }\n\n              break\n\n            case 'm':\n              numbers = parseFloats(data)\n\n              for (let j = 0, jl = numbers.length; j < jl; j += 2) {\n                point.x += numbers[j + 0]\n                point.y += numbers[j + 1]\n                control.x = point.x\n                control.y = point.y\n\n                if (j === 0) {\n                  path.moveTo(point.x, point.y)\n                } else {\n                  path.lineTo(point.x, point.y)\n                }\n\n                if (j === 0) firstPoint.copy(point)\n              }\n\n              break\n\n            case 'h':\n              numbers = parseFloats(data)\n\n              for (let j = 0, jl = numbers.length; j < jl; j++) {\n                point.x += numbers[j]\n                control.x = point.x\n                control.y = point.y\n                path.lineTo(point.x, point.y)\n\n                if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point)\n              }\n\n              break\n\n            case 'v':\n              numbers = parseFloats(data)\n\n              for (let j = 0, jl = numbers.length; j < jl; j++) {\n                point.y += numbers[j]\n                control.x = point.x\n                control.y = point.y\n                path.lineTo(point.x, point.y)\n\n                if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point)\n              }\n\n              break\n\n            case 'l':\n              numbers = parseFloats(data)\n\n              for (let j = 0, jl = numbers.length; j < jl; j += 2) {\n                point.x += numbers[j + 0]\n                point.y += numbers[j + 1]\n                control.x = point.x\n                control.y = point.y\n                path.lineTo(point.x, point.y)\n\n                if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point)\n              }\n\n              break\n\n            case 'c':\n              numbers = parseFloats(data)\n\n              for (let j = 0, jl = numbers.length; j < jl; j += 6) {\n                path.bezierCurveTo(\n                  point.x + numbers[j + 0],\n                  point.y + numbers[j + 1],\n                  point.x + numbers[j + 2],\n                  point.y + numbers[j + 3],\n                  point.x + numbers[j + 4],\n                  point.y + numbers[j + 5],\n                )\n                control.x = point.x + numbers[j + 2]\n                control.y = point.y + numbers[j + 3]\n                point.x += numbers[j + 4]\n                point.y += numbers[j + 5]\n\n                if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point)\n              }\n\n              break\n\n            case 's':\n              numbers = parseFloats(data)\n\n              for (let j = 0, jl = numbers.length; j < jl; j += 4) {\n                path.bezierCurveTo(\n                  getReflection(point.x, control.x),\n                  getReflection(point.y, control.y),\n                  point.x + numbers[j + 0],\n                  point.y + numbers[j + 1],\n                  point.x + numbers[j + 2],\n                  point.y + numbers[j + 3],\n                )\n                control.x = point.x + numbers[j + 0]\n                control.y = point.y + numbers[j + 1]\n                point.x += numbers[j + 2]\n                point.y += numbers[j + 3]\n\n                if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point)\n              }\n\n              break\n\n            case 'q':\n              numbers = parseFloats(data)\n\n              for (let j = 0, jl = numbers.length; j < jl; j += 4) {\n                path.quadraticCurveTo(\n                  point.x + numbers[j + 0],\n                  point.y + numbers[j + 1],\n                  point.x + numbers[j + 2],\n                  point.y + numbers[j + 3],\n                )\n                control.x = point.x + numbers[j + 0]\n                control.y = point.y + numbers[j + 1]\n                point.x += numbers[j + 2]\n                point.y += numbers[j + 3]\n\n                if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point)\n              }\n\n              break\n\n            case 't':\n              numbers = parseFloats(data)\n\n              for (let j = 0, jl = numbers.length; j < jl; j += 2) {\n                const rx = getReflection(point.x, control.x)\n                const ry = getReflection(point.y, control.y)\n                path.quadraticCurveTo(rx, ry, point.x + numbers[j + 0], point.y + numbers[j + 1])\n                control.x = rx\n                control.y = ry\n                point.x = point.x + numbers[j + 0]\n                point.y = point.y + numbers[j + 1]\n\n                if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point)\n              }\n\n              break\n\n            case 'a':\n              numbers = parseFloats(data, [3, 4], 7)\n\n              for (let j = 0, jl = numbers.length; j < jl; j += 7) {\n                // skip command if no displacement\n                if (numbers[j + 5] == 0 && numbers[j + 6] == 0) continue\n\n                const start = point.clone()\n                point.x += numbers[j + 5]\n                point.y += numbers[j + 6]\n                control.x = point.x\n                control.y = point.y\n                parseArcCommand(\n                  path,\n                  numbers[j],\n                  numbers[j + 1],\n                  numbers[j + 2],\n                  numbers[j + 3],\n                  numbers[j + 4],\n                  start,\n                  point,\n                )\n\n                if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point)\n              }\n\n              break\n\n            case 'Z':\n            case 'z':\n              path.currentPath.autoClose = true\n\n              if (path.currentPath.curves.length > 0) {\n                // Reset point to beginning of Path\n                point.copy(firstPoint)\n                path.currentPath.currentPoint.copy(point)\n                isFirstPoint = true\n              }\n\n              break\n\n            default:\n              console.warn(command)\n          }\n\n          // console.log( type, parseFloats( data ), parseFloats( data ).length  )\n\n          doSetFirstPoint = false\n        }\n\n        return path\n      }\n\n      function parseCSSStylesheet(node) {\n        if (!node.sheet || !node.sheet.cssRules || !node.sheet.cssRules.length) return\n\n        for (let i = 0; i < node.sheet.cssRules.length; i++) {\n          const stylesheet = node.sheet.cssRules[i]\n\n          if (stylesheet.type !== 1) continue\n\n          const selectorList = stylesheet.selectorText\n            .split(/,/gm)\n            .filter(Boolean)\n            .map((i) => i.trim())\n\n          for (let j = 0; j < selectorList.length; j++) {\n            // Remove empty rules\n            const definitions = Object.fromEntries(Object.entries(stylesheet.style).filter(([, v]) => v !== ''))\n\n            stylesheets[selectorList[j]] = Object.assign(stylesheets[selectorList[j]] || {}, definitions)\n          }\n        }\n      }\n\n      /**\n       * https://www.w3.org/TR/SVG/implnote.html#ArcImplementationNotes\n       * https://mortoray.com/2017/02/16/rendering-an-svg-elliptical-arc-as-bezier-curves/ Appendix: Endpoint to center arc conversion\n       * From\n       * rx ry x-axis-rotation large-arc-flag sweep-flag x y\n       * To\n       * aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation\n       */\n\n      function parseArcCommand(path, rx, ry, x_axis_rotation, large_arc_flag, sweep_flag, start, end) {\n        if (rx == 0 || ry == 0) {\n          // draw a line if either of the radii == 0\n          path.lineTo(end.x, end.y)\n          return\n        }\n\n        x_axis_rotation = (x_axis_rotation * Math.PI) / 180\n\n        // Ensure radii are positive\n        rx = Math.abs(rx)\n        ry = Math.abs(ry)\n\n        // Compute (x1', y1')\n        const dx2 = (start.x - end.x) / 2.0\n        const dy2 = (start.y - end.y) / 2.0\n        const x1p = Math.cos(x_axis_rotation) * dx2 + Math.sin(x_axis_rotation) * dy2\n        const y1p = -Math.sin(x_axis_rotation) * dx2 + Math.cos(x_axis_rotation) * dy2\n\n        // Compute (cx', cy')\n        let rxs = rx * rx\n        let rys = ry * ry\n        const x1ps = x1p * x1p\n        const y1ps = y1p * y1p\n\n        // Ensure radii are large enough\n        const cr = x1ps / rxs + y1ps / rys\n\n        if (cr > 1) {\n          // scale up rx,ry equally so cr == 1\n          const s = Math.sqrt(cr)\n          rx = s * rx\n          ry = s * ry\n          rxs = rx * rx\n          rys = ry * ry\n        }\n\n        const dq = rxs * y1ps + rys * x1ps\n        const pq = (rxs * rys - dq) / dq\n        let q = Math.sqrt(Math.max(0, pq))\n        if (large_arc_flag === sweep_flag) q = -q\n        const cxp = (q * rx * y1p) / ry\n        const cyp = (-q * ry * x1p) / rx\n\n        // Step 3: Compute (cx, cy) from (cx', cy')\n        const cx = Math.cos(x_axis_rotation) * cxp - Math.sin(x_axis_rotation) * cyp + (start.x + end.x) / 2\n        const cy = Math.sin(x_axis_rotation) * cxp + Math.cos(x_axis_rotation) * cyp + (start.y + end.y) / 2\n\n        // Step 4: Compute θ1 and Δθ\n        const theta = svgAngle(1, 0, (x1p - cxp) / rx, (y1p - cyp) / ry)\n        const delta = svgAngle((x1p - cxp) / rx, (y1p - cyp) / ry, (-x1p - cxp) / rx, (-y1p - cyp) / ry) % (Math.PI * 2)\n\n        path.currentPath.absellipse(cx, cy, rx, ry, theta, theta + delta, sweep_flag === 0, x_axis_rotation)\n      }\n\n      function svgAngle(ux, uy, vx, vy) {\n        const dot = ux * vx + uy * vy\n        const len = Math.sqrt(ux * ux + uy * uy) * Math.sqrt(vx * vx + vy * vy)\n        let ang = Math.acos(Math.max(-1, Math.min(1, dot / len))) // floating point precision, slightly over values appear\n        if (ux * vy - uy * vx < 0) ang = -ang\n        return ang\n      }\n\n      /*\n       * According to https://www.w3.org/TR/SVG/shapes.html#RectElementRXAttribute\n       * rounded corner should be rendered to elliptical arc, but bezier curve does the job well enough\n       */\n      function parseRectNode(node) {\n        const x = parseFloatWithUnits(node.getAttribute('x') || 0)\n        const y = parseFloatWithUnits(node.getAttribute('y') || 0)\n        const rx = parseFloatWithUnits(node.getAttribute('rx') || node.getAttribute('ry') || 0)\n        const ry = parseFloatWithUnits(node.getAttribute('ry') || node.getAttribute('rx') || 0)\n        const w = parseFloatWithUnits(node.getAttribute('width'))\n        const h = parseFloatWithUnits(node.getAttribute('height'))\n\n        // Ellipse arc to Bezier approximation Coefficient (Inversed). See:\n        // https://spencermortensen.com/articles/bezier-circle/\n        const bci = 1 - 0.551915024494\n\n        const path = new ShapePath()\n\n        // top left\n        path.moveTo(x + rx, y)\n\n        // top right\n        path.lineTo(x + w - rx, y)\n        if (rx !== 0 || ry !== 0) {\n          path.bezierCurveTo(x + w - rx * bci, y, x + w, y + ry * bci, x + w, y + ry)\n        }\n\n        // bottom right\n        path.lineTo(x + w, y + h - ry)\n        if (rx !== 0 || ry !== 0) {\n          path.bezierCurveTo(x + w, y + h - ry * bci, x + w - rx * bci, y + h, x + w - rx, y + h)\n        }\n\n        // bottom left\n        path.lineTo(x + rx, y + h)\n        if (rx !== 0 || ry !== 0) {\n          path.bezierCurveTo(x + rx * bci, y + h, x, y + h - ry * bci, x, y + h - ry)\n        }\n\n        // back to top left\n        path.lineTo(x, y + ry)\n        if (rx !== 0 || ry !== 0) {\n          path.bezierCurveTo(x, y + ry * bci, x + rx * bci, y, x + rx, y)\n        }\n\n        return path\n      }\n\n      function parsePolygonNode(node) {\n        function iterator(match, a, b) {\n          const x = parseFloatWithUnits(a)\n          const y = parseFloatWithUnits(b)\n\n          if (index === 0) {\n            path.moveTo(x, y)\n          } else {\n            path.lineTo(x, y)\n          }\n\n          index++\n        }\n\n        const regex = /([+-]?\\d*\\.?\\d+(?:e[+-]?\\d+)?)(?:,|\\s)([+-]?\\d*\\.?\\d+(?:e[+-]?\\d+)?)/g\n\n        const path = new ShapePath()\n\n        let index = 0\n\n        node.getAttribute('points').replace(regex, iterator)\n\n        path.currentPath.autoClose = true\n\n        return path\n      }\n\n      function parsePolylineNode(node) {\n        function iterator(match, a, b) {\n          const x = parseFloatWithUnits(a)\n          const y = parseFloatWithUnits(b)\n\n          if (index === 0) {\n            path.moveTo(x, y)\n          } else {\n            path.lineTo(x, y)\n          }\n\n          index++\n        }\n\n        const regex = /([+-]?\\d*\\.?\\d+(?:e[+-]?\\d+)?)(?:,|\\s)([+-]?\\d*\\.?\\d+(?:e[+-]?\\d+)?)/g\n\n        const path = new ShapePath()\n\n        let index = 0\n\n        node.getAttribute('points').replace(regex, iterator)\n\n        path.currentPath.autoClose = false\n\n        return path\n      }\n\n      function parseCircleNode(node) {\n        const x = parseFloatWithUnits(node.getAttribute('cx') || 0)\n        const y = parseFloatWithUnits(node.getAttribute('cy') || 0)\n        const r = parseFloatWithUnits(node.getAttribute('r') || 0)\n\n        const subpath = new Path()\n        subpath.absarc(x, y, r, 0, Math.PI * 2)\n\n        const path = new ShapePath()\n        path.subPaths.push(subpath)\n\n        return path\n      }\n\n      function parseEllipseNode(node) {\n        const x = parseFloatWithUnits(node.getAttribute('cx') || 0)\n        const y = parseFloatWithUnits(node.getAttribute('cy') || 0)\n        const rx = parseFloatWithUnits(node.getAttribute('rx') || 0)\n        const ry = parseFloatWithUnits(node.getAttribute('ry') || 0)\n\n        const subpath = new Path()\n        subpath.absellipse(x, y, rx, ry, 0, Math.PI * 2)\n\n        const path = new ShapePath()\n        path.subPaths.push(subpath)\n\n        return path\n      }\n\n      function parseLineNode(node) {\n        const x1 = parseFloatWithUnits(node.getAttribute('x1') || 0)\n        const y1 = parseFloatWithUnits(node.getAttribute('y1') || 0)\n        const x2 = parseFloatWithUnits(node.getAttribute('x2') || 0)\n        const y2 = parseFloatWithUnits(node.getAttribute('y2') || 0)\n\n        const path = new ShapePath()\n        path.moveTo(x1, y1)\n        path.lineTo(x2, y2)\n        path.currentPath.autoClose = false\n\n        return path\n      }\n\n      //\n\n      function parseStyle(node, style) {\n        style = Object.assign({}, style) // clone style\n\n        let stylesheetStyles = {}\n\n        if (node.hasAttribute('class')) {\n          const classSelectors = node\n            .getAttribute('class')\n            .split(/\\s/)\n            .filter(Boolean)\n            .map((i) => i.trim())\n\n          for (let i = 0; i < classSelectors.length; i++) {\n            stylesheetStyles = Object.assign(stylesheetStyles, stylesheets['.' + classSelectors[i]])\n          }\n        }\n\n        if (node.hasAttribute('id')) {\n          stylesheetStyles = Object.assign(stylesheetStyles, stylesheets['#' + node.getAttribute('id')])\n        }\n\n        function addStyle(svgName, jsName, adjustFunction) {\n          if (adjustFunction === undefined)\n            adjustFunction = function copy(v) {\n              if (v.startsWith('url')) console.warn('SVGLoader: url access in attributes is not implemented.')\n\n              return v\n            }\n\n          if (node.hasAttribute(svgName)) style[jsName] = adjustFunction(node.getAttribute(svgName))\n          if (stylesheetStyles[svgName]) style[jsName] = adjustFunction(stylesheetStyles[svgName])\n          if (node.style && node.style[svgName] !== '') style[jsName] = adjustFunction(node.style[svgName])\n        }\n\n        function clamp(v) {\n          return Math.max(0, Math.min(1, parseFloatWithUnits(v)))\n        }\n\n        function positive(v) {\n          return Math.max(0, parseFloatWithUnits(v))\n        }\n\n        addStyle('fill', 'fill')\n        addStyle('fill-opacity', 'fillOpacity', clamp)\n        addStyle('fill-rule', 'fillRule')\n        addStyle('opacity', 'opacity', clamp)\n        addStyle('stroke', 'stroke')\n        addStyle('stroke-opacity', 'strokeOpacity', clamp)\n        addStyle('stroke-width', 'strokeWidth', positive)\n        addStyle('stroke-linejoin', 'strokeLineJoin')\n        addStyle('stroke-linecap', 'strokeLineCap')\n        addStyle('stroke-miterlimit', 'strokeMiterLimit', positive)\n        addStyle('visibility', 'visibility')\n\n        return style\n      }\n\n      // http://www.w3.org/TR/SVG11/implnote.html#PathElementImplementationNotes\n\n      function getReflection(a, b) {\n        return a - (b - a)\n      }\n\n      // from https://github.com/ppvg/svg-numbers (MIT License)\n\n      function parseFloats(input, flags, stride) {\n        if (typeof input !== 'string') {\n          throw new TypeError('Invalid input: ' + typeof input)\n        }\n\n        // Character groups\n        const RE = {\n          SEPARATOR: /[ \\t\\r\\n\\,.\\-+]/,\n          WHITESPACE: /[ \\t\\r\\n]/,\n          DIGIT: /[\\d]/,\n          SIGN: /[-+]/,\n          POINT: /\\./,\n          COMMA: /,/,\n          EXP: /e/i,\n          FLAGS: /[01]/,\n        }\n\n        // States\n        const SEP = 0\n        const INT = 1\n        const FLOAT = 2\n        const EXP = 3\n\n        let state = SEP\n        let seenComma = true\n        let number = '',\n          exponent = ''\n        const result = []\n\n        function throwSyntaxError(current, i, partial) {\n          const error = new SyntaxError('Unexpected character \"' + current + '\" at index ' + i + '.')\n          error.partial = partial\n          throw error\n        }\n\n        function newNumber() {\n          if (number !== '') {\n            if (exponent === '') result.push(Number(number))\n            else result.push(Number(number) * Math.pow(10, Number(exponent)))\n          }\n\n          number = ''\n          exponent = ''\n        }\n\n        let current\n        const length = input.length\n\n        for (let i = 0; i < length; i++) {\n          current = input[i]\n\n          // check for flags\n          if (Array.isArray(flags) && flags.includes(result.length % stride) && RE.FLAGS.test(current)) {\n            state = INT\n            number = current\n            newNumber()\n            continue\n          }\n\n          // parse until next number\n          if (state === SEP) {\n            // eat whitespace\n            if (RE.WHITESPACE.test(current)) {\n              continue\n            }\n\n            // start new number\n            if (RE.DIGIT.test(current) || RE.SIGN.test(current)) {\n              state = INT\n              number = current\n              continue\n            }\n\n            if (RE.POINT.test(current)) {\n              state = FLOAT\n              number = current\n              continue\n            }\n\n            // throw on double commas (e.g. \"1, , 2\")\n            if (RE.COMMA.test(current)) {\n              if (seenComma) {\n                throwSyntaxError(current, i, result)\n              }\n\n              seenComma = true\n            }\n          }\n\n          // parse integer part\n          if (state === INT) {\n            if (RE.DIGIT.test(current)) {\n              number += current\n              continue\n            }\n\n            if (RE.POINT.test(current)) {\n              number += current\n              state = FLOAT\n              continue\n            }\n\n            if (RE.EXP.test(current)) {\n              state = EXP\n              continue\n            }\n\n            // throw on double signs (\"-+1\"), but not on sign as separator (\"-1-2\")\n            if (RE.SIGN.test(current) && number.length === 1 && RE.SIGN.test(number[0])) {\n              throwSyntaxError(current, i, result)\n            }\n          }\n\n          // parse decimal part\n          if (state === FLOAT) {\n            if (RE.DIGIT.test(current)) {\n              number += current\n              continue\n            }\n\n            if (RE.EXP.test(current)) {\n              state = EXP\n              continue\n            }\n\n            // throw on double decimal points (e.g. \"1..2\")\n            if (RE.POINT.test(current) && number[number.length - 1] === '.') {\n              throwSyntaxError(current, i, result)\n            }\n          }\n\n          // parse exponent part\n          if (state === EXP) {\n            if (RE.DIGIT.test(current)) {\n              exponent += current\n              continue\n            }\n\n            if (RE.SIGN.test(current)) {\n              if (exponent === '') {\n                exponent += current\n                continue\n              }\n\n              if (exponent.length === 1 && RE.SIGN.test(exponent)) {\n                throwSyntaxError(current, i, result)\n              }\n            }\n          }\n\n          // end of number\n          if (RE.WHITESPACE.test(current)) {\n            newNumber()\n            state = SEP\n            seenComma = false\n          } else if (RE.COMMA.test(current)) {\n            newNumber()\n            state = SEP\n            seenComma = true\n          } else if (RE.SIGN.test(current)) {\n            newNumber()\n            state = INT\n            number = current\n          } else if (RE.POINT.test(current)) {\n            newNumber()\n            state = FLOAT\n            number = current\n          } else {\n            throwSyntaxError(current, i, result)\n          }\n        }\n\n        // add the last number found (if any)\n        newNumber()\n\n        return result\n      }\n\n      // Units\n\n      const units = ['mm', 'cm', 'in', 'pt', 'pc', 'px']\n\n      // Conversion: [ fromUnit ][ toUnit ] (-1 means dpi dependent)\n      const unitConversion = {\n        mm: {\n          mm: 1,\n          cm: 0.1,\n          in: 1 / 25.4,\n          pt: 72 / 25.4,\n          pc: 6 / 25.4,\n          px: -1,\n        },\n        cm: {\n          mm: 10,\n          cm: 1,\n          in: 1 / 2.54,\n          pt: 72 / 2.54,\n          pc: 6 / 2.54,\n          px: -1,\n        },\n        in: {\n          mm: 25.4,\n          cm: 2.54,\n          in: 1,\n          pt: 72,\n          pc: 6,\n          px: -1,\n        },\n        pt: {\n          mm: 25.4 / 72,\n          cm: 2.54 / 72,\n          in: 1 / 72,\n          pt: 1,\n          pc: 6 / 72,\n          px: -1,\n        },\n        pc: {\n          mm: 25.4 / 6,\n          cm: 2.54 / 6,\n          in: 1 / 6,\n          pt: 72 / 6,\n          pc: 1,\n          px: -1,\n        },\n        px: {\n          px: 1,\n        },\n      }\n\n      function parseFloatWithUnits(string) {\n        let theUnit = 'px'\n\n        if (typeof string === 'string' || string instanceof String) {\n          for (let i = 0, n = units.length; i < n; i++) {\n            const u = units[i]\n\n            if (string.endsWith(u)) {\n              theUnit = u\n              string = string.substring(0, string.length - u.length)\n              break\n            }\n          }\n        }\n\n        let scale = undefined\n\n        if (theUnit === 'px' && scope.defaultUnit !== 'px') {\n          // Conversion scale from  pixels to inches, then to default units\n\n          scale = unitConversion['in'][scope.defaultUnit] / scope.defaultDPI\n        } else {\n          scale = unitConversion[theUnit][scope.defaultUnit]\n\n          if (scale < 0) {\n            // Conversion scale to pixels\n\n            scale = unitConversion[theUnit]['in'] * scope.defaultDPI\n          }\n        }\n\n        return scale * parseFloat(string)\n      }\n\n      // Transforms\n\n      function getNodeTransform(node) {\n        if (\n          !(\n            node.hasAttribute('transform') ||\n            (node.nodeName === 'use' && (node.hasAttribute('x') || node.hasAttribute('y')))\n          )\n        ) {\n          return null\n        }\n\n        const transform = parseNodeTransform(node)\n\n        if (transformStack.length > 0) {\n          transform.premultiply(transformStack[transformStack.length - 1])\n        }\n\n        currentTransform.copy(transform)\n        transformStack.push(transform)\n\n        return transform\n      }\n\n      function parseNodeTransform(node) {\n        const transform = new Matrix3()\n        const currentTransform = tempTransform0\n\n        if (node.nodeName === 'use' && (node.hasAttribute('x') || node.hasAttribute('y'))) {\n          const tx = parseFloatWithUnits(node.getAttribute('x'))\n          const ty = parseFloatWithUnits(node.getAttribute('y'))\n\n          transform.translate(tx, ty)\n        }\n\n        if (node.hasAttribute('transform')) {\n          const transformsTexts = node.getAttribute('transform').split(')')\n\n          for (let tIndex = transformsTexts.length - 1; tIndex >= 0; tIndex--) {\n            const transformText = transformsTexts[tIndex].trim()\n\n            if (transformText === '') continue\n\n            const openParPos = transformText.indexOf('(')\n            const closeParPos = transformText.length\n\n            if (openParPos > 0 && openParPos < closeParPos) {\n              const transformType = transformText.slice(0, openParPos)\n\n              const array = parseFloats(transformText.slice(openParPos + 1))\n\n              currentTransform.identity()\n\n              switch (transformType) {\n                case 'translate':\n                  if (array.length >= 1) {\n                    const tx = array[0]\n                    let ty = 0\n\n                    if (array.length >= 2) {\n                      ty = array[1]\n                    }\n\n                    currentTransform.translate(tx, ty)\n                  }\n\n                  break\n\n                case 'rotate':\n                  if (array.length >= 1) {\n                    let angle = 0\n                    let cx = 0\n                    let cy = 0\n\n                    // Angle\n                    angle = (array[0] * Math.PI) / 180\n\n                    if (array.length >= 3) {\n                      // Center x, y\n                      cx = array[1]\n                      cy = array[2]\n                    }\n\n                    // Rotate around center (cx, cy)\n                    tempTransform1.makeTranslation(-cx, -cy)\n                    tempTransform2.makeRotation(angle)\n                    tempTransform3.multiplyMatrices(tempTransform2, tempTransform1)\n                    tempTransform1.makeTranslation(cx, cy)\n                    currentTransform.multiplyMatrices(tempTransform1, tempTransform3)\n                  }\n\n                  break\n\n                case 'scale':\n                  if (array.length >= 1) {\n                    const scaleX = array[0]\n                    let scaleY = scaleX\n\n                    if (array.length >= 2) {\n                      scaleY = array[1]\n                    }\n\n                    currentTransform.scale(scaleX, scaleY)\n                  }\n\n                  break\n\n                case 'skewX':\n                  if (array.length === 1) {\n                    currentTransform.set(1, Math.tan((array[0] * Math.PI) / 180), 0, 0, 1, 0, 0, 0, 1)\n                  }\n\n                  break\n\n                case 'skewY':\n                  if (array.length === 1) {\n                    currentTransform.set(1, 0, 0, Math.tan((array[0] * Math.PI) / 180), 1, 0, 0, 0, 1)\n                  }\n\n                  break\n\n                case 'matrix':\n                  if (array.length === 6) {\n                    currentTransform.set(array[0], array[2], array[4], array[1], array[3], array[5], 0, 0, 1)\n                  }\n\n                  break\n              }\n            }\n\n            transform.premultiply(currentTransform)\n          }\n        }\n\n        return transform\n      }\n\n      function transformPath(path, m) {\n        function transfVec2(v2) {\n          tempV3.set(v2.x, v2.y, 1).applyMatrix3(m)\n\n          v2.set(tempV3.x, tempV3.y)\n        }\n\n        function transfEllipseGeneric(curve) {\n          // For math description see:\n          // https://math.stackexchange.com/questions/4544164\n\n          const a = curve.xRadius\n          const b = curve.yRadius\n\n          const cosTheta = Math.cos(curve.aRotation)\n          const sinTheta = Math.sin(curve.aRotation)\n\n          const v1 = new Vector3(a * cosTheta, a * sinTheta, 0)\n          const v2 = new Vector3(-b * sinTheta, b * cosTheta, 0)\n\n          const f1 = v1.applyMatrix3(m)\n          const f2 = v2.applyMatrix3(m)\n\n          const mF = tempTransform0.set(f1.x, f2.x, 0, f1.y, f2.y, 0, 0, 0, 1)\n\n          const mFInv = tempTransform1.copy(mF).invert()\n          const mFInvT = tempTransform2.copy(mFInv).transpose()\n          const mQ = mFInvT.multiply(mFInv)\n          const mQe = mQ.elements\n\n          const ed = eigenDecomposition(mQe[0], mQe[1], mQe[4])\n          const rt1sqrt = Math.sqrt(ed.rt1)\n          const rt2sqrt = Math.sqrt(ed.rt2)\n\n          curve.xRadius = 1 / rt1sqrt\n          curve.yRadius = 1 / rt2sqrt\n          curve.aRotation = Math.atan2(ed.sn, ed.cs)\n\n          const isFullEllipse = (curve.aEndAngle - curve.aStartAngle) % (2 * Math.PI) < Number.EPSILON\n\n          // Do not touch angles of a full ellipse because after transformation they\n          // would converge to a sinle value effectively removing the whole curve\n\n          if (!isFullEllipse) {\n            const mDsqrt = tempTransform1.set(rt1sqrt, 0, 0, 0, rt2sqrt, 0, 0, 0, 1)\n\n            const mRT = tempTransform2.set(ed.cs, ed.sn, 0, -ed.sn, ed.cs, 0, 0, 0, 1)\n\n            const mDRF = mDsqrt.multiply(mRT).multiply(mF)\n\n            const transformAngle = (phi) => {\n              const { x: cosR, y: sinR } = new Vector3(Math.cos(phi), Math.sin(phi), 0).applyMatrix3(mDRF)\n\n              return Math.atan2(sinR, cosR)\n            }\n\n            curve.aStartAngle = transformAngle(curve.aStartAngle)\n            curve.aEndAngle = transformAngle(curve.aEndAngle)\n\n            if (isTransformFlipped(m)) {\n              curve.aClockwise = !curve.aClockwise\n            }\n          }\n        }\n\n        function transfEllipseNoSkew(curve) {\n          // Faster shortcut if no skew is applied\n          // (e.g, a euclidean transform of a group containing the ellipse)\n\n          const sx = getTransformScaleX(m)\n          const sy = getTransformScaleY(m)\n\n          curve.xRadius *= sx\n          curve.yRadius *= sy\n\n          // Extract rotation angle from the matrix of form:\n          //\n          //  | cosθ sx   -sinθ sy |\n          //  | sinθ sx    cosθ sy |\n          //\n          // Remembering that tanθ = sinθ / cosθ; and that\n          // `sx`, `sy`, or both might be zero.\n          const theta =\n            sx > Number.EPSILON ? Math.atan2(m.elements[1], m.elements[0]) : Math.atan2(-m.elements[3], m.elements[4])\n\n          curve.aRotation += theta\n\n          if (isTransformFlipped(m)) {\n            curve.aStartAngle *= -1\n            curve.aEndAngle *= -1\n            curve.aClockwise = !curve.aClockwise\n          }\n        }\n\n        const subPaths = path.subPaths\n\n        for (let i = 0, n = subPaths.length; i < n; i++) {\n          const subPath = subPaths[i]\n          const curves = subPath.curves\n\n          for (let j = 0; j < curves.length; j++) {\n            const curve = curves[j]\n\n            if (curve.isLineCurve) {\n              transfVec2(curve.v1)\n              transfVec2(curve.v2)\n            } else if (curve.isCubicBezierCurve) {\n              transfVec2(curve.v0)\n              transfVec2(curve.v1)\n              transfVec2(curve.v2)\n              transfVec2(curve.v3)\n            } else if (curve.isQuadraticBezierCurve) {\n              transfVec2(curve.v0)\n              transfVec2(curve.v1)\n              transfVec2(curve.v2)\n            } else if (curve.isEllipseCurve) {\n              // Transform ellipse center point\n\n              tempV2.set(curve.aX, curve.aY)\n              transfVec2(tempV2)\n              curve.aX = tempV2.x\n              curve.aY = tempV2.y\n\n              // Transform ellipse shape parameters\n\n              if (isTransformSkewed(m)) {\n                transfEllipseGeneric(curve)\n              } else {\n                transfEllipseNoSkew(curve)\n              }\n            }\n          }\n        }\n      }\n\n      function isTransformFlipped(m) {\n        const te = m.elements\n        return te[0] * te[4] - te[1] * te[3] < 0\n      }\n\n      function isTransformSkewed(m) {\n        const te = m.elements\n        const basisDot = te[0] * te[3] + te[1] * te[4]\n\n        // Shortcut for trivial rotations and transformations\n        if (basisDot === 0) return false\n\n        const sx = getTransformScaleX(m)\n        const sy = getTransformScaleY(m)\n\n        return Math.abs(basisDot / (sx * sy)) > Number.EPSILON\n      }\n\n      function getTransformScaleX(m) {\n        const te = m.elements\n        return Math.sqrt(te[0] * te[0] + te[1] * te[1])\n      }\n\n      function getTransformScaleY(m) {\n        const te = m.elements\n        return Math.sqrt(te[3] * te[3] + te[4] * te[4])\n      }\n\n      // Calculates the eigensystem of a real symmetric 2x2 matrix\n      //    [ A  B ]\n      //    [ B  C ]\n      // in the form\n      //    [ A  B ]  =  [ cs  -sn ] [ rt1   0  ] [  cs  sn ]\n      //    [ B  C ]     [ sn   cs ] [  0   rt2 ] [ -sn  cs ]\n      // where rt1 >= rt2.\n      //\n      // Adapted from: https://www.mpi-hd.mpg.de/personalhomes/globes/3x3/index.html\n      // -> Algorithms for real symmetric matrices -> Analytical (2x2 symmetric)\n      function eigenDecomposition(A, B, C) {\n        let rt1, rt2, cs, sn, t\n        const sm = A + C\n        const df = A - C\n        const rt = Math.sqrt(df * df + 4 * B * B)\n\n        if (sm > 0) {\n          rt1 = 0.5 * (sm + rt)\n          t = 1 / rt1\n          rt2 = A * t * C - B * t * B\n        } else if (sm < 0) {\n          rt2 = 0.5 * (sm - rt)\n        } else {\n          // This case needs to be treated separately to avoid div by 0\n\n          rt1 = 0.5 * rt\n          rt2 = -0.5 * rt\n        }\n\n        // Calculate eigenvectors\n\n        if (df > 0) {\n          cs = df + rt\n        } else {\n          cs = df - rt\n        }\n\n        if (Math.abs(cs) > 2 * Math.abs(B)) {\n          t = (-2 * B) / cs\n          sn = 1 / Math.sqrt(1 + t * t)\n          cs = t * sn\n        } else if (Math.abs(B) === 0) {\n          cs = 1\n          sn = 0\n        } else {\n          t = (-0.5 * cs) / B\n          cs = 1 / Math.sqrt(1 + t * t)\n          sn = t * cs\n        }\n\n        if (df > 0) {\n          t = cs\n          cs = -sn\n          sn = t\n        }\n\n        return { rt1, rt2, cs, sn }\n      }\n\n      //\n\n      const paths = []\n      const stylesheets = {}\n\n      const transformStack = []\n\n      const tempTransform0 = new Matrix3()\n      const tempTransform1 = new Matrix3()\n      const tempTransform2 = new Matrix3()\n      const tempTransform3 = new Matrix3()\n      const tempV2 = new Vector2()\n      const tempV3 = new Vector3()\n\n      const currentTransform = new Matrix3()\n\n      const xml = new DOMParser().parseFromString(text, 'image/svg+xml') // application/xml\n\n      parseNode(xml.documentElement, {\n        fill: '#000',\n        fillOpacity: 1,\n        strokeOpacity: 1,\n        strokeWidth: 1,\n        strokeLineJoin: 'miter',\n        strokeLineCap: 'butt',\n        strokeMiterLimit: 4,\n      })\n\n      const data = { paths: paths, xml: xml.documentElement }\n\n      // console.log( paths );\n      return data\n    }\n\n    static createShapes(shapePath) {\n      // Param shapePath: a shapepath as returned by the parse function of this class\n      // Returns Shape object\n\n      const BIGNUMBER = 999999999\n\n      const IntersectionLocationType = {\n        ORIGIN: 0,\n        DESTINATION: 1,\n        BETWEEN: 2,\n        LEFT: 3,\n        RIGHT: 4,\n        BEHIND: 5,\n        BEYOND: 6,\n      }\n\n      const classifyResult = {\n        loc: IntersectionLocationType.ORIGIN,\n        t: 0,\n      }\n\n      function findEdgeIntersection(a0, a1, b0, b1) {\n        const x1 = a0.x\n        const x2 = a1.x\n        const x3 = b0.x\n        const x4 = b1.x\n        const y1 = a0.y\n        const y2 = a1.y\n        const y3 = b0.y\n        const y4 = b1.y\n        const nom1 = (x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3)\n        const nom2 = (x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3)\n        const denom = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1)\n        const t1 = nom1 / denom\n        const t2 = nom2 / denom\n\n        if ((denom === 0 && nom1 !== 0) || t1 <= 0 || t1 >= 1 || t2 < 0 || t2 > 1) {\n          //1. lines are parallel or edges don't intersect\n\n          return null\n        } else if (nom1 === 0 && denom === 0) {\n          //2. lines are colinear\n\n          //check if endpoints of edge2 (b0-b1) lies on edge1 (a0-a1)\n          for (let i = 0; i < 2; i++) {\n            classifyPoint(i === 0 ? b0 : b1, a0, a1)\n            //find position of this endpoints relatively to edge1\n            if (classifyResult.loc == IntersectionLocationType.ORIGIN) {\n              const point = i === 0 ? b0 : b1\n              return { x: point.x, y: point.y, t: classifyResult.t }\n            } else if (classifyResult.loc == IntersectionLocationType.BETWEEN) {\n              const x = +(x1 + classifyResult.t * (x2 - x1)).toPrecision(10)\n              const y = +(y1 + classifyResult.t * (y2 - y1)).toPrecision(10)\n              return { x: x, y: y, t: classifyResult.t }\n            }\n          }\n\n          return null\n        } else {\n          //3. edges intersect\n\n          for (let i = 0; i < 2; i++) {\n            classifyPoint(i === 0 ? b0 : b1, a0, a1)\n\n            if (classifyResult.loc == IntersectionLocationType.ORIGIN) {\n              const point = i === 0 ? b0 : b1\n              return { x: point.x, y: point.y, t: classifyResult.t }\n            }\n          }\n\n          const x = +(x1 + t1 * (x2 - x1)).toPrecision(10)\n          const y = +(y1 + t1 * (y2 - y1)).toPrecision(10)\n          return { x: x, y: y, t: t1 }\n        }\n      }\n\n      function classifyPoint(p, edgeStart, edgeEnd) {\n        const ax = edgeEnd.x - edgeStart.x\n        const ay = edgeEnd.y - edgeStart.y\n        const bx = p.x - edgeStart.x\n        const by = p.y - edgeStart.y\n        const sa = ax * by - bx * ay\n\n        if (p.x === edgeStart.x && p.y === edgeStart.y) {\n          classifyResult.loc = IntersectionLocationType.ORIGIN\n          classifyResult.t = 0\n          return\n        }\n\n        if (p.x === edgeEnd.x && p.y === edgeEnd.y) {\n          classifyResult.loc = IntersectionLocationType.DESTINATION\n          classifyResult.t = 1\n          return\n        }\n\n        if (sa < -Number.EPSILON) {\n          classifyResult.loc = IntersectionLocationType.LEFT\n          return\n        }\n\n        if (sa > Number.EPSILON) {\n          classifyResult.loc = IntersectionLocationType.RIGHT\n          return\n        }\n\n        if (ax * bx < 0 || ay * by < 0) {\n          classifyResult.loc = IntersectionLocationType.BEHIND\n          return\n        }\n\n        if (Math.sqrt(ax * ax + ay * ay) < Math.sqrt(bx * bx + by * by)) {\n          classifyResult.loc = IntersectionLocationType.BEYOND\n          return\n        }\n\n        let t\n\n        if (ax !== 0) {\n          t = bx / ax\n        } else {\n          t = by / ay\n        }\n\n        classifyResult.loc = IntersectionLocationType.BETWEEN\n        classifyResult.t = t\n      }\n\n      function getIntersections(path1, path2) {\n        const intersectionsRaw = []\n        const intersections = []\n\n        for (let index = 1; index < path1.length; index++) {\n          const path1EdgeStart = path1[index - 1]\n          const path1EdgeEnd = path1[index]\n\n          for (let index2 = 1; index2 < path2.length; index2++) {\n            const path2EdgeStart = path2[index2 - 1]\n            const path2EdgeEnd = path2[index2]\n\n            const intersection = findEdgeIntersection(path1EdgeStart, path1EdgeEnd, path2EdgeStart, path2EdgeEnd)\n\n            if (\n              intersection !== null &&\n              intersectionsRaw.find(\n                (i) => i.t <= intersection.t + Number.EPSILON && i.t >= intersection.t - Number.EPSILON,\n              ) === undefined\n            ) {\n              intersectionsRaw.push(intersection)\n              intersections.push(new Vector2(intersection.x, intersection.y))\n            }\n          }\n        }\n\n        return intersections\n      }\n\n      function getScanlineIntersections(scanline, boundingBox, paths) {\n        const center = new Vector2()\n        boundingBox.getCenter(center)\n\n        const allIntersections = []\n\n        paths.forEach((path) => {\n          // check if the center of the bounding box is in the bounding box of the paths.\n          // this is a pruning method to limit the search of intersections in paths that can't envelop of the current path.\n          // if a path envelops another path. The center of that oter path, has to be inside the bounding box of the enveloping path.\n          if (path.boundingBox.containsPoint(center)) {\n            const intersections = getIntersections(scanline, path.points)\n\n            intersections.forEach((p) => {\n              allIntersections.push({ identifier: path.identifier, isCW: path.isCW, point: p })\n            })\n          }\n        })\n\n        allIntersections.sort((i1, i2) => {\n          return i1.point.x - i2.point.x\n        })\n\n        return allIntersections\n      }\n\n      function isHoleTo(simplePath, allPaths, scanlineMinX, scanlineMaxX, _fillRule) {\n        if (_fillRule === null || _fillRule === undefined || _fillRule === '') {\n          _fillRule = 'nonzero'\n        }\n\n        const centerBoundingBox = new Vector2()\n        simplePath.boundingBox.getCenter(centerBoundingBox)\n\n        const scanline = [\n          new Vector2(scanlineMinX, centerBoundingBox.y),\n          new Vector2(scanlineMaxX, centerBoundingBox.y),\n        ]\n\n        const scanlineIntersections = getScanlineIntersections(scanline, simplePath.boundingBox, allPaths)\n\n        scanlineIntersections.sort((i1, i2) => {\n          return i1.point.x - i2.point.x\n        })\n\n        const baseIntersections = []\n        const otherIntersections = []\n\n        scanlineIntersections.forEach((i) => {\n          if (i.identifier === simplePath.identifier) {\n            baseIntersections.push(i)\n          } else {\n            otherIntersections.push(i)\n          }\n        })\n\n        const firstXOfPath = baseIntersections[0].point.x\n\n        // build up the path hierarchy\n        const stack = []\n        let i = 0\n\n        while (i < otherIntersections.length && otherIntersections[i].point.x < firstXOfPath) {\n          if (stack.length > 0 && stack[stack.length - 1] === otherIntersections[i].identifier) {\n            stack.pop()\n          } else {\n            stack.push(otherIntersections[i].identifier)\n          }\n\n          i++\n        }\n\n        stack.push(simplePath.identifier)\n\n        if (_fillRule === 'evenodd') {\n          const isHole = stack.length % 2 === 0 ? true : false\n          const isHoleFor = stack[stack.length - 2]\n\n          return { identifier: simplePath.identifier, isHole: isHole, for: isHoleFor }\n        } else if (_fillRule === 'nonzero') {\n          // check if path is a hole by counting the amount of paths with alternating rotations it has to cross.\n          let isHole = true\n          let isHoleFor = null\n          let lastCWValue = null\n\n          for (let i = 0; i < stack.length; i++) {\n            const identifier = stack[i]\n            if (isHole) {\n              lastCWValue = allPaths[identifier].isCW\n              isHole = false\n              isHoleFor = identifier\n            } else if (lastCWValue !== allPaths[identifier].isCW) {\n              lastCWValue = allPaths[identifier].isCW\n              isHole = true\n            }\n          }\n\n          return { identifier: simplePath.identifier, isHole: isHole, for: isHoleFor }\n        } else {\n          console.warn('fill-rule: \"' + _fillRule + '\" is currently not implemented.')\n        }\n      }\n\n      // check for self intersecting paths\n      // TODO\n\n      // check intersecting paths\n      // TODO\n\n      // prepare paths for hole detection\n      let scanlineMinX = BIGNUMBER\n      let scanlineMaxX = -BIGNUMBER\n\n      let simplePaths = shapePath.subPaths.map((p) => {\n        const points = p.getPoints()\n        let maxY = -BIGNUMBER\n        let minY = BIGNUMBER\n        let maxX = -BIGNUMBER\n        let minX = BIGNUMBER\n\n        //points.forEach(p => p.y *= -1);\n\n        for (let i = 0; i < points.length; i++) {\n          const p = points[i]\n\n          if (p.y > maxY) {\n            maxY = p.y\n          }\n\n          if (p.y < minY) {\n            minY = p.y\n          }\n\n          if (p.x > maxX) {\n            maxX = p.x\n          }\n\n          if (p.x < minX) {\n            minX = p.x\n          }\n        }\n\n        //\n        if (scanlineMaxX <= maxX) {\n          scanlineMaxX = maxX + 1\n        }\n\n        if (scanlineMinX >= minX) {\n          scanlineMinX = minX - 1\n        }\n\n        return {\n          curves: p.curves,\n          points: points,\n          isCW: ShapeUtils.isClockWise(points),\n          identifier: -1,\n          boundingBox: new Box2(new Vector2(minX, minY), new Vector2(maxX, maxY)),\n        }\n      })\n\n      simplePaths = simplePaths.filter((sp) => sp.points.length > 1)\n\n      for (let identifier = 0; identifier < simplePaths.length; identifier++) {\n        simplePaths[identifier].identifier = identifier\n      }\n\n      // check if path is solid or a hole\n      const isAHole = simplePaths.map((p) =>\n        isHoleTo(\n          p,\n          simplePaths,\n          scanlineMinX,\n          scanlineMaxX,\n          shapePath.userData ? shapePath.userData.style.fillRule : undefined,\n        ),\n      )\n\n      const shapesToReturn = []\n      simplePaths.forEach((p) => {\n        const amIAHole = isAHole[p.identifier]\n\n        if (!amIAHole.isHole) {\n          const shape = new Shape()\n          shape.curves = p.curves\n          const holes = isAHole.filter((h) => h.isHole && h.for === p.identifier)\n          holes.forEach((h) => {\n            const hole = simplePaths[h.identifier]\n            const path = new Path()\n            path.curves = hole.curves\n            shape.holes.push(path)\n          })\n          shapesToReturn.push(shape)\n        }\n      })\n\n      return shapesToReturn\n    }\n\n    static getStrokeStyle(width, color, lineJoin, lineCap, miterLimit) {\n      // Param width: Stroke width\n      // Param color: As returned by THREE.Color.getStyle()\n      // Param lineJoin: One of \"round\", \"bevel\", \"miter\" or \"miter-limit\"\n      // Param lineCap: One of \"round\", \"square\" or \"butt\"\n      // Param miterLimit: Maximum join length, in multiples of the \"width\" parameter (join is truncated if it exceeds that distance)\n      // Returns style object\n\n      width = width !== undefined ? width : 1\n      color = color !== undefined ? color : '#000'\n      lineJoin = lineJoin !== undefined ? lineJoin : 'miter'\n      lineCap = lineCap !== undefined ? lineCap : 'butt'\n      miterLimit = miterLimit !== undefined ? miterLimit : 4\n\n      return {\n        strokeColor: color,\n        strokeWidth: width,\n        strokeLineJoin: lineJoin,\n        strokeLineCap: lineCap,\n        strokeMiterLimit: miterLimit,\n      }\n    }\n\n    static pointsToStroke(points, style, arcDivisions, minDistance) {\n      // Generates a stroke with some width around the given path.\n      // The path can be open or closed (last point equals to first point)\n      // Param points: Array of Vector2D (the path). Minimum 2 points.\n      // Param style: Object with SVG properties as returned by SVGLoader.getStrokeStyle(), or SVGLoader.parse() in the path.userData.style object\n      // Params arcDivisions: Arc divisions for round joins and endcaps. (Optional)\n      // Param minDistance: Points closer to this distance will be merged. (Optional)\n      // Returns BufferGeometry with stroke triangles (In plane z = 0). UV coordinates are generated ('u' along path. 'v' across it, from left to right)\n\n      const vertices = []\n      const normals = []\n      const uvs = []\n\n      if (SVGLoader.pointsToStrokeWithBuffers(points, style, arcDivisions, minDistance, vertices, normals, uvs) === 0) {\n        return null\n      }\n\n      const geometry = new BufferGeometry()\n      geometry.setAttribute('position', new Float32BufferAttribute(vertices, 3))\n      geometry.setAttribute('normal', new Float32BufferAttribute(normals, 3))\n      geometry.setAttribute('uv', new Float32BufferAttribute(uvs, 2))\n\n      return geometry\n    }\n\n    static pointsToStrokeWithBuffers(points, style, arcDivisions, minDistance, vertices, normals, uvs, vertexOffset) {\n      // This function can be called to update existing arrays or buffers.\n      // Accepts same parameters as pointsToStroke, plus the buffers and optional offset.\n      // Param vertexOffset: Offset vertices to start writing in the buffers (3 elements/vertex for vertices and normals, and 2 elements/vertex for uvs)\n      // Returns number of written vertices / normals / uvs pairs\n      // if 'vertices' parameter is undefined no triangles will be generated, but the returned vertices count will still be valid (useful to preallocate the buffers)\n      // 'normals' and 'uvs' buffers are optional\n\n      const tempV2_1 = new Vector2()\n      const tempV2_2 = new Vector2()\n      const tempV2_3 = new Vector2()\n      const tempV2_4 = new Vector2()\n      const tempV2_5 = new Vector2()\n      const tempV2_6 = new Vector2()\n      const tempV2_7 = new Vector2()\n      const lastPointL = new Vector2()\n      const lastPointR = new Vector2()\n      const point0L = new Vector2()\n      const point0R = new Vector2()\n      const currentPointL = new Vector2()\n      const currentPointR = new Vector2()\n      const nextPointL = new Vector2()\n      const nextPointR = new Vector2()\n      const innerPoint = new Vector2()\n      const outerPoint = new Vector2()\n\n      arcDivisions = arcDivisions !== undefined ? arcDivisions : 12\n      minDistance = minDistance !== undefined ? minDistance : 0.001\n      vertexOffset = vertexOffset !== undefined ? vertexOffset : 0\n\n      // First ensure there are no duplicated points\n      points = removeDuplicatedPoints(points)\n\n      const numPoints = points.length\n\n      if (numPoints < 2) return 0\n\n      const isClosed = points[0].equals(points[numPoints - 1])\n\n      let currentPoint\n      let previousPoint = points[0]\n      let nextPoint\n\n      const strokeWidth2 = style.strokeWidth / 2\n\n      const deltaU = 1 / (numPoints - 1)\n      let u0 = 0,\n        u1\n\n      let innerSideModified\n      let joinIsOnLeftSide\n      let isMiter\n      let initialJoinIsOnLeftSide = false\n\n      let numVertices = 0\n      let currentCoordinate = vertexOffset * 3\n      let currentCoordinateUV = vertexOffset * 2\n\n      // Get initial left and right stroke points\n      getNormal(points[0], points[1], tempV2_1).multiplyScalar(strokeWidth2)\n      lastPointL.copy(points[0]).sub(tempV2_1)\n      lastPointR.copy(points[0]).add(tempV2_1)\n      point0L.copy(lastPointL)\n      point0R.copy(lastPointR)\n\n      for (let iPoint = 1; iPoint < numPoints; iPoint++) {\n        currentPoint = points[iPoint]\n\n        // Get next point\n        if (iPoint === numPoints - 1) {\n          if (isClosed) {\n            // Skip duplicated initial point\n            nextPoint = points[1]\n          } else nextPoint = undefined\n        } else {\n          nextPoint = points[iPoint + 1]\n        }\n\n        // Normal of previous segment in tempV2_1\n        const normal1 = tempV2_1\n        getNormal(previousPoint, currentPoint, normal1)\n\n        tempV2_3.copy(normal1).multiplyScalar(strokeWidth2)\n        currentPointL.copy(currentPoint).sub(tempV2_3)\n        currentPointR.copy(currentPoint).add(tempV2_3)\n\n        u1 = u0 + deltaU\n\n        innerSideModified = false\n\n        if (nextPoint !== undefined) {\n          // Normal of next segment in tempV2_2\n          getNormal(currentPoint, nextPoint, tempV2_2)\n\n          tempV2_3.copy(tempV2_2).multiplyScalar(strokeWidth2)\n          nextPointL.copy(currentPoint).sub(tempV2_3)\n          nextPointR.copy(currentPoint).add(tempV2_3)\n\n          joinIsOnLeftSide = true\n          tempV2_3.subVectors(nextPoint, previousPoint)\n          if (normal1.dot(tempV2_3) < 0) {\n            joinIsOnLeftSide = false\n          }\n\n          if (iPoint === 1) initialJoinIsOnLeftSide = joinIsOnLeftSide\n\n          tempV2_3.subVectors(nextPoint, currentPoint)\n          tempV2_3.normalize()\n          const dot = Math.abs(normal1.dot(tempV2_3))\n\n          // If path is straight, don't create join\n          if (dot > Number.EPSILON) {\n            // Compute inner and outer segment intersections\n            const miterSide = strokeWidth2 / dot\n            tempV2_3.multiplyScalar(-miterSide)\n            tempV2_4.subVectors(currentPoint, previousPoint)\n            tempV2_5.copy(tempV2_4).setLength(miterSide).add(tempV2_3)\n            innerPoint.copy(tempV2_5).negate()\n            const miterLength2 = tempV2_5.length()\n            const segmentLengthPrev = tempV2_4.length()\n            tempV2_4.divideScalar(segmentLengthPrev)\n            tempV2_6.subVectors(nextPoint, currentPoint)\n            const segmentLengthNext = tempV2_6.length()\n            tempV2_6.divideScalar(segmentLengthNext)\n            // Check that previous and next segments doesn't overlap with the innerPoint of intersection\n            if (tempV2_4.dot(innerPoint) < segmentLengthPrev && tempV2_6.dot(innerPoint) < segmentLengthNext) {\n              innerSideModified = true\n            }\n\n            outerPoint.copy(tempV2_5).add(currentPoint)\n            innerPoint.add(currentPoint)\n\n            isMiter = false\n\n            if (innerSideModified) {\n              if (joinIsOnLeftSide) {\n                nextPointR.copy(innerPoint)\n                currentPointR.copy(innerPoint)\n              } else {\n                nextPointL.copy(innerPoint)\n                currentPointL.copy(innerPoint)\n              }\n            } else {\n              // The segment triangles are generated here if there was overlapping\n\n              makeSegmentTriangles()\n            }\n\n            switch (style.strokeLineJoin) {\n              case 'bevel':\n                makeSegmentWithBevelJoin(joinIsOnLeftSide, innerSideModified, u1)\n\n                break\n\n              case 'round':\n                // Segment triangles\n\n                createSegmentTrianglesWithMiddleSection(joinIsOnLeftSide, innerSideModified)\n\n                // Join triangles\n\n                if (joinIsOnLeftSide) {\n                  makeCircularSector(currentPoint, currentPointL, nextPointL, u1, 0)\n                } else {\n                  makeCircularSector(currentPoint, nextPointR, currentPointR, u1, 1)\n                }\n\n                break\n\n              case 'miter':\n              case 'miter-clip':\n              default:\n                const miterFraction = (strokeWidth2 * style.strokeMiterLimit) / miterLength2\n\n                if (miterFraction < 1) {\n                  // The join miter length exceeds the miter limit\n\n                  if (style.strokeLineJoin !== 'miter-clip') {\n                    makeSegmentWithBevelJoin(joinIsOnLeftSide, innerSideModified, u1)\n                    break\n                  } else {\n                    // Segment triangles\n\n                    createSegmentTrianglesWithMiddleSection(joinIsOnLeftSide, innerSideModified)\n\n                    // Miter-clip join triangles\n\n                    if (joinIsOnLeftSide) {\n                      tempV2_6.subVectors(outerPoint, currentPointL).multiplyScalar(miterFraction).add(currentPointL)\n                      tempV2_7.subVectors(outerPoint, nextPointL).multiplyScalar(miterFraction).add(nextPointL)\n\n                      addVertex(currentPointL, u1, 0)\n                      addVertex(tempV2_6, u1, 0)\n                      addVertex(currentPoint, u1, 0.5)\n\n                      addVertex(currentPoint, u1, 0.5)\n                      addVertex(tempV2_6, u1, 0)\n                      addVertex(tempV2_7, u1, 0)\n\n                      addVertex(currentPoint, u1, 0.5)\n                      addVertex(tempV2_7, u1, 0)\n                      addVertex(nextPointL, u1, 0)\n                    } else {\n                      tempV2_6.subVectors(outerPoint, currentPointR).multiplyScalar(miterFraction).add(currentPointR)\n                      tempV2_7.subVectors(outerPoint, nextPointR).multiplyScalar(miterFraction).add(nextPointR)\n\n                      addVertex(currentPointR, u1, 1)\n                      addVertex(tempV2_6, u1, 1)\n                      addVertex(currentPoint, u1, 0.5)\n\n                      addVertex(currentPoint, u1, 0.5)\n                      addVertex(tempV2_6, u1, 1)\n                      addVertex(tempV2_7, u1, 1)\n\n                      addVertex(currentPoint, u1, 0.5)\n                      addVertex(tempV2_7, u1, 1)\n                      addVertex(nextPointR, u1, 1)\n                    }\n                  }\n                } else {\n                  // Miter join segment triangles\n\n                  if (innerSideModified) {\n                    // Optimized segment + join triangles\n\n                    if (joinIsOnLeftSide) {\n                      addVertex(lastPointR, u0, 1)\n                      addVertex(lastPointL, u0, 0)\n                      addVertex(outerPoint, u1, 0)\n\n                      addVertex(lastPointR, u0, 1)\n                      addVertex(outerPoint, u1, 0)\n                      addVertex(innerPoint, u1, 1)\n                    } else {\n                      addVertex(lastPointR, u0, 1)\n                      addVertex(lastPointL, u0, 0)\n                      addVertex(outerPoint, u1, 1)\n\n                      addVertex(lastPointL, u0, 0)\n                      addVertex(innerPoint, u1, 0)\n                      addVertex(outerPoint, u1, 1)\n                    }\n\n                    if (joinIsOnLeftSide) {\n                      nextPointL.copy(outerPoint)\n                    } else {\n                      nextPointR.copy(outerPoint)\n                    }\n                  } else {\n                    // Add extra miter join triangles\n\n                    if (joinIsOnLeftSide) {\n                      addVertex(currentPointL, u1, 0)\n                      addVertex(outerPoint, u1, 0)\n                      addVertex(currentPoint, u1, 0.5)\n\n                      addVertex(currentPoint, u1, 0.5)\n                      addVertex(outerPoint, u1, 0)\n                      addVertex(nextPointL, u1, 0)\n                    } else {\n                      addVertex(currentPointR, u1, 1)\n                      addVertex(outerPoint, u1, 1)\n                      addVertex(currentPoint, u1, 0.5)\n\n                      addVertex(currentPoint, u1, 0.5)\n                      addVertex(outerPoint, u1, 1)\n                      addVertex(nextPointR, u1, 1)\n                    }\n                  }\n\n                  isMiter = true\n                }\n\n                break\n            }\n          } else {\n            // The segment triangles are generated here when two consecutive points are collinear\n\n            makeSegmentTriangles()\n          }\n        } else {\n          // The segment triangles are generated here if it is the ending segment\n\n          makeSegmentTriangles()\n        }\n\n        if (!isClosed && iPoint === numPoints - 1) {\n          // Start line endcap\n          addCapGeometry(points[0], point0L, point0R, joinIsOnLeftSide, true, u0)\n        }\n\n        // Increment loop variables\n\n        u0 = u1\n\n        previousPoint = currentPoint\n\n        lastPointL.copy(nextPointL)\n        lastPointR.copy(nextPointR)\n      }\n\n      if (!isClosed) {\n        // Ending line endcap\n        addCapGeometry(currentPoint, currentPointL, currentPointR, joinIsOnLeftSide, false, u1)\n      } else if (innerSideModified && vertices) {\n        // Modify path first segment vertices to adjust to the segments inner and outer intersections\n\n        let lastOuter = outerPoint\n        let lastInner = innerPoint\n\n        if (initialJoinIsOnLeftSide !== joinIsOnLeftSide) {\n          lastOuter = innerPoint\n          lastInner = outerPoint\n        }\n\n        if (joinIsOnLeftSide) {\n          if (isMiter || initialJoinIsOnLeftSide) {\n            lastInner.toArray(vertices, 0 * 3)\n            lastInner.toArray(vertices, 3 * 3)\n\n            if (isMiter) {\n              lastOuter.toArray(vertices, 1 * 3)\n            }\n          }\n        } else {\n          if (isMiter || !initialJoinIsOnLeftSide) {\n            lastInner.toArray(vertices, 1 * 3)\n            lastInner.toArray(vertices, 3 * 3)\n\n            if (isMiter) {\n              lastOuter.toArray(vertices, 0 * 3)\n            }\n          }\n        }\n      }\n\n      return numVertices\n\n      // -- End of algorithm\n\n      // -- Functions\n\n      function getNormal(p1, p2, result) {\n        result.subVectors(p2, p1)\n        return result.set(-result.y, result.x).normalize()\n      }\n\n      function addVertex(position, u, v) {\n        if (vertices) {\n          vertices[currentCoordinate] = position.x\n          vertices[currentCoordinate + 1] = position.y\n          vertices[currentCoordinate + 2] = 0\n\n          if (normals) {\n            normals[currentCoordinate] = 0\n            normals[currentCoordinate + 1] = 0\n            normals[currentCoordinate + 2] = 1\n          }\n\n          currentCoordinate += 3\n\n          if (uvs) {\n            uvs[currentCoordinateUV] = u\n            uvs[currentCoordinateUV + 1] = v\n\n            currentCoordinateUV += 2\n          }\n        }\n\n        numVertices += 3\n      }\n\n      function makeCircularSector(center, p1, p2, u, v) {\n        // param p1, p2: Points in the circle arc.\n        // p1 and p2 are in clockwise direction.\n\n        tempV2_1.copy(p1).sub(center).normalize()\n        tempV2_2.copy(p2).sub(center).normalize()\n\n        let angle = Math.PI\n        const dot = tempV2_1.dot(tempV2_2)\n        if (Math.abs(dot) < 1) angle = Math.abs(Math.acos(dot))\n\n        angle /= arcDivisions\n\n        tempV2_3.copy(p1)\n\n        for (let i = 0, il = arcDivisions - 1; i < il; i++) {\n          tempV2_4.copy(tempV2_3).rotateAround(center, angle)\n\n          addVertex(tempV2_3, u, v)\n          addVertex(tempV2_4, u, v)\n          addVertex(center, u, 0.5)\n\n          tempV2_3.copy(tempV2_4)\n        }\n\n        addVertex(tempV2_4, u, v)\n        addVertex(p2, u, v)\n        addVertex(center, u, 0.5)\n      }\n\n      function makeSegmentTriangles() {\n        addVertex(lastPointR, u0, 1)\n        addVertex(lastPointL, u0, 0)\n        addVertex(currentPointL, u1, 0)\n\n        addVertex(lastPointR, u0, 1)\n        addVertex(currentPointL, u1, 0)\n        addVertex(currentPointR, u1, 1)\n      }\n\n      function makeSegmentWithBevelJoin(joinIsOnLeftSide, innerSideModified, u) {\n        if (innerSideModified) {\n          // Optimized segment + bevel triangles\n\n          if (joinIsOnLeftSide) {\n            // Path segments triangles\n\n            addVertex(lastPointR, u0, 1)\n            addVertex(lastPointL, u0, 0)\n            addVertex(currentPointL, u1, 0)\n\n            addVertex(lastPointR, u0, 1)\n            addVertex(currentPointL, u1, 0)\n            addVertex(innerPoint, u1, 1)\n\n            // Bevel join triangle\n\n            addVertex(currentPointL, u, 0)\n            addVertex(nextPointL, u, 0)\n            addVertex(innerPoint, u, 0.5)\n          } else {\n            // Path segments triangles\n\n            addVertex(lastPointR, u0, 1)\n            addVertex(lastPointL, u0, 0)\n            addVertex(currentPointR, u1, 1)\n\n            addVertex(lastPointL, u0, 0)\n            addVertex(innerPoint, u1, 0)\n            addVertex(currentPointR, u1, 1)\n\n            // Bevel join triangle\n\n            addVertex(currentPointR, u, 1)\n            addVertex(innerPoint, u, 0)\n            addVertex(nextPointR, u, 1)\n          }\n        } else {\n          // Bevel join triangle. The segment triangles are done in the main loop\n\n          if (joinIsOnLeftSide) {\n            addVertex(currentPointL, u, 0)\n            addVertex(nextPointL, u, 0)\n            addVertex(currentPoint, u, 0.5)\n          } else {\n            addVertex(currentPointR, u, 1)\n            addVertex(nextPointR, u, 0)\n            addVertex(currentPoint, u, 0.5)\n          }\n        }\n      }\n\n      function createSegmentTrianglesWithMiddleSection(joinIsOnLeftSide, innerSideModified) {\n        if (innerSideModified) {\n          if (joinIsOnLeftSide) {\n            addVertex(lastPointR, u0, 1)\n            addVertex(lastPointL, u0, 0)\n            addVertex(currentPointL, u1, 0)\n\n            addVertex(lastPointR, u0, 1)\n            addVertex(currentPointL, u1, 0)\n            addVertex(innerPoint, u1, 1)\n\n            addVertex(currentPointL, u0, 0)\n            addVertex(currentPoint, u1, 0.5)\n            addVertex(innerPoint, u1, 1)\n\n            addVertex(currentPoint, u1, 0.5)\n            addVertex(nextPointL, u0, 0)\n            addVertex(innerPoint, u1, 1)\n          } else {\n            addVertex(lastPointR, u0, 1)\n            addVertex(lastPointL, u0, 0)\n            addVertex(currentPointR, u1, 1)\n\n            addVertex(lastPointL, u0, 0)\n            addVertex(innerPoint, u1, 0)\n            addVertex(currentPointR, u1, 1)\n\n            addVertex(currentPointR, u0, 1)\n            addVertex(innerPoint, u1, 0)\n            addVertex(currentPoint, u1, 0.5)\n\n            addVertex(currentPoint, u1, 0.5)\n            addVertex(innerPoint, u1, 0)\n            addVertex(nextPointR, u0, 1)\n          }\n        }\n      }\n\n      function addCapGeometry(center, p1, p2, joinIsOnLeftSide, start, u) {\n        // param center: End point of the path\n        // param p1, p2: Left and right cap points\n\n        switch (style.strokeLineCap) {\n          case 'round':\n            if (start) {\n              makeCircularSector(center, p2, p1, u, 0.5)\n            } else {\n              makeCircularSector(center, p1, p2, u, 0.5)\n            }\n\n            break\n\n          case 'square':\n            if (start) {\n              tempV2_1.subVectors(p1, center)\n              tempV2_2.set(tempV2_1.y, -tempV2_1.x)\n\n              tempV2_3.addVectors(tempV2_1, tempV2_2).add(center)\n              tempV2_4.subVectors(tempV2_2, tempV2_1).add(center)\n\n              // Modify already existing vertices\n              if (joinIsOnLeftSide) {\n                tempV2_3.toArray(vertices, 1 * 3)\n                tempV2_4.toArray(vertices, 0 * 3)\n                tempV2_4.toArray(vertices, 3 * 3)\n              } else {\n                tempV2_3.toArray(vertices, 1 * 3)\n                // using tempV2_4 to update 3rd vertex if the uv.y of 3rd vertex is 1\n                uvs[3 * 2 + 1] === 1 ? tempV2_4.toArray(vertices, 3 * 3) : tempV2_3.toArray(vertices, 3 * 3)\n                tempV2_4.toArray(vertices, 0 * 3)\n              }\n            } else {\n              tempV2_1.subVectors(p2, center)\n              tempV2_2.set(tempV2_1.y, -tempV2_1.x)\n\n              tempV2_3.addVectors(tempV2_1, tempV2_2).add(center)\n              tempV2_4.subVectors(tempV2_2, tempV2_1).add(center)\n\n              const vl = vertices.length\n\n              // Modify already existing vertices\n              if (joinIsOnLeftSide) {\n                tempV2_3.toArray(vertices, vl - 1 * 3)\n                tempV2_4.toArray(vertices, vl - 2 * 3)\n                tempV2_4.toArray(vertices, vl - 4 * 3)\n              } else {\n                tempV2_4.toArray(vertices, vl - 2 * 3)\n                tempV2_3.toArray(vertices, vl - 1 * 3)\n                tempV2_4.toArray(vertices, vl - 4 * 3)\n              }\n            }\n\n            break\n\n          case 'butt':\n          default:\n            // Nothing to do here\n            break\n        }\n      }\n\n      function removeDuplicatedPoints(points) {\n        // Creates a new array if necessary with duplicated points removed.\n        // This does not remove duplicated initial and ending points of a closed path.\n\n        let dupPoints = false\n        for (let i = 1, n = points.length - 1; i < n; i++) {\n          if (points[i].distanceTo(points[i + 1]) < minDistance) {\n            dupPoints = true\n            break\n          }\n        }\n\n        if (!dupPoints) return points\n\n        const newPoints = []\n        newPoints.push(points[0])\n\n        for (let i = 1, n = points.length - 1; i < n; i++) {\n          if (points[i].distanceTo(points[i + 1]) >= minDistance) {\n            newPoints.push(points[i])\n          }\n        }\n\n        newPoints.push(points[points.length - 1])\n\n        return newPoints\n      }\n    }\n  }\n\n  return SVGLoader\n})()\n\nexport { SVGLoader }\n"],"names":["SVGLoader","node","data","i","current","currentTransform","scanlineMinX","scanlineMaxX","p","joinIsOnLeftSide","innerSideModified","points"],"mappings":"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","debugId":null}},
    {"offset": {"line": 1918, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/three-stdlib@2.36.1_three@0.182.0/node_modules/three-stdlib/loaders/GLTFLoader.js","sources":["file:///C:/coqueli/frontend/node_modules/.pnpm/three-stdlib%402.36.1_three%400.182.0/node_modules/src/loaders/GLTFLoader.js"],"sourcesContent":["import {\n  AnimationClip,\n  Bone,\n  Box3,\n  BufferAttribute,\n  BufferGeometry,\n  ClampToEdgeWrapping,\n  Color,\n  DirectionalLight,\n  DoubleSide,\n  FileLoader,\n  FrontSide,\n  Group,\n  ImageBitmapLoader,\n  InstancedMesh,\n  InterleavedBuffer,\n  InterleavedBufferAttribute,\n  Interpolant,\n  InterpolateDiscrete,\n  InterpolateLinear,\n  Line,\n  LineBasicMaterial,\n  LineLoop,\n  LineSegments,\n  LinearFilter,\n  LinearMipmapLinearFilter,\n  LinearMipmapNearestFilter,\n  Loader,\n  LoaderUtils,\n  Material,\n  MathUtils,\n  Matrix4,\n  Mesh,\n  MeshBasicMaterial,\n  MeshPhysicalMaterial,\n  MeshStandardMaterial,\n  MirroredRepeatWrapping,\n  NearestFilter,\n  NearestMipmapLinearFilter,\n  NearestMipmapNearestFilter,\n  NumberKeyframeTrack,\n  Object3D,\n  OrthographicCamera,\n  PerspectiveCamera,\n  PointLight,\n  Points,\n  PointsMaterial,\n  PropertyBinding,\n  Quaternion,\n  QuaternionKeyframeTrack,\n  RepeatWrapping,\n  Skeleton,\n  SkinnedMesh,\n  Sphere,\n  SpotLight,\n  Texture,\n  TextureLoader,\n  TriangleFanDrawMode,\n  TriangleStripDrawMode,\n  Vector2,\n  Vector3,\n  VectorKeyframeTrack,\n  InstancedBufferAttribute,\n} from 'three'\nimport { toTrianglesDrawMode } from '../utils/BufferGeometryUtils'\nimport { version } from '../_polyfill/constants'\nimport { decodeText } from '../_polyfill/LoaderUtils'\n\nconst SRGBColorSpace = 'srgb'\nconst LinearSRGBColorSpace = 'srgb-linear'\nconst sRGBEncoding = 3001\nconst LinearEncoding = 3000\n\nclass GLTFLoader extends Loader {\n  constructor(manager) {\n    super(manager)\n\n    this.dracoLoader = null\n    this.ktx2Loader = null\n    this.meshoptDecoder = null\n\n    this.pluginCallbacks = []\n\n    this.register(function (parser) {\n      return new GLTFMaterialsClearcoatExtension(parser)\n    })\n\n    this.register(function (parser) {\n      return new GLTFMaterialsDispersionExtension(parser)\n    })\n\n    this.register(function (parser) {\n      return new GLTFTextureBasisUExtension(parser)\n    })\n\n    this.register(function (parser) {\n      return new GLTFTextureWebPExtension(parser)\n    })\n\n    this.register(function (parser) {\n      return new GLTFTextureAVIFExtension(parser)\n    })\n\n    this.register(function (parser) {\n      return new GLTFMaterialsSheenExtension(parser)\n    })\n\n    this.register(function (parser) {\n      return new GLTFMaterialsTransmissionExtension(parser)\n    })\n\n    this.register(function (parser) {\n      return new GLTFMaterialsVolumeExtension(parser)\n    })\n\n    this.register(function (parser) {\n      return new GLTFMaterialsIorExtension(parser)\n    })\n\n    this.register(function (parser) {\n      return new GLTFMaterialsEmissiveStrengthExtension(parser)\n    })\n\n    this.register(function (parser) {\n      return new GLTFMaterialsSpecularExtension(parser)\n    })\n\n    this.register(function (parser) {\n      return new GLTFMaterialsIridescenceExtension(parser)\n    })\n\n    this.register(function (parser) {\n      return new GLTFMaterialsAnisotropyExtension(parser)\n    })\n\n    this.register(function (parser) {\n      return new GLTFMaterialsBumpExtension(parser)\n    })\n\n    this.register(function (parser) {\n      return new GLTFLightsExtension(parser)\n    })\n\n    this.register(function (parser) {\n      return new GLTFMeshoptCompression(parser)\n    })\n\n    this.register(function (parser) {\n      return new GLTFMeshGpuInstancing(parser)\n    })\n  }\n\n  load(url, onLoad, onProgress, onError) {\n    const scope = this\n\n    let resourcePath\n\n    if (this.resourcePath !== '') {\n      resourcePath = this.resourcePath\n    } else if (this.path !== '') {\n      // If a base path is set, resources will be relative paths from that plus the relative path of the gltf file\n      // Example  path = 'https://my-cnd-server.com/', url = 'assets/models/model.gltf'\n      // resourcePath = 'https://my-cnd-server.com/assets/models/'\n      // referenced resource 'model.bin' will be loaded from 'https://my-cnd-server.com/assets/models/model.bin'\n      // referenced resource '../textures/texture.png' will be loaded from 'https://my-cnd-server.com/assets/textures/texture.png'\n      const relativeUrl = LoaderUtils.extractUrlBase(url)\n      resourcePath = LoaderUtils.resolveURL(relativeUrl, this.path)\n    } else {\n      resourcePath = LoaderUtils.extractUrlBase(url)\n    }\n\n    // Tells the LoadingManager to track an extra item, which resolves after\n    // the model is fully loaded. This means the count of items loaded will\n    // be incorrect, but ensures manager.onLoad() does not fire early.\n    this.manager.itemStart(url)\n\n    const _onError = function (e) {\n      if (onError) {\n        onError(e)\n      } else {\n        console.error(e)\n      }\n\n      scope.manager.itemError(url)\n      scope.manager.itemEnd(url)\n    }\n\n    const loader = new FileLoader(this.manager)\n\n    loader.setPath(this.path)\n    loader.setResponseType('arraybuffer')\n    loader.setRequestHeader(this.requestHeader)\n    loader.setWithCredentials(this.withCredentials)\n\n    loader.load(\n      url,\n      function (data) {\n        try {\n          scope.parse(\n            data,\n            resourcePath,\n            function (gltf) {\n              onLoad(gltf)\n\n              scope.manager.itemEnd(url)\n            },\n            _onError,\n          )\n        } catch (e) {\n          _onError(e)\n        }\n      },\n      onProgress,\n      _onError,\n    )\n  }\n\n  setDRACOLoader(dracoLoader) {\n    this.dracoLoader = dracoLoader\n    return this\n  }\n\n  setDDSLoader() {\n    throw new Error('THREE.GLTFLoader: \"MSFT_texture_dds\" no longer supported. Please update to \"KHR_texture_basisu\".')\n  }\n\n  setKTX2Loader(ktx2Loader) {\n    this.ktx2Loader = ktx2Loader\n    return this\n  }\n\n  setMeshoptDecoder(meshoptDecoder) {\n    this.meshoptDecoder = meshoptDecoder\n    return this\n  }\n\n  register(callback) {\n    if (this.pluginCallbacks.indexOf(callback) === -1) {\n      this.pluginCallbacks.push(callback)\n    }\n\n    return this\n  }\n\n  unregister(callback) {\n    if (this.pluginCallbacks.indexOf(callback) !== -1) {\n      this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(callback), 1)\n    }\n\n    return this\n  }\n\n  parse(data, path, onLoad, onError) {\n    let json\n    const extensions = {}\n    const plugins = {}\n\n    if (typeof data === 'string') {\n      json = JSON.parse(data)\n    } else if (data instanceof ArrayBuffer) {\n      const magic = decodeText(new Uint8Array(data.slice(0, 4)))\n\n      if (magic === BINARY_EXTENSION_HEADER_MAGIC) {\n        try {\n          extensions[EXTENSIONS.KHR_BINARY_GLTF] = new GLTFBinaryExtension(data)\n        } catch (error) {\n          if (onError) onError(error)\n          return\n        }\n\n        json = JSON.parse(extensions[EXTENSIONS.KHR_BINARY_GLTF].content)\n      } else {\n        json = JSON.parse(decodeText(new Uint8Array(data)))\n      }\n    } else {\n      json = data\n    }\n\n    if (json.asset === undefined || json.asset.version[0] < 2) {\n      if (onError) onError(new Error('THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported.'))\n      return\n    }\n\n    const parser = new GLTFParser(json, {\n      path: path || this.resourcePath || '',\n      crossOrigin: this.crossOrigin,\n      requestHeader: this.requestHeader,\n      manager: this.manager,\n      ktx2Loader: this.ktx2Loader,\n      meshoptDecoder: this.meshoptDecoder,\n    })\n\n    parser.fileLoader.setRequestHeader(this.requestHeader)\n\n    for (let i = 0; i < this.pluginCallbacks.length; i++) {\n      const plugin = this.pluginCallbacks[i](parser)\n\n      if (!plugin.name) console.error('THREE.GLTFLoader: Invalid plugin found: missing name')\n\n      plugins[plugin.name] = plugin\n\n      // Workaround to avoid determining as unknown extension\n      // in addUnknownExtensionsToUserData().\n      // Remove this workaround if we move all the existing\n      // extension handlers to plugin system\n      extensions[plugin.name] = true\n    }\n\n    if (json.extensionsUsed) {\n      for (let i = 0; i < json.extensionsUsed.length; ++i) {\n        const extensionName = json.extensionsUsed[i]\n        const extensionsRequired = json.extensionsRequired || []\n\n        switch (extensionName) {\n          case EXTENSIONS.KHR_MATERIALS_UNLIT:\n            extensions[extensionName] = new GLTFMaterialsUnlitExtension()\n            break\n\n          case EXTENSIONS.KHR_DRACO_MESH_COMPRESSION:\n            extensions[extensionName] = new GLTFDracoMeshCompressionExtension(json, this.dracoLoader)\n            break\n\n          case EXTENSIONS.KHR_TEXTURE_TRANSFORM:\n            extensions[extensionName] = new GLTFTextureTransformExtension()\n            break\n\n          case EXTENSIONS.KHR_MESH_QUANTIZATION:\n            extensions[extensionName] = new GLTFMeshQuantizationExtension()\n            break\n\n          default:\n            if (extensionsRequired.indexOf(extensionName) >= 0 && plugins[extensionName] === undefined) {\n              console.warn('THREE.GLTFLoader: Unknown extension \"' + extensionName + '\".')\n            }\n        }\n      }\n    }\n\n    parser.setExtensions(extensions)\n    parser.setPlugins(plugins)\n    parser.parse(onLoad, onError)\n  }\n\n  parseAsync(data, path) {\n    const scope = this\n\n    return new Promise(function (resolve, reject) {\n      scope.parse(data, path, resolve, reject)\n    })\n  }\n}\n\n/* GLTFREGISTRY */\n\nfunction GLTFRegistry() {\n  let objects = {}\n\n  return {\n    get: function (key) {\n      return objects[key]\n    },\n\n    add: function (key, object) {\n      objects[key] = object\n    },\n\n    remove: function (key) {\n      delete objects[key]\n    },\n\n    removeAll: function () {\n      objects = {}\n    },\n  }\n}\n\n/*********************************/\n/********** EXTENSIONS ***********/\n/*********************************/\n\nconst EXTENSIONS = {\n  KHR_BINARY_GLTF: 'KHR_binary_glTF',\n  KHR_DRACO_MESH_COMPRESSION: 'KHR_draco_mesh_compression',\n  KHR_LIGHTS_PUNCTUAL: 'KHR_lights_punctual',\n  KHR_MATERIALS_CLEARCOAT: 'KHR_materials_clearcoat',\n  KHR_MATERIALS_DISPERSION: 'KHR_materials_dispersion',\n  KHR_MATERIALS_IOR: 'KHR_materials_ior',\n  KHR_MATERIALS_SHEEN: 'KHR_materials_sheen',\n  KHR_MATERIALS_SPECULAR: 'KHR_materials_specular',\n  KHR_MATERIALS_TRANSMISSION: 'KHR_materials_transmission',\n  KHR_MATERIALS_IRIDESCENCE: 'KHR_materials_iridescence',\n  KHR_MATERIALS_ANISOTROPY: 'KHR_materials_anisotropy',\n  KHR_MATERIALS_UNLIT: 'KHR_materials_unlit',\n  KHR_MATERIALS_VOLUME: 'KHR_materials_volume',\n  KHR_TEXTURE_BASISU: 'KHR_texture_basisu',\n  KHR_TEXTURE_TRANSFORM: 'KHR_texture_transform',\n  KHR_MESH_QUANTIZATION: 'KHR_mesh_quantization',\n  KHR_MATERIALS_EMISSIVE_STRENGTH: 'KHR_materials_emissive_strength',\n  EXT_MATERIALS_BUMP: 'EXT_materials_bump',\n  EXT_TEXTURE_WEBP: 'EXT_texture_webp',\n  EXT_TEXTURE_AVIF: 'EXT_texture_avif',\n  EXT_MESHOPT_COMPRESSION: 'EXT_meshopt_compression',\n  EXT_MESH_GPU_INSTANCING: 'EXT_mesh_gpu_instancing',\n}\n\n/**\n * Punctual Lights Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_lights_punctual\n */\nclass GLTFLightsExtension {\n  constructor(parser) {\n    this.parser = parser\n    this.name = EXTENSIONS.KHR_LIGHTS_PUNCTUAL\n\n    // Object3D instance caches\n    this.cache = { refs: {}, uses: {} }\n  }\n\n  _markDefs() {\n    const parser = this.parser\n    const nodeDefs = this.parser.json.nodes || []\n\n    for (let nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex++) {\n      const nodeDef = nodeDefs[nodeIndex]\n\n      if (nodeDef.extensions && nodeDef.extensions[this.name] && nodeDef.extensions[this.name].light !== undefined) {\n        parser._addNodeRef(this.cache, nodeDef.extensions[this.name].light)\n      }\n    }\n  }\n\n  _loadLight(lightIndex) {\n    const parser = this.parser\n    const cacheKey = 'light:' + lightIndex\n    let dependency = parser.cache.get(cacheKey)\n\n    if (dependency) return dependency\n\n    const json = parser.json\n    const extensions = (json.extensions && json.extensions[this.name]) || {}\n    const lightDefs = extensions.lights || []\n    const lightDef = lightDefs[lightIndex]\n    let lightNode\n\n    const color = new Color(0xffffff)\n\n    if (lightDef.color !== undefined)\n      color.setRGB(lightDef.color[0], lightDef.color[1], lightDef.color[2], LinearSRGBColorSpace)\n\n    const range = lightDef.range !== undefined ? lightDef.range : 0\n\n    switch (lightDef.type) {\n      case 'directional':\n        lightNode = new DirectionalLight(color)\n        lightNode.target.position.set(0, 0, -1)\n        lightNode.add(lightNode.target)\n        break\n\n      case 'point':\n        lightNode = new PointLight(color)\n        lightNode.distance = range\n        break\n\n      case 'spot':\n        lightNode = new SpotLight(color)\n        lightNode.distance = range\n        // Handle spotlight properties.\n        lightDef.spot = lightDef.spot || {}\n        lightDef.spot.innerConeAngle = lightDef.spot.innerConeAngle !== undefined ? lightDef.spot.innerConeAngle : 0\n        lightDef.spot.outerConeAngle =\n          lightDef.spot.outerConeAngle !== undefined ? lightDef.spot.outerConeAngle : Math.PI / 4.0\n        lightNode.angle = lightDef.spot.outerConeAngle\n        lightNode.penumbra = 1.0 - lightDef.spot.innerConeAngle / lightDef.spot.outerConeAngle\n        lightNode.target.position.set(0, 0, -1)\n        lightNode.add(lightNode.target)\n        break\n\n      default:\n        throw new Error('THREE.GLTFLoader: Unexpected light type: ' + lightDef.type)\n    }\n\n    // Some lights (e.g. spot) default to a position other than the origin. Reset the position\n    // here, because node-level parsing will only override position if explicitly specified.\n    lightNode.position.set(0, 0, 0)\n\n    lightNode.decay = 2\n\n    assignExtrasToUserData(lightNode, lightDef)\n\n    if (lightDef.intensity !== undefined) lightNode.intensity = lightDef.intensity\n\n    lightNode.name = parser.createUniqueName(lightDef.name || 'light_' + lightIndex)\n\n    dependency = Promise.resolve(lightNode)\n\n    parser.cache.add(cacheKey, dependency)\n\n    return dependency\n  }\n\n  getDependency(type, index) {\n    if (type !== 'light') return\n\n    return this._loadLight(index)\n  }\n\n  createNodeAttachment(nodeIndex) {\n    const self = this\n    const parser = this.parser\n    const json = parser.json\n    const nodeDef = json.nodes[nodeIndex]\n    const lightDef = (nodeDef.extensions && nodeDef.extensions[this.name]) || {}\n    const lightIndex = lightDef.light\n\n    if (lightIndex === undefined) return null\n\n    return this._loadLight(lightIndex).then(function (light) {\n      return parser._getNodeRef(self.cache, lightIndex, light)\n    })\n  }\n}\n\n/**\n * Unlit Materials Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_unlit\n */\nclass GLTFMaterialsUnlitExtension {\n  constructor() {\n    this.name = EXTENSIONS.KHR_MATERIALS_UNLIT\n  }\n\n  getMaterialType() {\n    return MeshBasicMaterial\n  }\n\n  extendParams(materialParams, materialDef, parser) {\n    const pending = []\n\n    materialParams.color = new Color(1.0, 1.0, 1.0)\n    materialParams.opacity = 1.0\n\n    const metallicRoughness = materialDef.pbrMetallicRoughness\n\n    if (metallicRoughness) {\n      if (Array.isArray(metallicRoughness.baseColorFactor)) {\n        const array = metallicRoughness.baseColorFactor\n\n        materialParams.color.setRGB(array[0], array[1], array[2], LinearSRGBColorSpace)\n        materialParams.opacity = array[3]\n      }\n\n      if (metallicRoughness.baseColorTexture !== undefined) {\n        pending.push(parser.assignTexture(materialParams, 'map', metallicRoughness.baseColorTexture, SRGBColorSpace))\n      }\n    }\n\n    return Promise.all(pending)\n  }\n}\n\n/**\n * Materials Emissive Strength Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/blob/5768b3ce0ef32bc39cdf1bef10b948586635ead3/extensions/2.0/Khronos/KHR_materials_emissive_strength/README.md\n */\nclass GLTFMaterialsEmissiveStrengthExtension {\n  constructor(parser) {\n    this.parser = parser\n    this.name = EXTENSIONS.KHR_MATERIALS_EMISSIVE_STRENGTH\n  }\n\n  extendMaterialParams(materialIndex, materialParams) {\n    const parser = this.parser\n    const materialDef = parser.json.materials[materialIndex]\n\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n      return Promise.resolve()\n    }\n\n    const emissiveStrength = materialDef.extensions[this.name].emissiveStrength\n\n    if (emissiveStrength !== undefined) {\n      materialParams.emissiveIntensity = emissiveStrength\n    }\n\n    return Promise.resolve()\n  }\n}\n\n/**\n * Clearcoat Materials Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_clearcoat\n */\nclass GLTFMaterialsClearcoatExtension {\n  constructor(parser) {\n    this.parser = parser\n    this.name = EXTENSIONS.KHR_MATERIALS_CLEARCOAT\n  }\n\n  getMaterialType(materialIndex) {\n    const parser = this.parser\n    const materialDef = parser.json.materials[materialIndex]\n\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) return null\n\n    return MeshPhysicalMaterial\n  }\n\n  extendMaterialParams(materialIndex, materialParams) {\n    const parser = this.parser\n    const materialDef = parser.json.materials[materialIndex]\n\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n      return Promise.resolve()\n    }\n\n    const pending = []\n\n    const extension = materialDef.extensions[this.name]\n\n    if (extension.clearcoatFactor !== undefined) {\n      materialParams.clearcoat = extension.clearcoatFactor\n    }\n\n    if (extension.clearcoatTexture !== undefined) {\n      pending.push(parser.assignTexture(materialParams, 'clearcoatMap', extension.clearcoatTexture))\n    }\n\n    if (extension.clearcoatRoughnessFactor !== undefined) {\n      materialParams.clearcoatRoughness = extension.clearcoatRoughnessFactor\n    }\n\n    if (extension.clearcoatRoughnessTexture !== undefined) {\n      pending.push(parser.assignTexture(materialParams, 'clearcoatRoughnessMap', extension.clearcoatRoughnessTexture))\n    }\n\n    if (extension.clearcoatNormalTexture !== undefined) {\n      pending.push(parser.assignTexture(materialParams, 'clearcoatNormalMap', extension.clearcoatNormalTexture))\n\n      if (extension.clearcoatNormalTexture.scale !== undefined) {\n        const scale = extension.clearcoatNormalTexture.scale\n\n        materialParams.clearcoatNormalScale = new Vector2(scale, scale)\n      }\n    }\n\n    return Promise.all(pending)\n  }\n}\n\n/**\n * Materials dispersion Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_dispersion\n */\nclass GLTFMaterialsDispersionExtension {\n  constructor(parser) {\n    this.parser = parser\n    this.name = EXTENSIONS.KHR_MATERIALS_DISPERSION\n  }\n\n  getMaterialType(materialIndex) {\n    const parser = this.parser\n    const materialDef = parser.json.materials[materialIndex]\n\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) return null\n\n    return MeshPhysicalMaterial\n  }\n\n  extendMaterialParams(materialIndex, materialParams) {\n    const parser = this.parser\n    const materialDef = parser.json.materials[materialIndex]\n\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n      return Promise.resolve()\n    }\n\n    const extension = materialDef.extensions[this.name]\n\n    materialParams.dispersion = extension.dispersion !== undefined ? extension.dispersion : 0\n\n    return Promise.resolve()\n  }\n}\n\n/**\n * Iridescence Materials Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_iridescence\n */\nclass GLTFMaterialsIridescenceExtension {\n  constructor(parser) {\n    this.parser = parser\n    this.name = EXTENSIONS.KHR_MATERIALS_IRIDESCENCE\n  }\n\n  getMaterialType(materialIndex) {\n    const parser = this.parser\n    const materialDef = parser.json.materials[materialIndex]\n\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) return null\n\n    return MeshPhysicalMaterial\n  }\n\n  extendMaterialParams(materialIndex, materialParams) {\n    const parser = this.parser\n    const materialDef = parser.json.materials[materialIndex]\n\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n      return Promise.resolve()\n    }\n\n    const pending = []\n\n    const extension = materialDef.extensions[this.name]\n\n    if (extension.iridescenceFactor !== undefined) {\n      materialParams.iridescence = extension.iridescenceFactor\n    }\n\n    if (extension.iridescenceTexture !== undefined) {\n      pending.push(parser.assignTexture(materialParams, 'iridescenceMap', extension.iridescenceTexture))\n    }\n\n    if (extension.iridescenceIor !== undefined) {\n      materialParams.iridescenceIOR = extension.iridescenceIor\n    }\n\n    if (materialParams.iridescenceThicknessRange === undefined) {\n      materialParams.iridescenceThicknessRange = [100, 400]\n    }\n\n    if (extension.iridescenceThicknessMinimum !== undefined) {\n      materialParams.iridescenceThicknessRange[0] = extension.iridescenceThicknessMinimum\n    }\n\n    if (extension.iridescenceThicknessMaximum !== undefined) {\n      materialParams.iridescenceThicknessRange[1] = extension.iridescenceThicknessMaximum\n    }\n\n    if (extension.iridescenceThicknessTexture !== undefined) {\n      pending.push(\n        parser.assignTexture(materialParams, 'iridescenceThicknessMap', extension.iridescenceThicknessTexture),\n      )\n    }\n\n    return Promise.all(pending)\n  }\n}\n\n/**\n * Sheen Materials Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_sheen\n */\nclass GLTFMaterialsSheenExtension {\n  constructor(parser) {\n    this.parser = parser\n    this.name = EXTENSIONS.KHR_MATERIALS_SHEEN\n  }\n\n  getMaterialType(materialIndex) {\n    const parser = this.parser\n    const materialDef = parser.json.materials[materialIndex]\n\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) return null\n\n    return MeshPhysicalMaterial\n  }\n\n  extendMaterialParams(materialIndex, materialParams) {\n    const parser = this.parser\n    const materialDef = parser.json.materials[materialIndex]\n\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n      return Promise.resolve()\n    }\n\n    const pending = []\n\n    materialParams.sheenColor = new Color(0, 0, 0)\n    materialParams.sheenRoughness = 0\n    materialParams.sheen = 1\n\n    const extension = materialDef.extensions[this.name]\n\n    if (extension.sheenColorFactor !== undefined) {\n      const colorFactor = extension.sheenColorFactor\n      materialParams.sheenColor.setRGB(colorFactor[0], colorFactor[1], colorFactor[2], LinearSRGBColorSpace)\n    }\n\n    if (extension.sheenRoughnessFactor !== undefined) {\n      materialParams.sheenRoughness = extension.sheenRoughnessFactor\n    }\n\n    if (extension.sheenColorTexture !== undefined) {\n      pending.push(parser.assignTexture(materialParams, 'sheenColorMap', extension.sheenColorTexture, SRGBColorSpace))\n    }\n\n    if (extension.sheenRoughnessTexture !== undefined) {\n      pending.push(parser.assignTexture(materialParams, 'sheenRoughnessMap', extension.sheenRoughnessTexture))\n    }\n\n    return Promise.all(pending)\n  }\n}\n\n/**\n * Transmission Materials Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_transmission\n * Draft: https://github.com/KhronosGroup/glTF/pull/1698\n */\nclass GLTFMaterialsTransmissionExtension {\n  constructor(parser) {\n    this.parser = parser\n    this.name = EXTENSIONS.KHR_MATERIALS_TRANSMISSION\n  }\n\n  getMaterialType(materialIndex) {\n    const parser = this.parser\n    const materialDef = parser.json.materials[materialIndex]\n\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) return null\n\n    return MeshPhysicalMaterial\n  }\n\n  extendMaterialParams(materialIndex, materialParams) {\n    const parser = this.parser\n    const materialDef = parser.json.materials[materialIndex]\n\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n      return Promise.resolve()\n    }\n\n    const pending = []\n\n    const extension = materialDef.extensions[this.name]\n\n    if (extension.transmissionFactor !== undefined) {\n      materialParams.transmission = extension.transmissionFactor\n    }\n\n    if (extension.transmissionTexture !== undefined) {\n      pending.push(parser.assignTexture(materialParams, 'transmissionMap', extension.transmissionTexture))\n    }\n\n    return Promise.all(pending)\n  }\n}\n\n/**\n * Materials Volume Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_volume\n */\nclass GLTFMaterialsVolumeExtension {\n  constructor(parser) {\n    this.parser = parser\n    this.name = EXTENSIONS.KHR_MATERIALS_VOLUME\n  }\n\n  getMaterialType(materialIndex) {\n    const parser = this.parser\n    const materialDef = parser.json.materials[materialIndex]\n\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) return null\n\n    return MeshPhysicalMaterial\n  }\n\n  extendMaterialParams(materialIndex, materialParams) {\n    const parser = this.parser\n    const materialDef = parser.json.materials[materialIndex]\n\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n      return Promise.resolve()\n    }\n\n    const pending = []\n\n    const extension = materialDef.extensions[this.name]\n\n    materialParams.thickness = extension.thicknessFactor !== undefined ? extension.thicknessFactor : 0\n\n    if (extension.thicknessTexture !== undefined) {\n      pending.push(parser.assignTexture(materialParams, 'thicknessMap', extension.thicknessTexture))\n    }\n\n    materialParams.attenuationDistance = extension.attenuationDistance || Infinity\n\n    const colorArray = extension.attenuationColor || [1, 1, 1]\n    materialParams.attenuationColor = new Color().setRGB(\n      colorArray[0],\n      colorArray[1],\n      colorArray[2],\n      LinearSRGBColorSpace,\n    )\n\n    return Promise.all(pending)\n  }\n}\n\n/**\n * Materials ior Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_ior\n */\nclass GLTFMaterialsIorExtension {\n  constructor(parser) {\n    this.parser = parser\n    this.name = EXTENSIONS.KHR_MATERIALS_IOR\n  }\n\n  getMaterialType(materialIndex) {\n    const parser = this.parser\n    const materialDef = parser.json.materials[materialIndex]\n\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) return null\n\n    return MeshPhysicalMaterial\n  }\n\n  extendMaterialParams(materialIndex, materialParams) {\n    const parser = this.parser\n    const materialDef = parser.json.materials[materialIndex]\n\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n      return Promise.resolve()\n    }\n\n    const extension = materialDef.extensions[this.name]\n\n    materialParams.ior = extension.ior !== undefined ? extension.ior : 1.5\n\n    return Promise.resolve()\n  }\n}\n\n/**\n * Materials specular Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_specular\n */\nclass GLTFMaterialsSpecularExtension {\n  constructor(parser) {\n    this.parser = parser\n    this.name = EXTENSIONS.KHR_MATERIALS_SPECULAR\n  }\n\n  getMaterialType(materialIndex) {\n    const parser = this.parser\n    const materialDef = parser.json.materials[materialIndex]\n\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) return null\n\n    return MeshPhysicalMaterial\n  }\n\n  extendMaterialParams(materialIndex, materialParams) {\n    const parser = this.parser\n    const materialDef = parser.json.materials[materialIndex]\n\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n      return Promise.resolve()\n    }\n\n    const pending = []\n\n    const extension = materialDef.extensions[this.name]\n\n    materialParams.specularIntensity = extension.specularFactor !== undefined ? extension.specularFactor : 1.0\n\n    if (extension.specularTexture !== undefined) {\n      pending.push(parser.assignTexture(materialParams, 'specularIntensityMap', extension.specularTexture))\n    }\n\n    const colorArray = extension.specularColorFactor || [1, 1, 1]\n    materialParams.specularColor = new Color().setRGB(colorArray[0], colorArray[1], colorArray[2], LinearSRGBColorSpace)\n\n    if (extension.specularColorTexture !== undefined) {\n      pending.push(\n        parser.assignTexture(materialParams, 'specularColorMap', extension.specularColorTexture, SRGBColorSpace),\n      )\n    }\n\n    return Promise.all(pending)\n  }\n}\n\n/**\n * Materials bump Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/EXT_materials_bump\n */\nclass GLTFMaterialsBumpExtension {\n  constructor(parser) {\n    this.parser = parser\n    this.name = EXTENSIONS.EXT_MATERIALS_BUMP\n  }\n\n  getMaterialType(materialIndex) {\n    const parser = this.parser\n    const materialDef = parser.json.materials[materialIndex]\n\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) return null\n\n    return MeshPhysicalMaterial\n  }\n\n  extendMaterialParams(materialIndex, materialParams) {\n    const parser = this.parser\n    const materialDef = parser.json.materials[materialIndex]\n\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n      return Promise.resolve()\n    }\n\n    const pending = []\n\n    const extension = materialDef.extensions[this.name]\n\n    materialParams.bumpScale = extension.bumpFactor !== undefined ? extension.bumpFactor : 1.0\n\n    if (extension.bumpTexture !== undefined) {\n      pending.push(parser.assignTexture(materialParams, 'bumpMap', extension.bumpTexture))\n    }\n\n    return Promise.all(pending)\n  }\n}\n\n/**\n * Materials anisotropy Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_anisotropy\n */\nclass GLTFMaterialsAnisotropyExtension {\n  constructor(parser) {\n    this.parser = parser\n    this.name = EXTENSIONS.KHR_MATERIALS_ANISOTROPY\n  }\n\n  getMaterialType(materialIndex) {\n    const parser = this.parser\n    const materialDef = parser.json.materials[materialIndex]\n\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) return null\n\n    return MeshPhysicalMaterial\n  }\n\n  extendMaterialParams(materialIndex, materialParams) {\n    const parser = this.parser\n    const materialDef = parser.json.materials[materialIndex]\n\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n      return Promise.resolve()\n    }\n\n    const pending = []\n\n    const extension = materialDef.extensions[this.name]\n\n    if (extension.anisotropyStrength !== undefined) {\n      materialParams.anisotropy = extension.anisotropyStrength\n    }\n\n    if (extension.anisotropyRotation !== undefined) {\n      materialParams.anisotropyRotation = extension.anisotropyRotation\n    }\n\n    if (extension.anisotropyTexture !== undefined) {\n      pending.push(parser.assignTexture(materialParams, 'anisotropyMap', extension.anisotropyTexture))\n    }\n\n    return Promise.all(pending)\n  }\n}\n\n/**\n * BasisU Texture Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_texture_basisu\n */\nclass GLTFTextureBasisUExtension {\n  constructor(parser) {\n    this.parser = parser\n    this.name = EXTENSIONS.KHR_TEXTURE_BASISU\n  }\n\n  loadTexture(textureIndex) {\n    const parser = this.parser\n    const json = parser.json\n\n    const textureDef = json.textures[textureIndex]\n\n    if (!textureDef.extensions || !textureDef.extensions[this.name]) {\n      return null\n    }\n\n    const extension = textureDef.extensions[this.name]\n    const loader = parser.options.ktx2Loader\n\n    if (!loader) {\n      if (json.extensionsRequired && json.extensionsRequired.indexOf(this.name) >= 0) {\n        throw new Error('THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures')\n      } else {\n        // Assumes that the extension is optional and that a fallback texture is present\n        return null\n      }\n    }\n\n    return parser.loadTextureImage(textureIndex, extension.source, loader)\n  }\n}\n\n/**\n * WebP Texture Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/EXT_texture_webp\n */\nclass GLTFTextureWebPExtension {\n  constructor(parser) {\n    this.parser = parser\n    this.name = EXTENSIONS.EXT_TEXTURE_WEBP\n    this.isSupported = null\n  }\n\n  loadTexture(textureIndex) {\n    const name = this.name\n    const parser = this.parser\n    const json = parser.json\n\n    const textureDef = json.textures[textureIndex]\n\n    if (!textureDef.extensions || !textureDef.extensions[name]) {\n      return null\n    }\n\n    const extension = textureDef.extensions[name]\n    const source = json.images[extension.source]\n\n    let loader = parser.textureLoader\n    if (source.uri) {\n      const handler = parser.options.manager.getHandler(source.uri)\n      if (handler !== null) loader = handler\n    }\n\n    return this.detectSupport().then(function (isSupported) {\n      if (isSupported) return parser.loadTextureImage(textureIndex, extension.source, loader)\n\n      if (json.extensionsRequired && json.extensionsRequired.indexOf(name) >= 0) {\n        throw new Error('THREE.GLTFLoader: WebP required by asset but unsupported.')\n      }\n\n      // Fall back to PNG or JPEG.\n      return parser.loadTexture(textureIndex)\n    })\n  }\n\n  detectSupport() {\n    if (!this.isSupported) {\n      this.isSupported = new Promise(function (resolve) {\n        const image = new Image()\n\n        // Lossy test image. Support for lossy images doesn't guarantee support for all\n        // WebP images, unfortunately.\n        image.src = 'data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA'\n\n        image.onload = image.onerror = function () {\n          resolve(image.height === 1)\n        }\n      })\n    }\n\n    return this.isSupported\n  }\n}\n\n/**\n * AVIF Texture Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/EXT_texture_avif\n */\nclass GLTFTextureAVIFExtension {\n  constructor(parser) {\n    this.parser = parser\n    this.name = EXTENSIONS.EXT_TEXTURE_AVIF\n    this.isSupported = null\n  }\n\n  loadTexture(textureIndex) {\n    const name = this.name\n    const parser = this.parser\n    const json = parser.json\n\n    const textureDef = json.textures[textureIndex]\n\n    if (!textureDef.extensions || !textureDef.extensions[name]) {\n      return null\n    }\n\n    const extension = textureDef.extensions[name]\n    const source = json.images[extension.source]\n\n    let loader = parser.textureLoader\n    if (source.uri) {\n      const handler = parser.options.manager.getHandler(source.uri)\n      if (handler !== null) loader = handler\n    }\n\n    return this.detectSupport().then(function (isSupported) {\n      if (isSupported) return parser.loadTextureImage(textureIndex, extension.source, loader)\n\n      if (json.extensionsRequired && json.extensionsRequired.indexOf(name) >= 0) {\n        throw new Error('THREE.GLTFLoader: AVIF required by asset but unsupported.')\n      }\n\n      // Fall back to PNG or JPEG.\n      return parser.loadTexture(textureIndex)\n    })\n  }\n\n  detectSupport() {\n    if (!this.isSupported) {\n      this.isSupported = new Promise(function (resolve) {\n        const image = new Image()\n\n        // Lossy test image.\n        image.src =\n          'data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAABcAAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAEAAAABAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQAMAAAAABNjb2xybmNseAACAAIABoAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAAB9tZGF0EgAKCBgABogQEDQgMgkQAAAAB8dSLfI='\n        image.onload = image.onerror = function () {\n          resolve(image.height === 1)\n        }\n      })\n    }\n\n    return this.isSupported\n  }\n}\n\n/**\n * meshopt BufferView Compression Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/EXT_meshopt_compression\n */\nclass GLTFMeshoptCompression {\n  constructor(parser) {\n    this.name = EXTENSIONS.EXT_MESHOPT_COMPRESSION\n    this.parser = parser\n  }\n\n  loadBufferView(index) {\n    const json = this.parser.json\n    const bufferView = json.bufferViews[index]\n\n    if (bufferView.extensions && bufferView.extensions[this.name]) {\n      const extensionDef = bufferView.extensions[this.name]\n\n      const buffer = this.parser.getDependency('buffer', extensionDef.buffer)\n      const decoder = this.parser.options.meshoptDecoder\n\n      if (!decoder || !decoder.supported) {\n        if (json.extensionsRequired && json.extensionsRequired.indexOf(this.name) >= 0) {\n          throw new Error('THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files')\n        } else {\n          // Assumes that the extension is optional and that fallback buffer data is present\n          return null\n        }\n      }\n\n      return buffer.then(function (res) {\n        const byteOffset = extensionDef.byteOffset || 0\n        const byteLength = extensionDef.byteLength || 0\n\n        const count = extensionDef.count\n        const stride = extensionDef.byteStride\n\n        const source = new Uint8Array(res, byteOffset, byteLength)\n\n        if (decoder.decodeGltfBufferAsync) {\n          return decoder\n            .decodeGltfBufferAsync(count, stride, source, extensionDef.mode, extensionDef.filter)\n            .then(function (res) {\n              return res.buffer\n            })\n        } else {\n          // Support for MeshoptDecoder 0.18 or earlier, without decodeGltfBufferAsync\n          return decoder.ready.then(function () {\n            const result = new ArrayBuffer(count * stride)\n            decoder.decodeGltfBuffer(\n              new Uint8Array(result),\n              count,\n              stride,\n              source,\n              extensionDef.mode,\n              extensionDef.filter,\n            )\n            return result\n          })\n        }\n      })\n    } else {\n      return null\n    }\n  }\n}\n\n/**\n * GPU Instancing Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/EXT_mesh_gpu_instancing\n *\n */\nclass GLTFMeshGpuInstancing {\n  constructor(parser) {\n    this.name = EXTENSIONS.EXT_MESH_GPU_INSTANCING\n    this.parser = parser\n  }\n\n  createNodeMesh(nodeIndex) {\n    const json = this.parser.json\n    const nodeDef = json.nodes[nodeIndex]\n\n    if (!nodeDef.extensions || !nodeDef.extensions[this.name] || nodeDef.mesh === undefined) {\n      return null\n    }\n\n    const meshDef = json.meshes[nodeDef.mesh]\n\n    // No Points or Lines + Instancing support yet\n\n    for (const primitive of meshDef.primitives) {\n      if (\n        primitive.mode !== WEBGL_CONSTANTS.TRIANGLES &&\n        primitive.mode !== WEBGL_CONSTANTS.TRIANGLE_STRIP &&\n        primitive.mode !== WEBGL_CONSTANTS.TRIANGLE_FAN &&\n        primitive.mode !== undefined\n      ) {\n        return null\n      }\n    }\n\n    const extensionDef = nodeDef.extensions[this.name]\n    const attributesDef = extensionDef.attributes\n\n    // @TODO: Can we support InstancedMesh + SkinnedMesh?\n\n    const pending = []\n    const attributes = {}\n\n    for (const key in attributesDef) {\n      pending.push(\n        this.parser.getDependency('accessor', attributesDef[key]).then((accessor) => {\n          attributes[key] = accessor\n          return attributes[key]\n        }),\n      )\n    }\n\n    if (pending.length < 1) {\n      return null\n    }\n\n    pending.push(this.parser.createNodeMesh(nodeIndex))\n\n    return Promise.all(pending).then((results) => {\n      const nodeObject = results.pop()\n      const meshes = nodeObject.isGroup ? nodeObject.children : [nodeObject]\n      const count = results[0].count // All attribute counts should be same\n      const instancedMeshes = []\n\n      for (const mesh of meshes) {\n        // Temporal variables\n        const m = new Matrix4()\n        const p = new Vector3()\n        const q = new Quaternion()\n        const s = new Vector3(1, 1, 1)\n\n        const instancedMesh = new InstancedMesh(mesh.geometry, mesh.material, count)\n\n        for (let i = 0; i < count; i++) {\n          if (attributes.TRANSLATION) {\n            p.fromBufferAttribute(attributes.TRANSLATION, i)\n          }\n\n          if (attributes.ROTATION) {\n            q.fromBufferAttribute(attributes.ROTATION, i)\n          }\n\n          if (attributes.SCALE) {\n            s.fromBufferAttribute(attributes.SCALE, i)\n          }\n\n          instancedMesh.setMatrixAt(i, m.compose(p, q, s))\n        }\n\n        // Add instance attributes to the geometry, excluding TRS.\n        for (const attributeName in attributes) {\n          if (attributeName === '_COLOR_0') {\n            const attr = attributes[attributeName]\n            instancedMesh.instanceColor = new InstancedBufferAttribute(attr.array, attr.itemSize, attr.normalized)\n          } else if (attributeName !== 'TRANSLATION' && attributeName !== 'ROTATION' && attributeName !== 'SCALE') {\n            mesh.geometry.setAttribute(attributeName, attributes[attributeName])\n          }\n        }\n\n        // Just in case\n        Object3D.prototype.copy.call(instancedMesh, mesh)\n\n        this.parser.assignFinalMaterial(instancedMesh)\n\n        instancedMeshes.push(instancedMesh)\n      }\n\n      if (nodeObject.isGroup) {\n        nodeObject.clear()\n\n        nodeObject.add(...instancedMeshes)\n\n        return nodeObject\n      }\n\n      return instancedMeshes[0]\n    })\n  }\n}\n\n/* BINARY EXTENSION */\nconst BINARY_EXTENSION_HEADER_MAGIC = 'glTF'\nconst BINARY_EXTENSION_HEADER_LENGTH = 12\nconst BINARY_EXTENSION_CHUNK_TYPES = { JSON: 0x4e4f534a, BIN: 0x004e4942 }\n\nclass GLTFBinaryExtension {\n  constructor(data) {\n    this.name = EXTENSIONS.KHR_BINARY_GLTF\n    this.content = null\n    this.body = null\n\n    const headerView = new DataView(data, 0, BINARY_EXTENSION_HEADER_LENGTH)\n\n    this.header = {\n      magic: decodeText(new Uint8Array(data.slice(0, 4))),\n      version: headerView.getUint32(4, true),\n      length: headerView.getUint32(8, true),\n    }\n\n    if (this.header.magic !== BINARY_EXTENSION_HEADER_MAGIC) {\n      throw new Error('THREE.GLTFLoader: Unsupported glTF-Binary header.')\n    } else if (this.header.version < 2.0) {\n      throw new Error('THREE.GLTFLoader: Legacy binary file detected.')\n    }\n\n    const chunkContentsLength = this.header.length - BINARY_EXTENSION_HEADER_LENGTH\n    const chunkView = new DataView(data, BINARY_EXTENSION_HEADER_LENGTH)\n    let chunkIndex = 0\n\n    while (chunkIndex < chunkContentsLength) {\n      const chunkLength = chunkView.getUint32(chunkIndex, true)\n      chunkIndex += 4\n\n      const chunkType = chunkView.getUint32(chunkIndex, true)\n      chunkIndex += 4\n\n      if (chunkType === BINARY_EXTENSION_CHUNK_TYPES.JSON) {\n        const contentArray = new Uint8Array(data, BINARY_EXTENSION_HEADER_LENGTH + chunkIndex, chunkLength)\n        this.content = decodeText(contentArray)\n      } else if (chunkType === BINARY_EXTENSION_CHUNK_TYPES.BIN) {\n        const byteOffset = BINARY_EXTENSION_HEADER_LENGTH + chunkIndex\n        this.body = data.slice(byteOffset, byteOffset + chunkLength)\n      }\n\n      // Clients must ignore chunks with unknown types.\n\n      chunkIndex += chunkLength\n    }\n\n    if (this.content === null) {\n      throw new Error('THREE.GLTFLoader: JSON content not found.')\n    }\n  }\n}\n\n/**\n * DRACO Mesh Compression Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_draco_mesh_compression\n */\nclass GLTFDracoMeshCompressionExtension {\n  constructor(json, dracoLoader) {\n    if (!dracoLoader) {\n      throw new Error('THREE.GLTFLoader: No DRACOLoader instance provided.')\n    }\n\n    this.name = EXTENSIONS.KHR_DRACO_MESH_COMPRESSION\n    this.json = json\n    this.dracoLoader = dracoLoader\n    this.dracoLoader.preload()\n  }\n\n  decodePrimitive(primitive, parser) {\n    const json = this.json\n    const dracoLoader = this.dracoLoader\n    const bufferViewIndex = primitive.extensions[this.name].bufferView\n    const gltfAttributeMap = primitive.extensions[this.name].attributes\n    const threeAttributeMap = {}\n    const attributeNormalizedMap = {}\n    const attributeTypeMap = {}\n\n    for (const attributeName in gltfAttributeMap) {\n      const threeAttributeName = ATTRIBUTES[attributeName] || attributeName.toLowerCase()\n\n      threeAttributeMap[threeAttributeName] = gltfAttributeMap[attributeName]\n    }\n\n    for (const attributeName in primitive.attributes) {\n      const threeAttributeName = ATTRIBUTES[attributeName] || attributeName.toLowerCase()\n\n      if (gltfAttributeMap[attributeName] !== undefined) {\n        const accessorDef = json.accessors[primitive.attributes[attributeName]]\n        const componentType = WEBGL_COMPONENT_TYPES[accessorDef.componentType]\n\n        attributeTypeMap[threeAttributeName] = componentType.name\n        attributeNormalizedMap[threeAttributeName] = accessorDef.normalized === true\n      }\n    }\n\n    return parser.getDependency('bufferView', bufferViewIndex).then(function (bufferView) {\n      return new Promise(function (resolve, reject) {\n        dracoLoader.decodeDracoFile(\n          bufferView,\n          function (geometry) {\n            for (const attributeName in geometry.attributes) {\n              const attribute = geometry.attributes[attributeName]\n              const normalized = attributeNormalizedMap[attributeName]\n\n              if (normalized !== undefined) attribute.normalized = normalized\n            }\n\n            resolve(geometry)\n          },\n          threeAttributeMap,\n          attributeTypeMap,\n          LinearSRGBColorSpace,\n          reject,\n        )\n      })\n    })\n  }\n}\n\n/**\n * Texture Transform Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_texture_transform\n */\nclass GLTFTextureTransformExtension {\n  constructor() {\n    this.name = EXTENSIONS.KHR_TEXTURE_TRANSFORM\n  }\n\n  extendTexture(texture, transform) {\n    if (\n      (transform.texCoord === undefined || transform.texCoord === texture.channel) &&\n      transform.offset === undefined &&\n      transform.rotation === undefined &&\n      transform.scale === undefined\n    ) {\n      // See https://github.com/mrdoob/three.js/issues/21819.\n      return texture\n    }\n\n    texture = texture.clone()\n\n    if (transform.texCoord !== undefined) {\n      texture.channel = transform.texCoord\n    }\n\n    if (transform.offset !== undefined) {\n      texture.offset.fromArray(transform.offset)\n    }\n\n    if (transform.rotation !== undefined) {\n      texture.rotation = transform.rotation\n    }\n\n    if (transform.scale !== undefined) {\n      texture.repeat.fromArray(transform.scale)\n    }\n\n    texture.needsUpdate = true\n\n    return texture\n  }\n}\n\n/**\n * Mesh Quantization Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_mesh_quantization\n */\nclass GLTFMeshQuantizationExtension {\n  constructor() {\n    this.name = EXTENSIONS.KHR_MESH_QUANTIZATION\n  }\n}\n\n/*********************************/\n/********** INTERPOLATION ********/\n/*********************************/\n\n// Spline Interpolation\n// Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#appendix-c-spline-interpolation\nclass GLTFCubicSplineInterpolant extends Interpolant {\n  constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {\n    super(parameterPositions, sampleValues, sampleSize, resultBuffer)\n  }\n\n  copySampleValue_(index) {\n    // Copies a sample value to the result buffer. See description of glTF\n    // CUBICSPLINE values layout in interpolate_() function below.\n\n    const result = this.resultBuffer,\n      values = this.sampleValues,\n      valueSize = this.valueSize,\n      offset = index * valueSize * 3 + valueSize\n\n    for (let i = 0; i !== valueSize; i++) {\n      result[i] = values[offset + i]\n    }\n\n    return result\n  }\n\n  interpolate_(i1, t0, t, t1) {\n    const result = this.resultBuffer\n    const values = this.sampleValues\n    const stride = this.valueSize\n\n    const stride2 = stride * 2\n    const stride3 = stride * 3\n\n    const td = t1 - t0\n\n    const p = (t - t0) / td\n    const pp = p * p\n    const ppp = pp * p\n\n    const offset1 = i1 * stride3\n    const offset0 = offset1 - stride3\n\n    const s2 = -2 * ppp + 3 * pp\n    const s3 = ppp - pp\n    const s0 = 1 - s2\n    const s1 = s3 - pp + p\n\n    // Layout of keyframe output values for CUBICSPLINE animations:\n    //   [ inTangent_1, splineVertex_1, outTangent_1, inTangent_2, splineVertex_2, ... ]\n    for (let i = 0; i !== stride; i++) {\n      const p0 = values[offset0 + i + stride] // splineVertex_k\n      const m0 = values[offset0 + i + stride2] * td // outTangent_k * (t_k+1 - t_k)\n      const p1 = values[offset1 + i + stride] // splineVertex_k+1\n      const m1 = values[offset1 + i] * td // inTangent_k+1 * (t_k+1 - t_k)\n\n      result[i] = s0 * p0 + s1 * m0 + s2 * p1 + s3 * m1\n    }\n\n    return result\n  }\n}\n\nconst _q = /* @__PURE__ */ new Quaternion()\n\nclass GLTFCubicSplineQuaternionInterpolant extends GLTFCubicSplineInterpolant {\n  interpolate_(i1, t0, t, t1) {\n    const result = super.interpolate_(i1, t0, t, t1)\n\n    _q.fromArray(result).normalize().toArray(result)\n\n    return result\n  }\n}\n\n/*********************************/\n/********** INTERNALS ************/\n/*********************************/\n\n/* CONSTANTS */\n\nconst WEBGL_CONSTANTS = {\n  FLOAT: 5126,\n  //FLOAT_MAT2: 35674,\n  FLOAT_MAT3: 35675,\n  FLOAT_MAT4: 35676,\n  FLOAT_VEC2: 35664,\n  FLOAT_VEC3: 35665,\n  FLOAT_VEC4: 35666,\n  LINEAR: 9729,\n  REPEAT: 10497,\n  SAMPLER_2D: 35678,\n  POINTS: 0,\n  LINES: 1,\n  LINE_LOOP: 2,\n  LINE_STRIP: 3,\n  TRIANGLES: 4,\n  TRIANGLE_STRIP: 5,\n  TRIANGLE_FAN: 6,\n  UNSIGNED_BYTE: 5121,\n  UNSIGNED_SHORT: 5123,\n}\n\nconst WEBGL_COMPONENT_TYPES = {\n  5120: Int8Array,\n  5121: Uint8Array,\n  5122: Int16Array,\n  5123: Uint16Array,\n  5125: Uint32Array,\n  5126: Float32Array,\n}\n\nconst WEBGL_FILTERS = {\n  9728: NearestFilter,\n  9729: LinearFilter,\n  9984: NearestMipmapNearestFilter,\n  9985: LinearMipmapNearestFilter,\n  9986: NearestMipmapLinearFilter,\n  9987: LinearMipmapLinearFilter,\n}\n\nconst WEBGL_WRAPPINGS = {\n  33071: ClampToEdgeWrapping,\n  33648: MirroredRepeatWrapping,\n  10497: RepeatWrapping,\n}\n\nconst WEBGL_TYPE_SIZES = {\n  SCALAR: 1,\n  VEC2: 2,\n  VEC3: 3,\n  VEC4: 4,\n  MAT2: 4,\n  MAT3: 9,\n  MAT4: 16,\n}\n\nconst ATTRIBUTES = {\n  POSITION: 'position',\n  NORMAL: 'normal',\n  TANGENT: 'tangent',\n  // uv => uv1, 4 uv channels\n  // https://github.com/mrdoob/three.js/pull/25943\n  // https://github.com/mrdoob/three.js/pull/25788\n  ...(version >= 152\n    ? {\n        TEXCOORD_0: 'uv',\n        TEXCOORD_1: 'uv1',\n        TEXCOORD_2: 'uv2',\n        TEXCOORD_3: 'uv3',\n      }\n    : {\n        TEXCOORD_0: 'uv',\n        TEXCOORD_1: 'uv2',\n      }),\n\n  COLOR_0: 'color',\n  WEIGHTS_0: 'skinWeight',\n  JOINTS_0: 'skinIndex',\n}\n\nconst PATH_PROPERTIES = {\n  scale: 'scale',\n  translation: 'position',\n  rotation: 'quaternion',\n  weights: 'morphTargetInfluences',\n}\n\nconst INTERPOLATION = {\n  CUBICSPLINE: undefined, // We use a custom interpolant (GLTFCubicSplineInterpolation) for CUBICSPLINE tracks. Each\n  // keyframe track will be initialized with a default interpolation type, then modified.\n  LINEAR: InterpolateLinear,\n  STEP: InterpolateDiscrete,\n}\n\nconst ALPHA_MODES = {\n  OPAQUE: 'OPAQUE',\n  MASK: 'MASK',\n  BLEND: 'BLEND',\n}\n\n/**\n * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#default-material\n */\nfunction createDefaultMaterial(cache) {\n  if (cache['DefaultMaterial'] === undefined) {\n    cache['DefaultMaterial'] = new MeshStandardMaterial({\n      color: 0xffffff,\n      emissive: 0x000000,\n      metalness: 1,\n      roughness: 1,\n      transparent: false,\n      depthTest: true,\n      side: FrontSide,\n    })\n  }\n\n  return cache['DefaultMaterial']\n}\n\nfunction addUnknownExtensionsToUserData(knownExtensions, object, objectDef) {\n  // Add unknown glTF extensions to an object's userData.\n\n  for (const name in objectDef.extensions) {\n    if (knownExtensions[name] === undefined) {\n      object.userData.gltfExtensions = object.userData.gltfExtensions || {}\n      object.userData.gltfExtensions[name] = objectDef.extensions[name]\n    }\n  }\n}\n\n/**\n * @param {Object3D|Material|BufferGeometry} object\n * @param {GLTF.definition} gltfDef\n */\nfunction assignExtrasToUserData(object, gltfDef) {\n  if (gltfDef.extras !== undefined) {\n    if (typeof gltfDef.extras === 'object') {\n      Object.assign(object.userData, gltfDef.extras)\n    } else {\n      console.warn('THREE.GLTFLoader: Ignoring primitive type .extras, ' + gltfDef.extras)\n    }\n  }\n}\n\n/**\n * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#morph-targets\n *\n * @param {BufferGeometry} geometry\n * @param {Array<GLTF.Target>} targets\n * @param {GLTFParser} parser\n * @return {Promise<BufferGeometry>}\n */\nfunction addMorphTargets(geometry, targets, parser) {\n  let hasMorphPosition = false\n  let hasMorphNormal = false\n  let hasMorphColor = false\n\n  for (let i = 0, il = targets.length; i < il; i++) {\n    const target = targets[i]\n\n    if (target.POSITION !== undefined) hasMorphPosition = true\n    if (target.NORMAL !== undefined) hasMorphNormal = true\n    if (target.COLOR_0 !== undefined) hasMorphColor = true\n\n    if (hasMorphPosition && hasMorphNormal && hasMorphColor) break\n  }\n\n  if (!hasMorphPosition && !hasMorphNormal && !hasMorphColor) return Promise.resolve(geometry)\n\n  const pendingPositionAccessors = []\n  const pendingNormalAccessors = []\n  const pendingColorAccessors = []\n\n  for (let i = 0, il = targets.length; i < il; i++) {\n    const target = targets[i]\n\n    if (hasMorphPosition) {\n      const pendingAccessor =\n        target.POSITION !== undefined ? parser.getDependency('accessor', target.POSITION) : geometry.attributes.position\n\n      pendingPositionAccessors.push(pendingAccessor)\n    }\n\n    if (hasMorphNormal) {\n      const pendingAccessor =\n        target.NORMAL !== undefined ? parser.getDependency('accessor', target.NORMAL) : geometry.attributes.normal\n\n      pendingNormalAccessors.push(pendingAccessor)\n    }\n\n    if (hasMorphColor) {\n      const pendingAccessor =\n        target.COLOR_0 !== undefined ? parser.getDependency('accessor', target.COLOR_0) : geometry.attributes.color\n\n      pendingColorAccessors.push(pendingAccessor)\n    }\n  }\n\n  return Promise.all([\n    Promise.all(pendingPositionAccessors),\n    Promise.all(pendingNormalAccessors),\n    Promise.all(pendingColorAccessors),\n  ]).then(function (accessors) {\n    const morphPositions = accessors[0]\n    const morphNormals = accessors[1]\n    const morphColors = accessors[2]\n\n    if (hasMorphPosition) geometry.morphAttributes.position = morphPositions\n    if (hasMorphNormal) geometry.morphAttributes.normal = morphNormals\n    if (hasMorphColor) geometry.morphAttributes.color = morphColors\n    geometry.morphTargetsRelative = true\n\n    return geometry\n  })\n}\n\n/**\n * @param {Mesh} mesh\n * @param {GLTF.Mesh} meshDef\n */\nfunction updateMorphTargets(mesh, meshDef) {\n  mesh.updateMorphTargets()\n\n  if (meshDef.weights !== undefined) {\n    for (let i = 0, il = meshDef.weights.length; i < il; i++) {\n      mesh.morphTargetInfluences[i] = meshDef.weights[i]\n    }\n  }\n\n  // .extras has user-defined data, so check that .extras.targetNames is an array.\n  if (meshDef.extras && Array.isArray(meshDef.extras.targetNames)) {\n    const targetNames = meshDef.extras.targetNames\n\n    if (mesh.morphTargetInfluences.length === targetNames.length) {\n      mesh.morphTargetDictionary = {}\n\n      for (let i = 0, il = targetNames.length; i < il; i++) {\n        mesh.morphTargetDictionary[targetNames[i]] = i\n      }\n    } else {\n      console.warn('THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.')\n    }\n  }\n}\n\nfunction createPrimitiveKey(primitiveDef) {\n  let geometryKey\n\n  const dracoExtension = primitiveDef.extensions && primitiveDef.extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION]\n\n  if (dracoExtension) {\n    geometryKey =\n      'draco:' +\n      dracoExtension.bufferView +\n      ':' +\n      dracoExtension.indices +\n      ':' +\n      createAttributesKey(dracoExtension.attributes)\n  } else {\n    geometryKey = primitiveDef.indices + ':' + createAttributesKey(primitiveDef.attributes) + ':' + primitiveDef.mode\n  }\n\n  if (primitiveDef.targets !== undefined) {\n    for (let i = 0, il = primitiveDef.targets.length; i < il; i++) {\n      geometryKey += ':' + createAttributesKey(primitiveDef.targets[i])\n    }\n  }\n\n  return geometryKey\n}\n\nfunction createAttributesKey(attributes) {\n  let attributesKey = ''\n\n  const keys = Object.keys(attributes).sort()\n\n  for (let i = 0, il = keys.length; i < il; i++) {\n    attributesKey += keys[i] + ':' + attributes[keys[i]] + ';'\n  }\n\n  return attributesKey\n}\n\nfunction getNormalizedComponentScale(constructor) {\n  // Reference:\n  // https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_mesh_quantization#encoding-quantized-data\n\n  switch (constructor) {\n    case Int8Array:\n      return 1 / 127\n\n    case Uint8Array:\n      return 1 / 255\n\n    case Int16Array:\n      return 1 / 32767\n\n    case Uint16Array:\n      return 1 / 65535\n\n    default:\n      throw new Error('THREE.GLTFLoader: Unsupported normalized accessor component type.')\n  }\n}\n\nfunction getImageURIMimeType(uri) {\n  if (uri.search(/\\.jpe?g($|\\?)/i) > 0 || uri.search(/^data\\:image\\/jpeg/) === 0) return 'image/jpeg'\n  if (uri.search(/\\.webp($|\\?)/i) > 0 || uri.search(/^data\\:image\\/webp/) === 0) return 'image/webp'\n\n  return 'image/png'\n}\n\nconst _identityMatrix = /* @__PURE__ */ new Matrix4()\n\n/* GLTF PARSER */\n\nclass GLTFParser {\n  constructor(json = {}, options = {}) {\n    this.json = json\n    this.extensions = {}\n    this.plugins = {}\n    this.options = options\n\n    // loader object cache\n    this.cache = new GLTFRegistry()\n\n    // associations between Three.js objects and glTF elements\n    this.associations = new Map()\n\n    // BufferGeometry caching\n    this.primitiveCache = {}\n\n    // Node cache\n    this.nodeCache = {}\n\n    // Object3D instance caches\n    this.meshCache = { refs: {}, uses: {} }\n    this.cameraCache = { refs: {}, uses: {} }\n    this.lightCache = { refs: {}, uses: {} }\n\n    this.sourceCache = {}\n    this.textureCache = {}\n\n    // Track node names, to ensure no duplicates\n    this.nodeNamesUsed = {}\n\n    // Use an ImageBitmapLoader if imageBitmaps are supported. Moves much of the\n    // expensive work of uploading a texture to the GPU off the main thread.\n\n    let isSafari = false\n    let isFirefox = false\n    let firefoxVersion = -1\n\n    if (typeof navigator !== 'undefined' && typeof navigator.userAgent !== 'undefined') {\n      isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent) === true\n      isFirefox = navigator.userAgent.indexOf('Firefox') > -1\n      firefoxVersion = isFirefox ? navigator.userAgent.match(/Firefox\\/([0-9]+)\\./)[1] : -1\n    }\n\n    if (typeof createImageBitmap === 'undefined' || isSafari || (isFirefox && firefoxVersion < 98)) {\n      this.textureLoader = new TextureLoader(this.options.manager)\n    } else {\n      this.textureLoader = new ImageBitmapLoader(this.options.manager)\n    }\n\n    this.textureLoader.setCrossOrigin(this.options.crossOrigin)\n    this.textureLoader.setRequestHeader(this.options.requestHeader)\n\n    this.fileLoader = new FileLoader(this.options.manager)\n    this.fileLoader.setResponseType('arraybuffer')\n\n    if (this.options.crossOrigin === 'use-credentials') {\n      this.fileLoader.setWithCredentials(true)\n    }\n  }\n\n  setExtensions(extensions) {\n    this.extensions = extensions\n  }\n\n  setPlugins(plugins) {\n    this.plugins = plugins\n  }\n\n  parse(onLoad, onError) {\n    const parser = this\n    const json = this.json\n    const extensions = this.extensions\n\n    // Clear the loader cache\n    this.cache.removeAll()\n    this.nodeCache = {}\n\n    // Mark the special nodes/meshes in json for efficient parse\n    this._invokeAll(function (ext) {\n      return ext._markDefs && ext._markDefs()\n    })\n\n    Promise.all(\n      this._invokeAll(function (ext) {\n        return ext.beforeRoot && ext.beforeRoot()\n      }),\n    )\n      .then(function () {\n        return Promise.all([\n          parser.getDependencies('scene'),\n          parser.getDependencies('animation'),\n          parser.getDependencies('camera'),\n        ])\n      })\n      .then(function (dependencies) {\n        const result = {\n          scene: dependencies[0][json.scene || 0],\n          scenes: dependencies[0],\n          animations: dependencies[1],\n          cameras: dependencies[2],\n          asset: json.asset,\n          parser: parser,\n          userData: {},\n        }\n\n        addUnknownExtensionsToUserData(extensions, result, json)\n\n        assignExtrasToUserData(result, json)\n\n        return Promise.all(\n          parser._invokeAll(function (ext) {\n            return ext.afterRoot && ext.afterRoot(result)\n          }),\n        ).then(function () {\n          for (const scene of result.scenes) {\n            scene.updateMatrixWorld()\n          }\n\n          onLoad(result)\n        })\n      })\n      .catch(onError)\n  }\n\n  /**\n   * Marks the special nodes/meshes in json for efficient parse.\n   */\n  _markDefs() {\n    const nodeDefs = this.json.nodes || []\n    const skinDefs = this.json.skins || []\n    const meshDefs = this.json.meshes || []\n\n    // Nothing in the node definition indicates whether it is a Bone or an\n    // Object3D. Use the skins' joint references to mark bones.\n    for (let skinIndex = 0, skinLength = skinDefs.length; skinIndex < skinLength; skinIndex++) {\n      const joints = skinDefs[skinIndex].joints\n\n      for (let i = 0, il = joints.length; i < il; i++) {\n        nodeDefs[joints[i]].isBone = true\n      }\n    }\n\n    // Iterate over all nodes, marking references to shared resources,\n    // as well as skeleton joints.\n    for (let nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex++) {\n      const nodeDef = nodeDefs[nodeIndex]\n\n      if (nodeDef.mesh !== undefined) {\n        this._addNodeRef(this.meshCache, nodeDef.mesh)\n\n        // Nothing in the mesh definition indicates whether it is\n        // a SkinnedMesh or Mesh. Use the node's mesh reference\n        // to mark SkinnedMesh if node has skin.\n        if (nodeDef.skin !== undefined) {\n          meshDefs[nodeDef.mesh].isSkinnedMesh = true\n        }\n      }\n\n      if (nodeDef.camera !== undefined) {\n        this._addNodeRef(this.cameraCache, nodeDef.camera)\n      }\n    }\n  }\n\n  /**\n   * Counts references to shared node / Object3D resources. These resources\n   * can be reused, or \"instantiated\", at multiple nodes in the scene\n   * hierarchy. Mesh, Camera, and Light instances are instantiated and must\n   * be marked. Non-scenegraph resources (like Materials, Geometries, and\n   * Textures) can be reused directly and are not marked here.\n   *\n   * Example: CesiumMilkTruck sample model reuses \"Wheel\" meshes.\n   */\n  _addNodeRef(cache, index) {\n    if (index === undefined) return\n\n    if (cache.refs[index] === undefined) {\n      cache.refs[index] = cache.uses[index] = 0\n    }\n\n    cache.refs[index]++\n  }\n\n  /** Returns a reference to a shared resource, cloning it if necessary. */\n  _getNodeRef(cache, index, object) {\n    if (cache.refs[index] <= 1) return object\n\n    const ref = object.clone()\n\n    // Propagates mappings to the cloned object, prevents mappings on the\n    // original object from being lost.\n    const updateMappings = (original, clone) => {\n      const mappings = this.associations.get(original)\n      if (mappings != null) {\n        this.associations.set(clone, mappings)\n      }\n\n      for (const [i, child] of original.children.entries()) {\n        updateMappings(child, clone.children[i])\n      }\n    }\n\n    updateMappings(object, ref)\n\n    ref.name += '_instance_' + cache.uses[index]++\n\n    return ref\n  }\n\n  _invokeOne(func) {\n    const extensions = Object.values(this.plugins)\n    extensions.push(this)\n\n    for (let i = 0; i < extensions.length; i++) {\n      const result = func(extensions[i])\n\n      if (result) return result\n    }\n\n    return null\n  }\n\n  _invokeAll(func) {\n    const extensions = Object.values(this.plugins)\n    extensions.unshift(this)\n\n    const pending = []\n\n    for (let i = 0; i < extensions.length; i++) {\n      const result = func(extensions[i])\n\n      if (result) pending.push(result)\n    }\n\n    return pending\n  }\n\n  /**\n   * Requests the specified dependency asynchronously, with caching.\n   * @param {string} type\n   * @param {number} index\n   * @return {Promise<Object3D|Material|THREE.Texture|AnimationClip|ArrayBuffer|Object>}\n   */\n  getDependency(type, index) {\n    const cacheKey = type + ':' + index\n    let dependency = this.cache.get(cacheKey)\n\n    if (!dependency) {\n      switch (type) {\n        case 'scene':\n          dependency = this.loadScene(index)\n          break\n\n        case 'node':\n          dependency = this._invokeOne(function (ext) {\n            return ext.loadNode && ext.loadNode(index)\n          })\n          break\n\n        case 'mesh':\n          dependency = this._invokeOne(function (ext) {\n            return ext.loadMesh && ext.loadMesh(index)\n          })\n          break\n\n        case 'accessor':\n          dependency = this.loadAccessor(index)\n          break\n\n        case 'bufferView':\n          dependency = this._invokeOne(function (ext) {\n            return ext.loadBufferView && ext.loadBufferView(index)\n          })\n          break\n\n        case 'buffer':\n          dependency = this.loadBuffer(index)\n          break\n\n        case 'material':\n          dependency = this._invokeOne(function (ext) {\n            return ext.loadMaterial && ext.loadMaterial(index)\n          })\n          break\n\n        case 'texture':\n          dependency = this._invokeOne(function (ext) {\n            return ext.loadTexture && ext.loadTexture(index)\n          })\n          break\n\n        case 'skin':\n          dependency = this.loadSkin(index)\n          break\n\n        case 'animation':\n          dependency = this._invokeOne(function (ext) {\n            return ext.loadAnimation && ext.loadAnimation(index)\n          })\n          break\n\n        case 'camera':\n          dependency = this.loadCamera(index)\n          break\n\n        default:\n          dependency = this._invokeOne(function (ext) {\n            return ext != this && ext.getDependency && ext.getDependency(type, index)\n          })\n\n          if (!dependency) {\n            throw new Error('Unknown type: ' + type)\n          }\n\n          break\n      }\n\n      this.cache.add(cacheKey, dependency)\n    }\n\n    return dependency\n  }\n\n  /**\n   * Requests all dependencies of the specified type asynchronously, with caching.\n   * @param {string} type\n   * @return {Promise<Array<Object>>}\n   */\n  getDependencies(type) {\n    let dependencies = this.cache.get(type)\n\n    if (!dependencies) {\n      const parser = this\n      const defs = this.json[type + (type === 'mesh' ? 'es' : 's')] || []\n\n      dependencies = Promise.all(\n        defs.map(function (def, index) {\n          return parser.getDependency(type, index)\n        }),\n      )\n\n      this.cache.add(type, dependencies)\n    }\n\n    return dependencies\n  }\n\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views\n   * @param {number} bufferIndex\n   * @return {Promise<ArrayBuffer>}\n   */\n  loadBuffer(bufferIndex) {\n    const bufferDef = this.json.buffers[bufferIndex]\n    const loader = this.fileLoader\n\n    if (bufferDef.type && bufferDef.type !== 'arraybuffer') {\n      throw new Error('THREE.GLTFLoader: ' + bufferDef.type + ' buffer type is not supported.')\n    }\n\n    // If present, GLB container is required to be the first buffer.\n    if (bufferDef.uri === undefined && bufferIndex === 0) {\n      return Promise.resolve(this.extensions[EXTENSIONS.KHR_BINARY_GLTF].body)\n    }\n\n    const options = this.options\n\n    return new Promise(function (resolve, reject) {\n      loader.load(LoaderUtils.resolveURL(bufferDef.uri, options.path), resolve, undefined, function () {\n        reject(new Error('THREE.GLTFLoader: Failed to load buffer \"' + bufferDef.uri + '\".'))\n      })\n    })\n  }\n\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views\n   * @param {number} bufferViewIndex\n   * @return {Promise<ArrayBuffer>}\n   */\n  loadBufferView(bufferViewIndex) {\n    const bufferViewDef = this.json.bufferViews[bufferViewIndex]\n\n    return this.getDependency('buffer', bufferViewDef.buffer).then(function (buffer) {\n      const byteLength = bufferViewDef.byteLength || 0\n      const byteOffset = bufferViewDef.byteOffset || 0\n      return buffer.slice(byteOffset, byteOffset + byteLength)\n    })\n  }\n\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#accessors\n   * @param {number} accessorIndex\n   * @return {Promise<BufferAttribute|InterleavedBufferAttribute>}\n   */\n  loadAccessor(accessorIndex) {\n    const parser = this\n    const json = this.json\n\n    const accessorDef = this.json.accessors[accessorIndex]\n\n    if (accessorDef.bufferView === undefined && accessorDef.sparse === undefined) {\n      const itemSize = WEBGL_TYPE_SIZES[accessorDef.type]\n      const TypedArray = WEBGL_COMPONENT_TYPES[accessorDef.componentType]\n      const normalized = accessorDef.normalized === true\n\n      const array = new TypedArray(accessorDef.count * itemSize)\n      return Promise.resolve(new BufferAttribute(array, itemSize, normalized))\n    }\n\n    const pendingBufferViews = []\n\n    if (accessorDef.bufferView !== undefined) {\n      pendingBufferViews.push(this.getDependency('bufferView', accessorDef.bufferView))\n    } else {\n      pendingBufferViews.push(null)\n    }\n\n    if (accessorDef.sparse !== undefined) {\n      pendingBufferViews.push(this.getDependency('bufferView', accessorDef.sparse.indices.bufferView))\n      pendingBufferViews.push(this.getDependency('bufferView', accessorDef.sparse.values.bufferView))\n    }\n\n    return Promise.all(pendingBufferViews).then(function (bufferViews) {\n      const bufferView = bufferViews[0]\n\n      const itemSize = WEBGL_TYPE_SIZES[accessorDef.type]\n      const TypedArray = WEBGL_COMPONENT_TYPES[accessorDef.componentType]\n\n      // For VEC3: itemSize is 3, elementBytes is 4, itemBytes is 12.\n      const elementBytes = TypedArray.BYTES_PER_ELEMENT\n      const itemBytes = elementBytes * itemSize\n      const byteOffset = accessorDef.byteOffset || 0\n      const byteStride =\n        accessorDef.bufferView !== undefined ? json.bufferViews[accessorDef.bufferView].byteStride : undefined\n      const normalized = accessorDef.normalized === true\n      let array, bufferAttribute\n\n      // The buffer is not interleaved if the stride is the item size in bytes.\n      if (byteStride && byteStride !== itemBytes) {\n        // Each \"slice\" of the buffer, as defined by 'count' elements of 'byteStride' bytes, gets its own InterleavedBuffer\n        // This makes sure that IBA.count reflects accessor.count properly\n        const ibSlice = Math.floor(byteOffset / byteStride)\n        const ibCacheKey =\n          'InterleavedBuffer:' +\n          accessorDef.bufferView +\n          ':' +\n          accessorDef.componentType +\n          ':' +\n          ibSlice +\n          ':' +\n          accessorDef.count\n        let ib = parser.cache.get(ibCacheKey)\n\n        if (!ib) {\n          array = new TypedArray(bufferView, ibSlice * byteStride, (accessorDef.count * byteStride) / elementBytes)\n\n          // Integer parameters to IB/IBA are in array elements, not bytes.\n          ib = new InterleavedBuffer(array, byteStride / elementBytes)\n\n          parser.cache.add(ibCacheKey, ib)\n        }\n\n        bufferAttribute = new InterleavedBufferAttribute(\n          ib,\n          itemSize,\n          (byteOffset % byteStride) / elementBytes,\n          normalized,\n        )\n      } else {\n        if (bufferView === null) {\n          array = new TypedArray(accessorDef.count * itemSize)\n        } else {\n          array = new TypedArray(bufferView, byteOffset, accessorDef.count * itemSize)\n        }\n\n        bufferAttribute = new BufferAttribute(array, itemSize, normalized)\n      }\n\n      // https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#sparse-accessors\n      if (accessorDef.sparse !== undefined) {\n        const itemSizeIndices = WEBGL_TYPE_SIZES.SCALAR\n        const TypedArrayIndices = WEBGL_COMPONENT_TYPES[accessorDef.sparse.indices.componentType]\n\n        const byteOffsetIndices = accessorDef.sparse.indices.byteOffset || 0\n        const byteOffsetValues = accessorDef.sparse.values.byteOffset || 0\n\n        const sparseIndices = new TypedArrayIndices(\n          bufferViews[1],\n          byteOffsetIndices,\n          accessorDef.sparse.count * itemSizeIndices,\n        )\n        const sparseValues = new TypedArray(bufferViews[2], byteOffsetValues, accessorDef.sparse.count * itemSize)\n\n        if (bufferView !== null) {\n          // Avoid modifying the original ArrayBuffer, if the bufferView wasn't initialized with zeroes.\n          bufferAttribute = new BufferAttribute(\n            bufferAttribute.array.slice(),\n            bufferAttribute.itemSize,\n            bufferAttribute.normalized,\n          )\n        }\n\n        for (let i = 0, il = sparseIndices.length; i < il; i++) {\n          const index = sparseIndices[i]\n\n          bufferAttribute.setX(index, sparseValues[i * itemSize])\n          if (itemSize >= 2) bufferAttribute.setY(index, sparseValues[i * itemSize + 1])\n          if (itemSize >= 3) bufferAttribute.setZ(index, sparseValues[i * itemSize + 2])\n          if (itemSize >= 4) bufferAttribute.setW(index, sparseValues[i * itemSize + 3])\n          if (itemSize >= 5) throw new Error('THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.')\n        }\n      }\n\n      return bufferAttribute\n    })\n  }\n\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#textures\n   * @param {number} textureIndex\n   * @return {Promise<THREE.Texture|null>}\n   */\n  loadTexture(textureIndex) {\n    const json = this.json\n    const options = this.options\n    const textureDef = json.textures[textureIndex]\n    const sourceIndex = textureDef.source\n    const sourceDef = json.images[sourceIndex]\n\n    let loader = this.textureLoader\n\n    if (sourceDef.uri) {\n      const handler = options.manager.getHandler(sourceDef.uri)\n      if (handler !== null) loader = handler\n    }\n\n    return this.loadTextureImage(textureIndex, sourceIndex, loader)\n  }\n\n  loadTextureImage(textureIndex, sourceIndex, loader) {\n    const parser = this\n    const json = this.json\n\n    const textureDef = json.textures[textureIndex]\n    const sourceDef = json.images[sourceIndex]\n\n    const cacheKey = (sourceDef.uri || sourceDef.bufferView) + ':' + textureDef.sampler\n\n    if (this.textureCache[cacheKey]) {\n      // See https://github.com/mrdoob/three.js/issues/21559.\n      return this.textureCache[cacheKey]\n    }\n\n    const promise = this.loadImageSource(sourceIndex, loader)\n      .then(function (texture) {\n        texture.flipY = false\n\n        texture.name = textureDef.name || sourceDef.name || ''\n\n        if (\n          texture.name === '' &&\n          typeof sourceDef.uri === 'string' &&\n          sourceDef.uri.startsWith('data:image/') === false\n        ) {\n          texture.name = sourceDef.uri\n        }\n\n        const samplers = json.samplers || {}\n        const sampler = samplers[textureDef.sampler] || {}\n\n        texture.magFilter = WEBGL_FILTERS[sampler.magFilter] || LinearFilter\n        texture.minFilter = WEBGL_FILTERS[sampler.minFilter] || LinearMipmapLinearFilter\n        texture.wrapS = WEBGL_WRAPPINGS[sampler.wrapS] || RepeatWrapping\n        texture.wrapT = WEBGL_WRAPPINGS[sampler.wrapT] || RepeatWrapping\n\n        parser.associations.set(texture, { textures: textureIndex })\n\n        return texture\n      })\n      .catch(function () {\n        return null\n      })\n\n    this.textureCache[cacheKey] = promise\n\n    return promise\n  }\n\n  loadImageSource(sourceIndex, loader) {\n    const parser = this\n    const json = this.json\n    const options = this.options\n\n    if (this.sourceCache[sourceIndex] !== undefined) {\n      return this.sourceCache[sourceIndex].then((texture) => texture.clone())\n    }\n\n    const sourceDef = json.images[sourceIndex]\n\n    const URL = self.URL || self.webkitURL\n\n    let sourceURI = sourceDef.uri || ''\n    let isObjectURL = false\n\n    if (sourceDef.bufferView !== undefined) {\n      // Load binary image data from bufferView, if provided.\n\n      sourceURI = parser.getDependency('bufferView', sourceDef.bufferView).then(function (bufferView) {\n        isObjectURL = true\n        const blob = new Blob([bufferView], { type: sourceDef.mimeType })\n        sourceURI = URL.createObjectURL(blob)\n        return sourceURI\n      })\n    } else if (sourceDef.uri === undefined) {\n      throw new Error('THREE.GLTFLoader: Image ' + sourceIndex + ' is missing URI and bufferView')\n    }\n\n    const promise = Promise.resolve(sourceURI)\n      .then(function (sourceURI) {\n        return new Promise(function (resolve, reject) {\n          let onLoad = resolve\n\n          if (loader.isImageBitmapLoader === true) {\n            onLoad = function (imageBitmap) {\n              const texture = new Texture(imageBitmap)\n              texture.needsUpdate = true\n\n              resolve(texture)\n            }\n          }\n\n          loader.load(LoaderUtils.resolveURL(sourceURI, options.path), onLoad, undefined, reject)\n        })\n      })\n      .then(function (texture) {\n        // Clean up resources and configure Texture.\n\n        if (isObjectURL === true) {\n          URL.revokeObjectURL(sourceURI)\n        }\n\n        assignExtrasToUserData(texture, sourceDef)\n\n        texture.userData.mimeType = sourceDef.mimeType || getImageURIMimeType(sourceDef.uri)\n\n        return texture\n      })\n      .catch(function (error) {\n        console.error(\"THREE.GLTFLoader: Couldn't load texture\", sourceURI)\n        throw error\n      })\n\n    this.sourceCache[sourceIndex] = promise\n    return promise\n  }\n\n  /**\n   * Asynchronously assigns a texture to the given material parameters.\n   * @param {Object} materialParams\n   * @param {string} mapName\n   * @param {Object} mapDef\n   * @return {Promise<Texture>}\n   */\n  assignTexture(materialParams, mapName, mapDef, colorSpace) {\n    const parser = this\n\n    return this.getDependency('texture', mapDef.index).then(function (texture) {\n      if (!texture) return null\n\n      if (mapDef.texCoord !== undefined && mapDef.texCoord > 0) {\n        texture = texture.clone()\n        texture.channel = mapDef.texCoord\n      }\n\n      if (parser.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM]) {\n        const transform =\n          mapDef.extensions !== undefined ? mapDef.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM] : undefined\n\n        if (transform) {\n          const gltfReference = parser.associations.get(texture)\n          texture = parser.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM].extendTexture(texture, transform)\n          parser.associations.set(texture, gltfReference)\n        }\n      }\n\n      if (colorSpace !== undefined) {\n        // Convert from legacy encoding to colorSpace\n        if (typeof colorSpace === 'number')\n          colorSpace = colorSpace === sRGBEncoding ? SRGBColorSpace : LinearSRGBColorSpace\n\n        // Set colorSpace if able, fallback to legacy encoding\n        if ('colorSpace' in texture) texture.colorSpace = colorSpace\n        else texture.encoding = colorSpace === SRGBColorSpace ? sRGBEncoding : LinearEncoding\n      }\n\n      materialParams[mapName] = texture\n\n      return texture\n    })\n  }\n\n  /**\n   * Assigns final material to a Mesh, Line, or Points instance. The instance\n   * already has a material (generated from the glTF material options alone)\n   * but reuse of the same glTF material may require multiple threejs materials\n   * to accommodate different primitive types, defines, etc. New materials will\n   * be created if necessary, and reused from a cache.\n   * @param  {Object3D} mesh Mesh, Line, or Points instance.\n   */\n  assignFinalMaterial(mesh) {\n    const geometry = mesh.geometry\n    let material = mesh.material\n\n    const useDerivativeTangents = geometry.attributes.tangent === undefined\n    const useVertexColors = geometry.attributes.color !== undefined\n    const useFlatShading = geometry.attributes.normal === undefined\n\n    if (mesh.isPoints) {\n      const cacheKey = 'PointsMaterial:' + material.uuid\n\n      let pointsMaterial = this.cache.get(cacheKey)\n\n      if (!pointsMaterial) {\n        pointsMaterial = new PointsMaterial()\n        Material.prototype.copy.call(pointsMaterial, material)\n        pointsMaterial.color.copy(material.color)\n        pointsMaterial.map = material.map\n        pointsMaterial.sizeAttenuation = false // glTF spec says points should be 1px\n\n        this.cache.add(cacheKey, pointsMaterial)\n      }\n\n      material = pointsMaterial\n    } else if (mesh.isLine) {\n      const cacheKey = 'LineBasicMaterial:' + material.uuid\n\n      let lineMaterial = this.cache.get(cacheKey)\n\n      if (!lineMaterial) {\n        lineMaterial = new LineBasicMaterial()\n        Material.prototype.copy.call(lineMaterial, material)\n        lineMaterial.color.copy(material.color)\n        lineMaterial.map = material.map\n\n        this.cache.add(cacheKey, lineMaterial)\n      }\n\n      material = lineMaterial\n    }\n\n    // Clone the material if it will be modified\n    if (useDerivativeTangents || useVertexColors || useFlatShading) {\n      let cacheKey = 'ClonedMaterial:' + material.uuid + ':'\n\n      if (useDerivativeTangents) cacheKey += 'derivative-tangents:'\n      if (useVertexColors) cacheKey += 'vertex-colors:'\n      if (useFlatShading) cacheKey += 'flat-shading:'\n\n      let cachedMaterial = this.cache.get(cacheKey)\n\n      if (!cachedMaterial) {\n        cachedMaterial = material.clone()\n\n        if (useVertexColors) cachedMaterial.vertexColors = true\n        if (useFlatShading) cachedMaterial.flatShading = true\n\n        if (useDerivativeTangents) {\n          // https://github.com/mrdoob/three.js/issues/11438#issuecomment-507003995\n          if (cachedMaterial.normalScale) cachedMaterial.normalScale.y *= -1\n          if (cachedMaterial.clearcoatNormalScale) cachedMaterial.clearcoatNormalScale.y *= -1\n        }\n\n        this.cache.add(cacheKey, cachedMaterial)\n\n        this.associations.set(cachedMaterial, this.associations.get(material))\n      }\n\n      material = cachedMaterial\n    }\n\n    mesh.material = material\n  }\n\n  getMaterialType(/* materialIndex */) {\n    return MeshStandardMaterial\n  }\n\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#materials\n   * @param {number} materialIndex\n   * @return {Promise<Material>}\n   */\n  loadMaterial(materialIndex) {\n    const parser = this\n    const json = this.json\n    const extensions = this.extensions\n    const materialDef = json.materials[materialIndex]\n\n    let materialType\n    const materialParams = {}\n    const materialExtensions = materialDef.extensions || {}\n\n    const pending = []\n\n    if (materialExtensions[EXTENSIONS.KHR_MATERIALS_UNLIT]) {\n      const kmuExtension = extensions[EXTENSIONS.KHR_MATERIALS_UNLIT]\n      materialType = kmuExtension.getMaterialType()\n      pending.push(kmuExtension.extendParams(materialParams, materialDef, parser))\n    } else {\n      // Specification:\n      // https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#metallic-roughness-material\n\n      const metallicRoughness = materialDef.pbrMetallicRoughness || {}\n\n      materialParams.color = new Color(1.0, 1.0, 1.0)\n      materialParams.opacity = 1.0\n\n      if (Array.isArray(metallicRoughness.baseColorFactor)) {\n        const array = metallicRoughness.baseColorFactor\n\n        materialParams.color.setRGB(array[0], array[1], array[2], LinearSRGBColorSpace)\n        materialParams.opacity = array[3]\n      }\n\n      if (metallicRoughness.baseColorTexture !== undefined) {\n        pending.push(parser.assignTexture(materialParams, 'map', metallicRoughness.baseColorTexture, SRGBColorSpace))\n      }\n\n      materialParams.metalness = metallicRoughness.metallicFactor !== undefined ? metallicRoughness.metallicFactor : 1.0\n      materialParams.roughness =\n        metallicRoughness.roughnessFactor !== undefined ? metallicRoughness.roughnessFactor : 1.0\n\n      if (metallicRoughness.metallicRoughnessTexture !== undefined) {\n        pending.push(parser.assignTexture(materialParams, 'metalnessMap', metallicRoughness.metallicRoughnessTexture))\n        pending.push(parser.assignTexture(materialParams, 'roughnessMap', metallicRoughness.metallicRoughnessTexture))\n      }\n\n      materialType = this._invokeOne(function (ext) {\n        return ext.getMaterialType && ext.getMaterialType(materialIndex)\n      })\n\n      pending.push(\n        Promise.all(\n          this._invokeAll(function (ext) {\n            return ext.extendMaterialParams && ext.extendMaterialParams(materialIndex, materialParams)\n          }),\n        ),\n      )\n    }\n\n    if (materialDef.doubleSided === true) {\n      materialParams.side = DoubleSide\n    }\n\n    const alphaMode = materialDef.alphaMode || ALPHA_MODES.OPAQUE\n\n    if (alphaMode === ALPHA_MODES.BLEND) {\n      materialParams.transparent = true\n\n      // See: https://github.com/mrdoob/three.js/issues/17706\n      materialParams.depthWrite = false\n    } else {\n      materialParams.transparent = false\n\n      if (alphaMode === ALPHA_MODES.MASK) {\n        materialParams.alphaTest = materialDef.alphaCutoff !== undefined ? materialDef.alphaCutoff : 0.5\n      }\n    }\n\n    if (materialDef.normalTexture !== undefined && materialType !== MeshBasicMaterial) {\n      pending.push(parser.assignTexture(materialParams, 'normalMap', materialDef.normalTexture))\n\n      materialParams.normalScale = new Vector2(1, 1)\n\n      if (materialDef.normalTexture.scale !== undefined) {\n        const scale = materialDef.normalTexture.scale\n\n        materialParams.normalScale.set(scale, scale)\n      }\n    }\n\n    if (materialDef.occlusionTexture !== undefined && materialType !== MeshBasicMaterial) {\n      pending.push(parser.assignTexture(materialParams, 'aoMap', materialDef.occlusionTexture))\n\n      if (materialDef.occlusionTexture.strength !== undefined) {\n        materialParams.aoMapIntensity = materialDef.occlusionTexture.strength\n      }\n    }\n\n    if (materialDef.emissiveFactor !== undefined && materialType !== MeshBasicMaterial) {\n      const emissiveFactor = materialDef.emissiveFactor\n      materialParams.emissive = new Color().setRGB(\n        emissiveFactor[0],\n        emissiveFactor[1],\n        emissiveFactor[2],\n        LinearSRGBColorSpace,\n      )\n    }\n\n    if (materialDef.emissiveTexture !== undefined && materialType !== MeshBasicMaterial) {\n      pending.push(parser.assignTexture(materialParams, 'emissiveMap', materialDef.emissiveTexture, SRGBColorSpace))\n    }\n\n    return Promise.all(pending).then(function () {\n      const material = new materialType(materialParams)\n\n      if (materialDef.name) material.name = materialDef.name\n\n      assignExtrasToUserData(material, materialDef)\n\n      parser.associations.set(material, { materials: materialIndex })\n\n      if (materialDef.extensions) addUnknownExtensionsToUserData(extensions, material, materialDef)\n\n      return material\n    })\n  }\n\n  /** When Object3D instances are targeted by animation, they need unique names. */\n  createUniqueName(originalName) {\n    const sanitizedName = PropertyBinding.sanitizeNodeName(originalName || '')\n\n    if (sanitizedName in this.nodeNamesUsed) {\n      return sanitizedName + '_' + ++this.nodeNamesUsed[sanitizedName]\n    } else {\n      this.nodeNamesUsed[sanitizedName] = 0\n\n      return sanitizedName\n    }\n  }\n\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#geometry\n   *\n   * Creates BufferGeometries from primitives.\n   *\n   * @param {Array<GLTF.Primitive>} primitives\n   * @return {Promise<Array<BufferGeometry>>}\n   */\n  loadGeometries(primitives) {\n    const parser = this\n    const extensions = this.extensions\n    const cache = this.primitiveCache\n\n    function createDracoPrimitive(primitive) {\n      return extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION]\n        .decodePrimitive(primitive, parser)\n        .then(function (geometry) {\n          return addPrimitiveAttributes(geometry, primitive, parser)\n        })\n    }\n\n    const pending = []\n\n    for (let i = 0, il = primitives.length; i < il; i++) {\n      const primitive = primitives[i]\n      const cacheKey = createPrimitiveKey(primitive)\n\n      // See if we've already created this geometry\n      const cached = cache[cacheKey]\n\n      if (cached) {\n        // Use the cached geometry if it exists\n        pending.push(cached.promise)\n      } else {\n        let geometryPromise\n\n        if (primitive.extensions && primitive.extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION]) {\n          // Use DRACO geometry if available\n          geometryPromise = createDracoPrimitive(primitive)\n        } else {\n          // Otherwise create a new geometry\n          geometryPromise = addPrimitiveAttributes(new BufferGeometry(), primitive, parser)\n        }\n\n        // Cache this geometry\n        cache[cacheKey] = { primitive: primitive, promise: geometryPromise }\n\n        pending.push(geometryPromise)\n      }\n    }\n\n    return Promise.all(pending)\n  }\n\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#meshes\n   * @param {number} meshIndex\n   * @return {Promise<Group|Mesh|SkinnedMesh>}\n   */\n  loadMesh(meshIndex) {\n    const parser = this\n    const json = this.json\n    const extensions = this.extensions\n\n    const meshDef = json.meshes[meshIndex]\n    const primitives = meshDef.primitives\n\n    const pending = []\n\n    for (let i = 0, il = primitives.length; i < il; i++) {\n      const material =\n        primitives[i].material === undefined\n          ? createDefaultMaterial(this.cache)\n          : this.getDependency('material', primitives[i].material)\n\n      pending.push(material)\n    }\n\n    pending.push(parser.loadGeometries(primitives))\n\n    return Promise.all(pending).then(function (results) {\n      const materials = results.slice(0, results.length - 1)\n      const geometries = results[results.length - 1]\n\n      const meshes = []\n\n      for (let i = 0, il = geometries.length; i < il; i++) {\n        const geometry = geometries[i]\n        const primitive = primitives[i]\n\n        // 1. create Mesh\n\n        let mesh\n\n        const material = materials[i]\n\n        if (\n          primitive.mode === WEBGL_CONSTANTS.TRIANGLES ||\n          primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP ||\n          primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN ||\n          primitive.mode === undefined\n        ) {\n          // .isSkinnedMesh isn't in glTF spec. See ._markDefs()\n          mesh = meshDef.isSkinnedMesh === true ? new SkinnedMesh(geometry, material) : new Mesh(geometry, material)\n\n          if (mesh.isSkinnedMesh === true) {\n            // normalize skin weights to fix malformed assets (see #15319)\n            mesh.normalizeSkinWeights()\n          }\n\n          if (primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP) {\n            mesh.geometry = toTrianglesDrawMode(mesh.geometry, TriangleStripDrawMode)\n          } else if (primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN) {\n            mesh.geometry = toTrianglesDrawMode(mesh.geometry, TriangleFanDrawMode)\n          }\n        } else if (primitive.mode === WEBGL_CONSTANTS.LINES) {\n          mesh = new LineSegments(geometry, material)\n        } else if (primitive.mode === WEBGL_CONSTANTS.LINE_STRIP) {\n          mesh = new Line(geometry, material)\n        } else if (primitive.mode === WEBGL_CONSTANTS.LINE_LOOP) {\n          mesh = new LineLoop(geometry, material)\n        } else if (primitive.mode === WEBGL_CONSTANTS.POINTS) {\n          mesh = new Points(geometry, material)\n        } else {\n          throw new Error('THREE.GLTFLoader: Primitive mode unsupported: ' + primitive.mode)\n        }\n\n        if (Object.keys(mesh.geometry.morphAttributes).length > 0) {\n          updateMorphTargets(mesh, meshDef)\n        }\n\n        mesh.name = parser.createUniqueName(meshDef.name || 'mesh_' + meshIndex)\n\n        assignExtrasToUserData(mesh, meshDef)\n\n        if (primitive.extensions) addUnknownExtensionsToUserData(extensions, mesh, primitive)\n\n        parser.assignFinalMaterial(mesh)\n\n        meshes.push(mesh)\n      }\n\n      for (let i = 0, il = meshes.length; i < il; i++) {\n        parser.associations.set(meshes[i], {\n          meshes: meshIndex,\n          primitives: i,\n        })\n      }\n\n      if (meshes.length === 1) {\n        if (meshDef.extensions) addUnknownExtensionsToUserData(extensions, meshes[0], meshDef)\n\n        return meshes[0]\n      }\n\n      const group = new Group()\n\n      if (meshDef.extensions) addUnknownExtensionsToUserData(extensions, group, meshDef)\n\n      parser.associations.set(group, { meshes: meshIndex })\n\n      for (let i = 0, il = meshes.length; i < il; i++) {\n        group.add(meshes[i])\n      }\n\n      return group\n    })\n  }\n\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#cameras\n   * @param {number} cameraIndex\n   * @return {Promise<THREE.Camera>}\n   */\n  loadCamera(cameraIndex) {\n    let camera\n    const cameraDef = this.json.cameras[cameraIndex]\n    const params = cameraDef[cameraDef.type]\n\n    if (!params) {\n      console.warn('THREE.GLTFLoader: Missing camera parameters.')\n      return\n    }\n\n    if (cameraDef.type === 'perspective') {\n      camera = new PerspectiveCamera(\n        MathUtils.radToDeg(params.yfov),\n        params.aspectRatio || 1,\n        params.znear || 1,\n        params.zfar || 2e6,\n      )\n    } else if (cameraDef.type === 'orthographic') {\n      camera = new OrthographicCamera(-params.xmag, params.xmag, params.ymag, -params.ymag, params.znear, params.zfar)\n    }\n\n    if (cameraDef.name) camera.name = this.createUniqueName(cameraDef.name)\n\n    assignExtrasToUserData(camera, cameraDef)\n\n    return Promise.resolve(camera)\n  }\n\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#skins\n   * @param {number} skinIndex\n   * @return {Promise<Skeleton>}\n   */\n  loadSkin(skinIndex) {\n    const skinDef = this.json.skins[skinIndex]\n\n    const pending = []\n\n    for (let i = 0, il = skinDef.joints.length; i < il; i++) {\n      pending.push(this._loadNodeShallow(skinDef.joints[i]))\n    }\n\n    if (skinDef.inverseBindMatrices !== undefined) {\n      pending.push(this.getDependency('accessor', skinDef.inverseBindMatrices))\n    } else {\n      pending.push(null)\n    }\n\n    return Promise.all(pending).then(function (results) {\n      const inverseBindMatrices = results.pop()\n      const jointNodes = results\n\n      // Note that bones (joint nodes) may or may not be in the\n      // scene graph at this time.\n\n      const bones = []\n      const boneInverses = []\n\n      for (let i = 0, il = jointNodes.length; i < il; i++) {\n        const jointNode = jointNodes[i]\n\n        if (jointNode) {\n          bones.push(jointNode)\n\n          const mat = new Matrix4()\n\n          if (inverseBindMatrices !== null) {\n            mat.fromArray(inverseBindMatrices.array, i * 16)\n          }\n\n          boneInverses.push(mat)\n        } else {\n          console.warn('THREE.GLTFLoader: Joint \"%s\" could not be found.', skinDef.joints[i])\n        }\n      }\n\n      return new Skeleton(bones, boneInverses)\n    })\n  }\n\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#animations\n   * @param {number} animationIndex\n   * @return {Promise<AnimationClip>}\n   */\n  loadAnimation(animationIndex) {\n    const json = this.json\n    const parser = this\n\n    const animationDef = json.animations[animationIndex]\n    const animationName = animationDef.name ? animationDef.name : 'animation_' + animationIndex\n\n    const pendingNodes = []\n    const pendingInputAccessors = []\n    const pendingOutputAccessors = []\n    const pendingSamplers = []\n    const pendingTargets = []\n\n    for (let i = 0, il = animationDef.channels.length; i < il; i++) {\n      const channel = animationDef.channels[i]\n      const sampler = animationDef.samplers[channel.sampler]\n      const target = channel.target\n      const name = target.node\n      const input = animationDef.parameters !== undefined ? animationDef.parameters[sampler.input] : sampler.input\n      const output = animationDef.parameters !== undefined ? animationDef.parameters[sampler.output] : sampler.output\n\n      if (target.node === undefined) continue\n\n      pendingNodes.push(this.getDependency('node', name))\n      pendingInputAccessors.push(this.getDependency('accessor', input))\n      pendingOutputAccessors.push(this.getDependency('accessor', output))\n      pendingSamplers.push(sampler)\n      pendingTargets.push(target)\n    }\n\n    return Promise.all([\n      Promise.all(pendingNodes),\n      Promise.all(pendingInputAccessors),\n      Promise.all(pendingOutputAccessors),\n      Promise.all(pendingSamplers),\n      Promise.all(pendingTargets),\n    ]).then(function (dependencies) {\n      const nodes = dependencies[0]\n      const inputAccessors = dependencies[1]\n      const outputAccessors = dependencies[2]\n      const samplers = dependencies[3]\n      const targets = dependencies[4]\n\n      const tracks = []\n\n      for (let i = 0, il = nodes.length; i < il; i++) {\n        const node = nodes[i]\n        const inputAccessor = inputAccessors[i]\n        const outputAccessor = outputAccessors[i]\n        const sampler = samplers[i]\n        const target = targets[i]\n\n        if (node === undefined) continue\n\n        if (node.updateMatrix) {\n          node.updateMatrix()\n        }\n\n        const createdTracks = parser._createAnimationTracks(node, inputAccessor, outputAccessor, sampler, target)\n\n        if (createdTracks) {\n          for (let k = 0; k < createdTracks.length; k++) {\n            tracks.push(createdTracks[k])\n          }\n        }\n      }\n\n      return new AnimationClip(animationName, undefined, tracks)\n    })\n  }\n\n  createNodeMesh(nodeIndex) {\n    const json = this.json\n    const parser = this\n    const nodeDef = json.nodes[nodeIndex]\n\n    if (nodeDef.mesh === undefined) return null\n\n    return parser.getDependency('mesh', nodeDef.mesh).then(function (mesh) {\n      const node = parser._getNodeRef(parser.meshCache, nodeDef.mesh, mesh)\n\n      // if weights are provided on the node, override weights on the mesh.\n      if (nodeDef.weights !== undefined) {\n        node.traverse(function (o) {\n          if (!o.isMesh) return\n\n          for (let i = 0, il = nodeDef.weights.length; i < il; i++) {\n            o.morphTargetInfluences[i] = nodeDef.weights[i]\n          }\n        })\n      }\n\n      return node\n    })\n  }\n\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#nodes-and-hierarchy\n   * @param {number} nodeIndex\n   * @return {Promise<Object3D>}\n   */\n  loadNode(nodeIndex) {\n    const json = this.json\n    const parser = this\n\n    const nodeDef = json.nodes[nodeIndex]\n\n    const nodePending = parser._loadNodeShallow(nodeIndex)\n\n    const childPending = []\n    const childrenDef = nodeDef.children || []\n\n    for (let i = 0, il = childrenDef.length; i < il; i++) {\n      childPending.push(parser.getDependency('node', childrenDef[i]))\n    }\n\n    const skeletonPending =\n      nodeDef.skin === undefined ? Promise.resolve(null) : parser.getDependency('skin', nodeDef.skin)\n\n    return Promise.all([nodePending, Promise.all(childPending), skeletonPending]).then(function (results) {\n      const node = results[0]\n      const children = results[1]\n      const skeleton = results[2]\n\n      if (skeleton !== null) {\n        // This full traverse should be fine because\n        // child glTF nodes have not been added to this node yet.\n        node.traverse(function (mesh) {\n          if (!mesh.isSkinnedMesh) return\n\n          mesh.bind(skeleton, _identityMatrix)\n        })\n      }\n\n      for (let i = 0, il = children.length; i < il; i++) {\n        node.add(children[i])\n      }\n\n      return node\n    })\n  }\n\n  // ._loadNodeShallow() parses a single node.\n  // skin and child nodes are created and added in .loadNode() (no '_' prefix).\n  _loadNodeShallow(nodeIndex) {\n    const json = this.json\n    const extensions = this.extensions\n    const parser = this\n\n    // This method is called from .loadNode() and .loadSkin().\n    // Cache a node to avoid duplication.\n\n    if (this.nodeCache[nodeIndex] !== undefined) {\n      return this.nodeCache[nodeIndex]\n    }\n\n    const nodeDef = json.nodes[nodeIndex]\n\n    // reserve node's name before its dependencies, so the root has the intended name.\n    const nodeName = nodeDef.name ? parser.createUniqueName(nodeDef.name) : ''\n\n    const pending = []\n\n    const meshPromise = parser._invokeOne(function (ext) {\n      return ext.createNodeMesh && ext.createNodeMesh(nodeIndex)\n    })\n\n    if (meshPromise) {\n      pending.push(meshPromise)\n    }\n\n    if (nodeDef.camera !== undefined) {\n      pending.push(\n        parser.getDependency('camera', nodeDef.camera).then(function (camera) {\n          return parser._getNodeRef(parser.cameraCache, nodeDef.camera, camera)\n        }),\n      )\n    }\n\n    parser\n      ._invokeAll(function (ext) {\n        return ext.createNodeAttachment && ext.createNodeAttachment(nodeIndex)\n      })\n      .forEach(function (promise) {\n        pending.push(promise)\n      })\n\n    this.nodeCache[nodeIndex] = Promise.all(pending).then(function (objects) {\n      let node\n\n      // .isBone isn't in glTF spec. See ._markDefs\n      if (nodeDef.isBone === true) {\n        node = new Bone()\n      } else if (objects.length > 1) {\n        node = new Group()\n      } else if (objects.length === 1) {\n        node = objects[0]\n      } else {\n        node = new Object3D()\n      }\n\n      if (node !== objects[0]) {\n        for (let i = 0, il = objects.length; i < il; i++) {\n          node.add(objects[i])\n        }\n      }\n\n      if (nodeDef.name) {\n        node.userData.name = nodeDef.name\n        node.name = nodeName\n      }\n\n      assignExtrasToUserData(node, nodeDef)\n\n      if (nodeDef.extensions) addUnknownExtensionsToUserData(extensions, node, nodeDef)\n\n      if (nodeDef.matrix !== undefined) {\n        const matrix = new Matrix4()\n        matrix.fromArray(nodeDef.matrix)\n        node.applyMatrix4(matrix)\n      } else {\n        if (nodeDef.translation !== undefined) {\n          node.position.fromArray(nodeDef.translation)\n        }\n\n        if (nodeDef.rotation !== undefined) {\n          node.quaternion.fromArray(nodeDef.rotation)\n        }\n\n        if (nodeDef.scale !== undefined) {\n          node.scale.fromArray(nodeDef.scale)\n        }\n      }\n\n      if (!parser.associations.has(node)) {\n        parser.associations.set(node, {})\n      }\n\n      parser.associations.get(node).nodes = nodeIndex\n\n      return node\n    })\n\n    return this.nodeCache[nodeIndex]\n  }\n\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#scenes\n   * @param {number} sceneIndex\n   * @return {Promise<Group>}\n   */\n  loadScene(sceneIndex) {\n    const extensions = this.extensions\n    const sceneDef = this.json.scenes[sceneIndex]\n    const parser = this\n\n    // Loader returns Group, not Scene.\n    // See: https://github.com/mrdoob/three.js/issues/18342#issuecomment-578981172\n    const scene = new Group()\n    if (sceneDef.name) scene.name = parser.createUniqueName(sceneDef.name)\n\n    assignExtrasToUserData(scene, sceneDef)\n\n    if (sceneDef.extensions) addUnknownExtensionsToUserData(extensions, scene, sceneDef)\n\n    const nodeIds = sceneDef.nodes || []\n\n    const pending = []\n\n    for (let i = 0, il = nodeIds.length; i < il; i++) {\n      pending.push(parser.getDependency('node', nodeIds[i]))\n    }\n\n    return Promise.all(pending).then(function (nodes) {\n      for (let i = 0, il = nodes.length; i < il; i++) {\n        scene.add(nodes[i])\n      }\n\n      // Removes dangling associations, associations that reference a node that\n      // didn't make it into the scene.\n      const reduceAssociations = (node) => {\n        const reducedAssociations = new Map()\n\n        for (const [key, value] of parser.associations) {\n          if (key instanceof Material || key instanceof Texture) {\n            reducedAssociations.set(key, value)\n          }\n        }\n\n        node.traverse((node) => {\n          const mappings = parser.associations.get(node)\n\n          if (mappings != null) {\n            reducedAssociations.set(node, mappings)\n          }\n        })\n\n        return reducedAssociations\n      }\n\n      parser.associations = reduceAssociations(scene)\n\n      return scene\n    })\n  }\n\n  _createAnimationTracks(node, inputAccessor, outputAccessor, sampler, target) {\n    const tracks = []\n\n    const targetName = node.name ? node.name : node.uuid\n    const targetNames = []\n\n    if (PATH_PROPERTIES[target.path] === PATH_PROPERTIES.weights) {\n      node.traverse(function (object) {\n        if (object.morphTargetInfluences) {\n          targetNames.push(object.name ? object.name : object.uuid)\n        }\n      })\n    } else {\n      targetNames.push(targetName)\n    }\n\n    let TypedKeyframeTrack\n\n    switch (PATH_PROPERTIES[target.path]) {\n      case PATH_PROPERTIES.weights:\n        TypedKeyframeTrack = NumberKeyframeTrack\n        break\n\n      case PATH_PROPERTIES.rotation:\n        TypedKeyframeTrack = QuaternionKeyframeTrack\n        break\n\n      case PATH_PROPERTIES.position:\n      case PATH_PROPERTIES.scale:\n        TypedKeyframeTrack = VectorKeyframeTrack\n        break\n\n      default:\n        switch (outputAccessor.itemSize) {\n          case 1:\n            TypedKeyframeTrack = NumberKeyframeTrack\n            break\n          case 2:\n          case 3:\n          default:\n            TypedKeyframeTrack = VectorKeyframeTrack\n            break\n        }\n\n        break\n    }\n\n    const interpolation = sampler.interpolation !== undefined ? INTERPOLATION[sampler.interpolation] : InterpolateLinear\n\n    const outputArray = this._getArrayFromAccessor(outputAccessor)\n\n    for (let j = 0, jl = targetNames.length; j < jl; j++) {\n      const track = new TypedKeyframeTrack(\n        targetNames[j] + '.' + PATH_PROPERTIES[target.path],\n        inputAccessor.array,\n        outputArray,\n        interpolation,\n      )\n\n      // Override interpolation with custom factory method.\n      if (sampler.interpolation === 'CUBICSPLINE') {\n        this._createCubicSplineTrackInterpolant(track)\n      }\n\n      tracks.push(track)\n    }\n\n    return tracks\n  }\n\n  _getArrayFromAccessor(accessor) {\n    let outputArray = accessor.array\n\n    if (accessor.normalized) {\n      const scale = getNormalizedComponentScale(outputArray.constructor)\n      const scaled = new Float32Array(outputArray.length)\n\n      for (let j = 0, jl = outputArray.length; j < jl; j++) {\n        scaled[j] = outputArray[j] * scale\n      }\n\n      outputArray = scaled\n    }\n\n    return outputArray\n  }\n\n  _createCubicSplineTrackInterpolant(track) {\n    track.createInterpolant = function InterpolantFactoryMethodGLTFCubicSpline(result) {\n      // A CUBICSPLINE keyframe in glTF has three output values for each input value,\n      // representing inTangent, splineVertex, and outTangent. As a result, track.getValueSize()\n      // must be divided by three to get the interpolant's sampleSize argument.\n\n      const interpolantType =\n        this instanceof QuaternionKeyframeTrack ? GLTFCubicSplineQuaternionInterpolant : GLTFCubicSplineInterpolant\n\n      return new interpolantType(this.times, this.values, this.getValueSize() / 3, result)\n    }\n\n    // Mark as CUBICSPLINE. `track.getInterpolation()` doesn't support custom interpolants.\n    track.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = true\n  }\n}\n\n/**\n * @param {BufferGeometry} geometry\n * @param {GLTF.Primitive} primitiveDef\n * @param {GLTFParser} parser\n */\nfunction computeBounds(geometry, primitiveDef, parser) {\n  const attributes = primitiveDef.attributes\n\n  const box = new Box3()\n\n  if (attributes.POSITION !== undefined) {\n    const accessor = parser.json.accessors[attributes.POSITION]\n\n    const min = accessor.min\n    const max = accessor.max\n\n    // glTF requires 'min' and 'max', but VRM (which extends glTF) currently ignores that requirement.\n\n    if (min !== undefined && max !== undefined) {\n      box.set(new Vector3(min[0], min[1], min[2]), new Vector3(max[0], max[1], max[2]))\n\n      if (accessor.normalized) {\n        const boxScale = getNormalizedComponentScale(WEBGL_COMPONENT_TYPES[accessor.componentType])\n        box.min.multiplyScalar(boxScale)\n        box.max.multiplyScalar(boxScale)\n      }\n    } else {\n      console.warn('THREE.GLTFLoader: Missing min/max properties for accessor POSITION.')\n\n      return\n    }\n  } else {\n    return\n  }\n\n  const targets = primitiveDef.targets\n\n  if (targets !== undefined) {\n    const maxDisplacement = new Vector3()\n    const vector = new Vector3()\n\n    for (let i = 0, il = targets.length; i < il; i++) {\n      const target = targets[i]\n\n      if (target.POSITION !== undefined) {\n        const accessor = parser.json.accessors[target.POSITION]\n        const min = accessor.min\n        const max = accessor.max\n\n        // glTF requires 'min' and 'max', but VRM (which extends glTF) currently ignores that requirement.\n\n        if (min !== undefined && max !== undefined) {\n          // we need to get max of absolute components because target weight is [-1,1]\n          vector.setX(Math.max(Math.abs(min[0]), Math.abs(max[0])))\n          vector.setY(Math.max(Math.abs(min[1]), Math.abs(max[1])))\n          vector.setZ(Math.max(Math.abs(min[2]), Math.abs(max[2])))\n\n          if (accessor.normalized) {\n            const boxScale = getNormalizedComponentScale(WEBGL_COMPONENT_TYPES[accessor.componentType])\n            vector.multiplyScalar(boxScale)\n          }\n\n          // Note: this assumes that the sum of all weights is at most 1. This isn't quite correct - it's more conservative\n          // to assume that each target can have a max weight of 1. However, for some use cases - notably, when morph targets\n          // are used to implement key-frame animations and as such only two are active at a time - this results in very large\n          // boxes. So for now we make a box that's sometimes a touch too small but is hopefully mostly of reasonable size.\n          maxDisplacement.max(vector)\n        } else {\n          console.warn('THREE.GLTFLoader: Missing min/max properties for accessor POSITION.')\n        }\n      }\n    }\n\n    // As per comment above this box isn't conservative, but has a reasonable size for a very large number of morph targets.\n    box.expandByVector(maxDisplacement)\n  }\n\n  geometry.boundingBox = box\n\n  const sphere = new Sphere()\n\n  box.getCenter(sphere.center)\n  sphere.radius = box.min.distanceTo(box.max) / 2\n\n  geometry.boundingSphere = sphere\n}\n\n/**\n * @param {BufferGeometry} geometry\n * @param {GLTF.Primitive} primitiveDef\n * @param {GLTFParser} parser\n * @return {Promise<BufferGeometry>}\n */\nfunction addPrimitiveAttributes(geometry, primitiveDef, parser) {\n  const attributes = primitiveDef.attributes\n\n  const pending = []\n\n  function assignAttributeAccessor(accessorIndex, attributeName) {\n    return parser.getDependency('accessor', accessorIndex).then(function (accessor) {\n      geometry.setAttribute(attributeName, accessor)\n    })\n  }\n\n  for (const gltfAttributeName in attributes) {\n    const threeAttributeName = ATTRIBUTES[gltfAttributeName] || gltfAttributeName.toLowerCase()\n\n    // Skip attributes already provided by e.g. Draco extension.\n    if (threeAttributeName in geometry.attributes) continue\n\n    pending.push(assignAttributeAccessor(attributes[gltfAttributeName], threeAttributeName))\n  }\n\n  if (primitiveDef.indices !== undefined && !geometry.index) {\n    const accessor = parser.getDependency('accessor', primitiveDef.indices).then(function (accessor) {\n      geometry.setIndex(accessor)\n    })\n\n    pending.push(accessor)\n  }\n\n  assignExtrasToUserData(geometry, primitiveDef)\n\n  computeBounds(geometry, primitiveDef, parser)\n\n  return Promise.all(pending).then(function () {\n    return primitiveDef.targets !== undefined ? addMorphTargets(geometry, primitiveDef.targets, parser) : geometry\n  })\n}\n\nexport { GLTFLoader }\n"],"names":["self","res","sourceURI","node","accessor"],"mappings":";;;;;;;;;;;;AAoEA,MAAM,iBAAiB;AACvB,MAAM,uBAAuB;AAC7B,MAAM,eAAe;AACrB,MAAM,iBAAiB;AAEvB,MAAM,mBAAmB,gNAAA,CAAO;IAC9B,YAAY,OAAA,CAAS;QACnB,KAAA,CAAM,OAAO;QAEb,IAAA,CAAK,WAAA,GAAc;QACnB,IAAA,CAAK,UAAA,GAAa;QAClB,IAAA,CAAK,cAAA,GAAiB;QAEtB,IAAA,CAAK,eAAA,GAAkB,CAAE,CAAA;QAEzB,IAAA,CAAK,QAAA,CAAS,SAAU,MAAA,EAAQ;YAC9B,OAAO,IAAI,gCAAgC,MAAM;QACvD,CAAK;QAED,IAAA,CAAK,QAAA,CAAS,SAAU,MAAA,EAAQ;YAC9B,OAAO,IAAI,iCAAiC,MAAM;QACxD,CAAK;QAED,IAAA,CAAK,QAAA,CAAS,SAAU,MAAA,EAAQ;YAC9B,OAAO,IAAI,2BAA2B,MAAM;QAClD,CAAK;QAED,IAAA,CAAK,QAAA,CAAS,SAAU,MAAA,EAAQ;YAC9B,OAAO,IAAI,yBAAyB,MAAM;QAChD,CAAK;QAED,IAAA,CAAK,QAAA,CAAS,SAAU,MAAA,EAAQ;YAC9B,OAAO,IAAI,yBAAyB,MAAM;QAChD,CAAK;QAED,IAAA,CAAK,QAAA,CAAS,SAAU,MAAA,EAAQ;YAC9B,OAAO,IAAI,4BAA4B,MAAM;QACnD,CAAK;QAED,IAAA,CAAK,QAAA,CAAS,SAAU,MAAA,EAAQ;YAC9B,OAAO,IAAI,mCAAmC,MAAM;QAC1D,CAAK;QAED,IAAA,CAAK,QAAA,CAAS,SAAU,MAAA,EAAQ;YAC9B,OAAO,IAAI,6BAA6B,MAAM;QACpD,CAAK;QAED,IAAA,CAAK,QAAA,CAAS,SAAU,MAAA,EAAQ;YAC9B,OAAO,IAAI,0BAA0B,MAAM;QACjD,CAAK;QAED,IAAA,CAAK,QAAA,CAAS,SAAU,MAAA,EAAQ;YAC9B,OAAO,IAAI,uCAAuC,MAAM;QAC9D,CAAK;QAED,IAAA,CAAK,QAAA,CAAS,SAAU,MAAA,EAAQ;YAC9B,OAAO,IAAI,+BAA+B,MAAM;QACtD,CAAK;QAED,IAAA,CAAK,QAAA,CAAS,SAAU,MAAA,EAAQ;YAC9B,OAAO,IAAI,kCAAkC,MAAM;QACzD,CAAK;QAED,IAAA,CAAK,QAAA,CAAS,SAAU,MAAA,EAAQ;YAC9B,OAAO,IAAI,iCAAiC,MAAM;QACxD,CAAK;QAED,IAAA,CAAK,QAAA,CAAS,SAAU,MAAA,EAAQ;YAC9B,OAAO,IAAI,2BAA2B,MAAM;QAClD,CAAK;QAED,IAAA,CAAK,QAAA,CAAS,SAAU,MAAA,EAAQ;YAC9B,OAAO,IAAI,oBAAoB,MAAM;QAC3C,CAAK;QAED,IAAA,CAAK,QAAA,CAAS,SAAU,MAAA,EAAQ;YAC9B,OAAO,IAAI,uBAAuB,MAAM;QAC9C,CAAK;QAED,IAAA,CAAK,QAAA,CAAS,SAAU,MAAA,EAAQ;YAC9B,OAAO,IAAI,sBAAsB,MAAM;QAC7C,CAAK;IACF;IAED,KAAK,GAAA,EAAK,MAAA,EAAQ,UAAA,EAAY,OAAA,EAAS;QACrC,MAAM,QAAQ,IAAA;QAEd,IAAI;QAEJ,IAAI,IAAA,CAAK,YAAA,KAAiB,IAAI;YAC5B,eAAe,IAAA,CAAK,YAAA;QAC1B,OAAA,IAAe,IAAA,CAAK,IAAA,KAAS,IAAI;YAM3B,MAAM,cAAc,qNAAA,CAAY,cAAA,CAAe,GAAG;YAClD,eAAe,qNAAA,CAAY,UAAA,CAAW,aAAa,IAAA,CAAK,IAAI;QAClE,OAAW;YACL,eAAe,qNAAA,CAAY,cAAA,CAAe,GAAG;QAC9C;QAKD,IAAA,CAAK,OAAA,CAAQ,SAAA,CAAU,GAAG;QAE1B,MAAM,WAAW,SAAU,CAAA,EAAG;YAC5B,IAAI,SAAS;gBACX,QAAQ,CAAC;YACjB,OAAa;gBACL,QAAQ,KAAA,CAAM,CAAC;YAChB;YAED,MAAM,OAAA,CAAQ,SAAA,CAAU,GAAG;YAC3B,MAAM,OAAA,CAAQ,OAAA,CAAQ,GAAG;QAC1B;QAED,MAAM,SAAS,IAAI,oNAAA,CAAW,IAAA,CAAK,OAAO;QAE1C,OAAO,OAAA,CAAQ,IAAA,CAAK,IAAI;QACxB,OAAO,eAAA,CAAgB,aAAa;QACpC,OAAO,gBAAA,CAAiB,IAAA,CAAK,aAAa;QAC1C,OAAO,kBAAA,CAAmB,IAAA,CAAK,eAAe;QAE9C,OAAO,IAAA,CACL,KACA,SAAU,IAAA,EAAM;YACd,IAAI;gBACF,MAAM,KAAA,CACJ,MACA,cACA,SAAU,IAAA,EAAM;oBACd,OAAO,IAAI;oBAEX,MAAM,OAAA,CAAQ,OAAA,CAAQ,GAAG;gBAC1B,GACD;YAEH,EAAA,OAAQ,GAAP;gBACA,SAAS,CAAC;YACX;QACF,GACD,YACA;IAEH;IAED,eAAe,WAAA,EAAa;QAC1B,IAAA,CAAK,WAAA,GAAc;QACnB,OAAO,IAAA;IACR;IAED,eAAe;QACb,MAAM,IAAI,MAAM,kGAAkG;IACnH;IAED,cAAc,UAAA,EAAY;QACxB,IAAA,CAAK,UAAA,GAAa;QAClB,OAAO,IAAA;IACR;IAED,kBAAkB,cAAA,EAAgB;QAChC,IAAA,CAAK,cAAA,GAAiB;QACtB,OAAO,IAAA;IACR;IAED,SAAS,QAAA,EAAU;QACjB,IAAI,IAAA,CAAK,eAAA,CAAgB,OAAA,CAAQ,QAAQ,MAAM,CAAA,GAAI;YACjD,IAAA,CAAK,eAAA,CAAgB,IAAA,CAAK,QAAQ;QACnC;QAED,OAAO,IAAA;IACR;IAED,WAAW,QAAA,EAAU;QACnB,IAAI,IAAA,CAAK,eAAA,CAAgB,OAAA,CAAQ,QAAQ,MAAM,CAAA,GAAI;YACjD,IAAA,CAAK,eAAA,CAAgB,MAAA,CAAO,IAAA,CAAK,eAAA,CAAgB,OAAA,CAAQ,QAAQ,GAAG,CAAC;QACtE;QAED,OAAO,IAAA;IACR;IAED,MAAM,IAAA,EAAM,IAAA,EAAM,MAAA,EAAQ,OAAA,EAAS;QACjC,IAAI;QACJ,MAAM,aAAa,CAAE;QACrB,MAAM,UAAU,CAAE;QAElB,IAAI,OAAO,SAAS,UAAU;YAC5B,OAAO,KAAK,KAAA,CAAM,IAAI;QAC5B,OAAA,IAAe,gBAAgB,aAAa;YACtC,MAAM,YAAQ,gQAAA,EAAW,IAAI,WAAW,KAAK,KAAA,CAAM,GAAG,CAAC,CAAC,CAAC;YAEzD,IAAI,UAAU,+BAA+B;gBAC3C,IAAI;oBACF,UAAA,CAAW,WAAW,eAAe,CAAA,GAAI,IAAI,oBAAoB,IAAI;gBACtE,EAAA,OAAQ,OAAP;oBACA,IAAI,SAAS,QAAQ,KAAK;oBAC1B;gBACD;gBAED,OAAO,KAAK,KAAA,CAAM,UAAA,CAAW,WAAW,eAAe,CAAA,CAAE,OAAO;YACxE,OAAa;gBACL,OAAO,KAAK,KAAA,KAAM,gQAAA,EAAW,IAAI,WAAW,IAAI,CAAC,CAAC;YACnD;QACP,OAAW;YACL,OAAO;QACR;QAED,IAAI,KAAK,KAAA,KAAU,KAAA,KAAa,KAAK,KAAA,CAAM,OAAA,CAAQ,CAAC,CAAA,GAAI,GAAG;YACzD,IAAI,SAAS,QAAQ,IAAI,MAAM,yEAAyE,CAAC;YACzG;QACD;QAED,MAAM,SAAS,IAAI,WAAW,MAAM;YAClC,MAAM,QAAQ,IAAA,CAAK,YAAA,IAAgB;YACnC,aAAa,IAAA,CAAK,WAAA;YAClB,eAAe,IAAA,CAAK,aAAA;YACpB,SAAS,IAAA,CAAK,OAAA;YACd,YAAY,IAAA,CAAK,UAAA;YACjB,gBAAgB,IAAA,CAAK,cAAA;QAC3B,CAAK;QAED,OAAO,UAAA,CAAW,gBAAA,CAAiB,IAAA,CAAK,aAAa;QAErD,IAAA,IAAS,IAAI,GAAG,IAAI,IAAA,CAAK,eAAA,CAAgB,MAAA,EAAQ,IAAK;YACpD,MAAM,SAAS,IAAA,CAAK,eAAA,CAAgB,CAAC,CAAA,CAAE,MAAM;YAE7C,IAAI,CAAC,OAAO,IAAA,EAAM,QAAQ,KAAA,CAAM,sDAAsD;YAEtF,OAAA,CAAQ,OAAO,IAAI,CAAA,GAAI;YAMvB,UAAA,CAAW,OAAO,IAAI,CAAA,GAAI;QAC3B;QAED,IAAI,KAAK,cAAA,EAAgB;YACvB,IAAA,IAAS,IAAI,GAAG,IAAI,KAAK,cAAA,CAAe,MAAA,EAAQ,EAAE,EAAG;gBACnD,MAAM,gBAAgB,KAAK,cAAA,CAAe,CAAC,CAAA;gBAC3C,MAAM,qBAAqB,KAAK,kBAAA,IAAsB,CAAE,CAAA;gBAExD,OAAQ,eAAa;oBACnB,KAAK,WAAW,mBAAA;wBACd,UAAA,CAAW,aAAa,CAAA,GAAI,IAAI,4BAA6B;wBAC7D;oBAEF,KAAK,WAAW,0BAAA;wBACd,UAAA,CAAW,aAAa,CAAA,GAAI,IAAI,kCAAkC,MAAM,IAAA,CAAK,WAAW;wBACxF;oBAEF,KAAK,WAAW,qBAAA;wBACd,UAAA,CAAW,aAAa,CAAA,GAAI,IAAI,8BAA+B;wBAC/D;oBAEF,KAAK,WAAW,qBAAA;wBACd,UAAA,CAAW,aAAa,CAAA,GAAI,IAAI,8BAA+B;wBAC/D;oBAEF;wBACE,IAAI,mBAAmB,OAAA,CAAQ,aAAa,KAAK,KAAK,OAAA,CAAQ,aAAa,CAAA,KAAM,KAAA,GAAW;4BAC1F,QAAQ,IAAA,CAAK,0CAA0C,gBAAgB,IAAI;wBAC5E;gBACJ;YACF;QACF;QAED,OAAO,aAAA,CAAc,UAAU;QAC/B,OAAO,UAAA,CAAW,OAAO;QACzB,OAAO,KAAA,CAAM,QAAQ,OAAO;IAC7B;IAED,WAAW,IAAA,EAAM,IAAA,EAAM;QACrB,MAAM,QAAQ,IAAA;QAEd,OAAO,IAAI,QAAQ,SAAU,OAAA,EAAS,MAAA,EAAQ;YAC5C,MAAM,KAAA,CAAM,MAAM,MAAM,SAAS,MAAM;QAC7C,CAAK;IACF;AACH;AAIA,SAAS,eAAe;IACtB,IAAI,UAAU,CAAE;IAEhB,OAAO;QACL,KAAK,SAAU,GAAA,EAAK;YAClB,OAAO,OAAA,CAAQ,GAAG,CAAA;QACnB;QAED,KAAK,SAAU,GAAA,EAAK,MAAA,EAAQ;YAC1B,OAAA,CAAQ,GAAG,CAAA,GAAI;QAChB;QAED,QAAQ,SAAU,GAAA,EAAK;YACrB,OAAO,OAAA,CAAQ,GAAG,CAAA;QACnB;QAED,WAAW,WAAY;YACrB,UAAU,CAAE;QACb;IACF;AACH;AAMA,MAAM,aAAa;IACjB,iBAAiB;IACjB,4BAA4B;IAC5B,qBAAqB;IACrB,yBAAyB;IACzB,0BAA0B;IAC1B,mBAAmB;IACnB,qBAAqB;IACrB,wBAAwB;IACxB,4BAA4B;IAC5B,2BAA2B;IAC3B,0BAA0B;IAC1B,qBAAqB;IACrB,sBAAsB;IACtB,oBAAoB;IACpB,uBAAuB;IACvB,uBAAuB;IACvB,iCAAiC;IACjC,oBAAoB;IACpB,kBAAkB;IAClB,kBAAkB;IAClB,yBAAyB;IACzB,yBAAyB;AAC3B;AAOA,MAAM,oBAAoB;IACxB,YAAY,MAAA,CAAQ;QAClB,IAAA,CAAK,MAAA,GAAS;QACd,IAAA,CAAK,IAAA,GAAO,WAAW,mBAAA;QAGvB,IAAA,CAAK,KAAA,GAAQ;YAAE,MAAM,CAAA;YAAI,MAAM,CAAA;QAAI;IACpC;IAED,YAAY;QACV,MAAM,SAAS,IAAA,CAAK,MAAA;QACpB,MAAM,WAAW,IAAA,CAAK,MAAA,CAAO,IAAA,CAAK,KAAA,IAAS,CAAE,CAAA;QAE7C,IAAA,IAAS,YAAY,GAAG,aAAa,SAAS,MAAA,EAAQ,YAAY,YAAY,YAAa;YACzF,MAAM,UAAU,QAAA,CAAS,SAAS,CAAA;YAElC,IAAI,QAAQ,UAAA,IAAc,QAAQ,UAAA,CAAW,IAAA,CAAK,IAAI,CAAA,IAAK,QAAQ,UAAA,CAAW,IAAA,CAAK,IAAI,CAAA,CAAE,KAAA,KAAU,KAAA,GAAW;gBAC5G,OAAO,WAAA,CAAY,IAAA,CAAK,KAAA,EAAO,QAAQ,UAAA,CAAW,IAAA,CAAK,IAAI,CAAA,CAAE,KAAK;YACnE;QACF;IACF;IAED,WAAW,UAAA,EAAY;QACrB,MAAM,SAAS,IAAA,CAAK,MAAA;QACpB,MAAM,WAAW,WAAW;QAC5B,IAAI,aAAa,OAAO,KAAA,CAAM,GAAA,CAAI,QAAQ;QAE1C,IAAI,YAAY,OAAO;QAEvB,MAAM,OAAO,OAAO,IAAA;QACpB,MAAM,aAAc,KAAK,UAAA,IAAc,KAAK,UAAA,CAAW,IAAA,CAAK,IAAI,CAAA,IAAM,CAAE;QACxE,MAAM,YAAY,WAAW,MAAA,IAAU,CAAE,CAAA;QACzC,MAAM,WAAW,SAAA,CAAU,UAAU,CAAA;QACrC,IAAI;QAEJ,MAAM,QAAQ,IAAI,+MAAA,CAAM,QAAQ;QAEhC,IAAI,SAAS,KAAA,KAAU,KAAA,GACrB,MAAM,MAAA,CAAO,SAAS,KAAA,CAAM,CAAC,CAAA,EAAG,SAAS,KAAA,CAAM,CAAC,CAAA,EAAG,SAAS,KAAA,CAAM,CAAC,CAAA,EAAG,oBAAoB;QAE5F,MAAM,QAAQ,SAAS,KAAA,KAAU,KAAA,IAAY,SAAS,KAAA,GAAQ;QAE9D,OAAQ,SAAS,IAAA,EAAI;YACnB,KAAK;gBACH,YAAY,IAAI,0NAAA,CAAiB,KAAK;gBACtC,UAAU,MAAA,CAAO,QAAA,CAAS,GAAA,CAAI,GAAG,GAAG,CAAA,CAAE;gBACtC,UAAU,GAAA,CAAI,UAAU,MAAM;gBAC9B;YAEF,KAAK;gBACH,YAAY,IAAI,oNAAA,CAAW,KAAK;gBAChC,UAAU,QAAA,GAAW;gBACrB;YAEF,KAAK;gBACH,YAAY,IAAI,mNAAA,CAAU,KAAK;gBAC/B,UAAU,QAAA,GAAW;gBAErB,SAAS,IAAA,GAAO,SAAS,IAAA,IAAQ,CAAE;gBACnC,SAAS,IAAA,CAAK,cAAA,GAAiB,SAAS,IAAA,CAAK,cAAA,KAAmB,KAAA,IAAY,SAAS,IAAA,CAAK,cAAA,GAAiB;gBAC3G,SAAS,IAAA,CAAK,cAAA,GACZ,SAAS,IAAA,CAAK,cAAA,KAAmB,KAAA,IAAY,SAAS,IAAA,CAAK,cAAA,GAAiB,KAAK,EAAA,GAAK;gBACxF,UAAU,KAAA,GAAQ,SAAS,IAAA,CAAK,cAAA;gBAChC,UAAU,QAAA,GAAW,IAAM,SAAS,IAAA,CAAK,cAAA,GAAiB,SAAS,IAAA,CAAK,cAAA;gBACxE,UAAU,MAAA,CAAO,QAAA,CAAS,GAAA,CAAI,GAAG,GAAG,CAAA,CAAE;gBACtC,UAAU,GAAA,CAAI,UAAU,MAAM;gBAC9B;YAEF;gBACE,MAAM,IAAI,MAAM,8CAA8C,SAAS,IAAI;QAC9E;QAID,UAAU,QAAA,CAAS,GAAA,CAAI,GAAG,GAAG,CAAC;QAE9B,UAAU,KAAA,GAAQ;QAElB,uBAAuB,WAAW,QAAQ;QAE1C,IAAI,SAAS,SAAA,KAAc,KAAA,GAAW,UAAU,SAAA,GAAY,SAAS,SAAA;QAErE,UAAU,IAAA,GAAO,OAAO,gBAAA,CAAiB,SAAS,IAAA,IAAQ,WAAW,UAAU;QAE/E,aAAa,QAAQ,OAAA,CAAQ,SAAS;QAEtC,OAAO,KAAA,CAAM,GAAA,CAAI,UAAU,UAAU;QAErC,OAAO;IACR;IAED,cAAc,IAAA,EAAM,KAAA,EAAO;QACzB,IAAI,SAAS,SAAS;QAEtB,OAAO,IAAA,CAAK,UAAA,CAAW,KAAK;IAC7B;IAED,qBAAqB,SAAA,EAAW;QAC9B,MAAMA,QAAO,IAAA;QACb,MAAM,SAAS,IAAA,CAAK,MAAA;QACpB,MAAM,OAAO,OAAO,IAAA;QACpB,MAAM,UAAU,KAAK,KAAA,CAAM,SAAS,CAAA;QACpC,MAAM,WAAY,QAAQ,UAAA,IAAc,QAAQ,UAAA,CAAW,IAAA,CAAK,IAAI,CAAA,IAAM,CAAE;QAC5E,MAAM,aAAa,SAAS,KAAA;QAE5B,IAAI,eAAe,KAAA,GAAW,OAAO;QAErC,OAAO,IAAA,CAAK,UAAA,CAAW,UAAU,EAAE,IAAA,CAAK,SAAU,KAAA,EAAO;YACvD,OAAO,OAAO,WAAA,CAAYA,MAAK,KAAA,EAAO,YAAY,KAAK;QAC7D,CAAK;IACF;AACH;AAOA,MAAM,4BAA4B;IAChC,aAAc;QACZ,IAAA,CAAK,IAAA,GAAO,WAAW,mBAAA;IACxB;IAED,kBAAkB;QAChB,OAAO,2NAAA;IACR;IAED,aAAa,cAAA,EAAgB,WAAA,EAAa,MAAA,EAAQ;QAChD,MAAM,UAAU,CAAE,CAAA;QAElB,eAAe,KAAA,GAAQ,IAAI,+MAAA,CAAM,GAAK,GAAK,CAAG;QAC9C,eAAe,OAAA,GAAU;QAEzB,MAAM,oBAAoB,YAAY,oBAAA;QAEtC,IAAI,mBAAmB;YACrB,IAAI,MAAM,OAAA,CAAQ,kBAAkB,eAAe,GAAG;gBACpD,MAAM,QAAQ,kBAAkB,eAAA;gBAEhC,eAAe,KAAA,CAAM,MAAA,CAAO,KAAA,CAAM,CAAC,CAAA,EAAG,KAAA,CAAM,CAAC,CAAA,EAAG,KAAA,CAAM,CAAC,CAAA,EAAG,oBAAoB;gBAC9E,eAAe,OAAA,GAAU,KAAA,CAAM,CAAC,CAAA;YACjC;YAED,IAAI,kBAAkB,gBAAA,KAAqB,KAAA,GAAW;gBACpD,QAAQ,IAAA,CAAK,OAAO,aAAA,CAAc,gBAAgB,OAAO,kBAAkB,gBAAA,EAAkB,cAAc,CAAC;YAC7G;QACF;QAED,OAAO,QAAQ,GAAA,CAAI,OAAO;IAC3B;AACH;AAOA,MAAM,uCAAuC;IAC3C,YAAY,MAAA,CAAQ;QAClB,IAAA,CAAK,MAAA,GAAS;QACd,IAAA,CAAK,IAAA,GAAO,WAAW,+BAAA;IACxB;IAED,qBAAqB,aAAA,EAAe,cAAA,EAAgB;QAClD,MAAM,SAAS,IAAA,CAAK,MAAA;QACpB,MAAM,cAAc,OAAO,IAAA,CAAK,SAAA,CAAU,aAAa,CAAA;QAEvD,IAAI,CAAC,YAAY,UAAA,IAAc,CAAC,YAAY,UAAA,CAAW,IAAA,CAAK,IAAI,CAAA,EAAG;YACjE,OAAO,QAAQ,OAAA,CAAS;QACzB;QAED,MAAM,mBAAmB,YAAY,UAAA,CAAW,IAAA,CAAK,IAAI,CAAA,CAAE,gBAAA;QAE3D,IAAI,qBAAqB,KAAA,GAAW;YAClC,eAAe,iBAAA,GAAoB;QACpC;QAED,OAAO,QAAQ,OAAA,CAAS;IACzB;AACH;AAOA,MAAM,gCAAgC;IACpC,YAAY,MAAA,CAAQ;QAClB,IAAA,CAAK,MAAA,GAAS;QACd,IAAA,CAAK,IAAA,GAAO,WAAW,uBAAA;IACxB;IAED,gBAAgB,aAAA,EAAe;QAC7B,MAAM,SAAS,IAAA,CAAK,MAAA;QACpB,MAAM,cAAc,OAAO,IAAA,CAAK,SAAA,CAAU,aAAa,CAAA;QAEvD,IAAI,CAAC,YAAY,UAAA,IAAc,CAAC,YAAY,UAAA,CAAW,IAAA,CAAK,IAAI,CAAA,EAAG,OAAO;QAE1E,OAAO,8NAAA;IACR;IAED,qBAAqB,aAAA,EAAe,cAAA,EAAgB;QAClD,MAAM,SAAS,IAAA,CAAK,MAAA;QACpB,MAAM,cAAc,OAAO,IAAA,CAAK,SAAA,CAAU,aAAa,CAAA;QAEvD,IAAI,CAAC,YAAY,UAAA,IAAc,CAAC,YAAY,UAAA,CAAW,IAAA,CAAK,IAAI,CAAA,EAAG;YACjE,OAAO,QAAQ,OAAA,CAAS;QACzB;QAED,MAAM,UAAU,CAAE,CAAA;QAElB,MAAM,YAAY,YAAY,UAAA,CAAW,IAAA,CAAK,IAAI,CAAA;QAElD,IAAI,UAAU,eAAA,KAAoB,KAAA,GAAW;YAC3C,eAAe,SAAA,GAAY,UAAU,eAAA;QACtC;QAED,IAAI,UAAU,gBAAA,KAAqB,KAAA,GAAW;YAC5C,QAAQ,IAAA,CAAK,OAAO,aAAA,CAAc,gBAAgB,gBAAgB,UAAU,gBAAgB,CAAC;QAC9F;QAED,IAAI,UAAU,wBAAA,KAA6B,KAAA,GAAW;YACpD,eAAe,kBAAA,GAAqB,UAAU,wBAAA;QAC/C;QAED,IAAI,UAAU,yBAAA,KAA8B,KAAA,GAAW;YACrD,QAAQ,IAAA,CAAK,OAAO,aAAA,CAAc,gBAAgB,yBAAyB,UAAU,yBAAyB,CAAC;QAChH;QAED,IAAI,UAAU,sBAAA,KAA2B,KAAA,GAAW;YAClD,QAAQ,IAAA,CAAK,OAAO,aAAA,CAAc,gBAAgB,sBAAsB,UAAU,sBAAsB,CAAC;YAEzG,IAAI,UAAU,sBAAA,CAAuB,KAAA,KAAU,KAAA,GAAW;gBACxD,MAAM,QAAQ,UAAU,sBAAA,CAAuB,KAAA;gBAE/C,eAAe,oBAAA,GAAuB,IAAI,iNAAA,CAAQ,OAAO,KAAK;YAC/D;QACF;QAED,OAAO,QAAQ,GAAA,CAAI,OAAO;IAC3B;AACH;AAOA,MAAM,iCAAiC;IACrC,YAAY,MAAA,CAAQ;QAClB,IAAA,CAAK,MAAA,GAAS;QACd,IAAA,CAAK,IAAA,GAAO,WAAW,wBAAA;IACxB;IAED,gBAAgB,aAAA,EAAe;QAC7B,MAAM,SAAS,IAAA,CAAK,MAAA;QACpB,MAAM,cAAc,OAAO,IAAA,CAAK,SAAA,CAAU,aAAa,CAAA;QAEvD,IAAI,CAAC,YAAY,UAAA,IAAc,CAAC,YAAY,UAAA,CAAW,IAAA,CAAK,IAAI,CAAA,EAAG,OAAO;QAE1E,OAAO,8NAAA;IACR;IAED,qBAAqB,aAAA,EAAe,cAAA,EAAgB;QAClD,MAAM,SAAS,IAAA,CAAK,MAAA;QACpB,MAAM,cAAc,OAAO,IAAA,CAAK,SAAA,CAAU,aAAa,CAAA;QAEvD,IAAI,CAAC,YAAY,UAAA,IAAc,CAAC,YAAY,UAAA,CAAW,IAAA,CAAK,IAAI,CAAA,EAAG;YACjE,OAAO,QAAQ,OAAA,CAAS;QACzB;QAED,MAAM,YAAY,YAAY,UAAA,CAAW,IAAA,CAAK,IAAI,CAAA;QAElD,eAAe,UAAA,GAAa,UAAU,UAAA,KAAe,KAAA,IAAY,UAAU,UAAA,GAAa;QAExF,OAAO,QAAQ,OAAA,CAAS;IACzB;AACH;AAOA,MAAM,kCAAkC;IACtC,YAAY,MAAA,CAAQ;QAClB,IAAA,CAAK,MAAA,GAAS;QACd,IAAA,CAAK,IAAA,GAAO,WAAW,yBAAA;IACxB;IAED,gBAAgB,aAAA,EAAe;QAC7B,MAAM,SAAS,IAAA,CAAK,MAAA;QACpB,MAAM,cAAc,OAAO,IAAA,CAAK,SAAA,CAAU,aAAa,CAAA;QAEvD,IAAI,CAAC,YAAY,UAAA,IAAc,CAAC,YAAY,UAAA,CAAW,IAAA,CAAK,IAAI,CAAA,EAAG,OAAO;QAE1E,OAAO,8NAAA;IACR;IAED,qBAAqB,aAAA,EAAe,cAAA,EAAgB;QAClD,MAAM,SAAS,IAAA,CAAK,MAAA;QACpB,MAAM,cAAc,OAAO,IAAA,CAAK,SAAA,CAAU,aAAa,CAAA;QAEvD,IAAI,CAAC,YAAY,UAAA,IAAc,CAAC,YAAY,UAAA,CAAW,IAAA,CAAK,IAAI,CAAA,EAAG;YACjE,OAAO,QAAQ,OAAA,CAAS;QACzB;QAED,MAAM,UAAU,CAAE,CAAA;QAElB,MAAM,YAAY,YAAY,UAAA,CAAW,IAAA,CAAK,IAAI,CAAA;QAElD,IAAI,UAAU,iBAAA,KAAsB,KAAA,GAAW;YAC7C,eAAe,WAAA,GAAc,UAAU,iBAAA;QACxC;QAED,IAAI,UAAU,kBAAA,KAAuB,KAAA,GAAW;YAC9C,QAAQ,IAAA,CAAK,OAAO,aAAA,CAAc,gBAAgB,kBAAkB,UAAU,kBAAkB,CAAC;QAClG;QAED,IAAI,UAAU,cAAA,KAAmB,KAAA,GAAW;YAC1C,eAAe,cAAA,GAAiB,UAAU,cAAA;QAC3C;QAED,IAAI,eAAe,yBAAA,KAA8B,KAAA,GAAW;YAC1D,eAAe,yBAAA,GAA4B;gBAAC;gBAAK,GAAG;aAAA;QACrD;QAED,IAAI,UAAU,2BAAA,KAAgC,KAAA,GAAW;YACvD,eAAe,yBAAA,CAA0B,CAAC,CAAA,GAAI,UAAU,2BAAA;QACzD;QAED,IAAI,UAAU,2BAAA,KAAgC,KAAA,GAAW;YACvD,eAAe,yBAAA,CAA0B,CAAC,CAAA,GAAI,UAAU,2BAAA;QACzD;QAED,IAAI,UAAU,2BAAA,KAAgC,KAAA,GAAW;YACvD,QAAQ,IAAA,CACN,OAAO,aAAA,CAAc,gBAAgB,2BAA2B,UAAU,2BAA2B;QAExG;QAED,OAAO,QAAQ,GAAA,CAAI,OAAO;IAC3B;AACH;AAOA,MAAM,4BAA4B;IAChC,YAAY,MAAA,CAAQ;QAClB,IAAA,CAAK,MAAA,GAAS;QACd,IAAA,CAAK,IAAA,GAAO,WAAW,mBAAA;IACxB;IAED,gBAAgB,aAAA,EAAe;QAC7B,MAAM,SAAS,IAAA,CAAK,MAAA;QACpB,MAAM,cAAc,OAAO,IAAA,CAAK,SAAA,CAAU,aAAa,CAAA;QAEvD,IAAI,CAAC,YAAY,UAAA,IAAc,CAAC,YAAY,UAAA,CAAW,IAAA,CAAK,IAAI,CAAA,EAAG,OAAO;QAE1E,OAAO,8NAAA;IACR;IAED,qBAAqB,aAAA,EAAe,cAAA,EAAgB;QAClD,MAAM,SAAS,IAAA,CAAK,MAAA;QACpB,MAAM,cAAc,OAAO,IAAA,CAAK,SAAA,CAAU,aAAa,CAAA;QAEvD,IAAI,CAAC,YAAY,UAAA,IAAc,CAAC,YAAY,UAAA,CAAW,IAAA,CAAK,IAAI,CAAA,EAAG;YACjE,OAAO,QAAQ,OAAA,CAAS;QACzB;QAED,MAAM,UAAU,CAAE,CAAA;QAElB,eAAe,UAAA,GAAa,IAAI,+MAAA,CAAM,GAAG,GAAG,CAAC;QAC7C,eAAe,cAAA,GAAiB;QAChC,eAAe,KAAA,GAAQ;QAEvB,MAAM,YAAY,YAAY,UAAA,CAAW,IAAA,CAAK,IAAI,CAAA;QAElD,IAAI,UAAU,gBAAA,KAAqB,KAAA,GAAW;YAC5C,MAAM,cAAc,UAAU,gBAAA;YAC9B,eAAe,UAAA,CAAW,MAAA,CAAO,WAAA,CAAY,CAAC,CAAA,EAAG,WAAA,CAAY,CAAC,CAAA,EAAG,WAAA,CAAY,CAAC,CAAA,EAAG,oBAAoB;QACtG;QAED,IAAI,UAAU,oBAAA,KAAyB,KAAA,GAAW;YAChD,eAAe,cAAA,GAAiB,UAAU,oBAAA;QAC3C;QAED,IAAI,UAAU,iBAAA,KAAsB,KAAA,GAAW;YAC7C,QAAQ,IAAA,CAAK,OAAO,aAAA,CAAc,gBAAgB,iBAAiB,UAAU,iBAAA,EAAmB,cAAc,CAAC;QAChH;QAED,IAAI,UAAU,qBAAA,KAA0B,KAAA,GAAW;YACjD,QAAQ,IAAA,CAAK,OAAO,aAAA,CAAc,gBAAgB,qBAAqB,UAAU,qBAAqB,CAAC;QACxG;QAED,OAAO,QAAQ,GAAA,CAAI,OAAO;IAC3B;AACH;AAQA,MAAM,mCAAmC;IACvC,YAAY,MAAA,CAAQ;QAClB,IAAA,CAAK,MAAA,GAAS;QACd,IAAA,CAAK,IAAA,GAAO,WAAW,0BAAA;IACxB;IAED,gBAAgB,aAAA,EAAe;QAC7B,MAAM,SAAS,IAAA,CAAK,MAAA;QACpB,MAAM,cAAc,OAAO,IAAA,CAAK,SAAA,CAAU,aAAa,CAAA;QAEvD,IAAI,CAAC,YAAY,UAAA,IAAc,CAAC,YAAY,UAAA,CAAW,IAAA,CAAK,IAAI,CAAA,EAAG,OAAO;QAE1E,OAAO,8NAAA;IACR;IAED,qBAAqB,aAAA,EAAe,cAAA,EAAgB;QAClD,MAAM,SAAS,IAAA,CAAK,MAAA;QACpB,MAAM,cAAc,OAAO,IAAA,CAAK,SAAA,CAAU,aAAa,CAAA;QAEvD,IAAI,CAAC,YAAY,UAAA,IAAc,CAAC,YAAY,UAAA,CAAW,IAAA,CAAK,IAAI,CAAA,EAAG;YACjE,OAAO,QAAQ,OAAA,CAAS;QACzB;QAED,MAAM,UAAU,CAAE,CAAA;QAElB,MAAM,YAAY,YAAY,UAAA,CAAW,IAAA,CAAK,IAAI,CAAA;QAElD,IAAI,UAAU,kBAAA,KAAuB,KAAA,GAAW;YAC9C,eAAe,YAAA,GAAe,UAAU,kBAAA;QACzC;QAED,IAAI,UAAU,mBAAA,KAAwB,KAAA,GAAW;YAC/C,QAAQ,IAAA,CAAK,OAAO,aAAA,CAAc,gBAAgB,mBAAmB,UAAU,mBAAmB,CAAC;QACpG;QAED,OAAO,QAAQ,GAAA,CAAI,OAAO;IAC3B;AACH;AAOA,MAAM,6BAA6B;IACjC,YAAY,MAAA,CAAQ;QAClB,IAAA,CAAK,MAAA,GAAS;QACd,IAAA,CAAK,IAAA,GAAO,WAAW,oBAAA;IACxB;IAED,gBAAgB,aAAA,EAAe;QAC7B,MAAM,SAAS,IAAA,CAAK,MAAA;QACpB,MAAM,cAAc,OAAO,IAAA,CAAK,SAAA,CAAU,aAAa,CAAA;QAEvD,IAAI,CAAC,YAAY,UAAA,IAAc,CAAC,YAAY,UAAA,CAAW,IAAA,CAAK,IAAI,CAAA,EAAG,OAAO;QAE1E,OAAO,8NAAA;IACR;IAED,qBAAqB,aAAA,EAAe,cAAA,EAAgB;QAClD,MAAM,SAAS,IAAA,CAAK,MAAA;QACpB,MAAM,cAAc,OAAO,IAAA,CAAK,SAAA,CAAU,aAAa,CAAA;QAEvD,IAAI,CAAC,YAAY,UAAA,IAAc,CAAC,YAAY,UAAA,CAAW,IAAA,CAAK,IAAI,CAAA,EAAG;YACjE,OAAO,QAAQ,OAAA,CAAS;QACzB;QAED,MAAM,UAAU,CAAE,CAAA;QAElB,MAAM,YAAY,YAAY,UAAA,CAAW,IAAA,CAAK,IAAI,CAAA;QAElD,eAAe,SAAA,GAAY,UAAU,eAAA,KAAoB,KAAA,IAAY,UAAU,eAAA,GAAkB;QAEjG,IAAI,UAAU,gBAAA,KAAqB,KAAA,GAAW;YAC5C,QAAQ,IAAA,CAAK,OAAO,aAAA,CAAc,gBAAgB,gBAAgB,UAAU,gBAAgB,CAAC;QAC9F;QAED,eAAe,mBAAA,GAAsB,UAAU,mBAAA,IAAuB;QAEtE,MAAM,aAAa,UAAU,gBAAA,IAAoB;YAAC;YAAG;YAAG,CAAC;SAAA;QACzD,eAAe,gBAAA,GAAmB,IAAI,+MAAA,CAAK,EAAG,MAAA,CAC5C,UAAA,CAAW,CAAC,CAAA,EACZ,UAAA,CAAW,CAAC,CAAA,EACZ,UAAA,CAAW,CAAC,CAAA,EACZ;QAGF,OAAO,QAAQ,GAAA,CAAI,OAAO;IAC3B;AACH;AAOA,MAAM,0BAA0B;IAC9B,YAAY,MAAA,CAAQ;QAClB,IAAA,CAAK,MAAA,GAAS;QACd,IAAA,CAAK,IAAA,GAAO,WAAW,iBAAA;IACxB;IAED,gBAAgB,aAAA,EAAe;QAC7B,MAAM,SAAS,IAAA,CAAK,MAAA;QACpB,MAAM,cAAc,OAAO,IAAA,CAAK,SAAA,CAAU,aAAa,CAAA;QAEvD,IAAI,CAAC,YAAY,UAAA,IAAc,CAAC,YAAY,UAAA,CAAW,IAAA,CAAK,IAAI,CAAA,EAAG,OAAO;QAE1E,OAAO,8NAAA;IACR;IAED,qBAAqB,aAAA,EAAe,cAAA,EAAgB;QAClD,MAAM,SAAS,IAAA,CAAK,MAAA;QACpB,MAAM,cAAc,OAAO,IAAA,CAAK,SAAA,CAAU,aAAa,CAAA;QAEvD,IAAI,CAAC,YAAY,UAAA,IAAc,CAAC,YAAY,UAAA,CAAW,IAAA,CAAK,IAAI,CAAA,EAAG;YACjE,OAAO,QAAQ,OAAA,CAAS;QACzB;QAED,MAAM,YAAY,YAAY,UAAA,CAAW,IAAA,CAAK,IAAI,CAAA;QAElD,eAAe,GAAA,GAAM,UAAU,GAAA,KAAQ,KAAA,IAAY,UAAU,GAAA,GAAM;QAEnE,OAAO,QAAQ,OAAA,CAAS;IACzB;AACH;AAOA,MAAM,+BAA+B;IACnC,YAAY,MAAA,CAAQ;QAClB,IAAA,CAAK,MAAA,GAAS;QACd,IAAA,CAAK,IAAA,GAAO,WAAW,sBAAA;IACxB;IAED,gBAAgB,aAAA,EAAe;QAC7B,MAAM,SAAS,IAAA,CAAK,MAAA;QACpB,MAAM,cAAc,OAAO,IAAA,CAAK,SAAA,CAAU,aAAa,CAAA;QAEvD,IAAI,CAAC,YAAY,UAAA,IAAc,CAAC,YAAY,UAAA,CAAW,IAAA,CAAK,IAAI,CAAA,EAAG,OAAO;QAE1E,OAAO,8NAAA;IACR;IAED,qBAAqB,aAAA,EAAe,cAAA,EAAgB;QAClD,MAAM,SAAS,IAAA,CAAK,MAAA;QACpB,MAAM,cAAc,OAAO,IAAA,CAAK,SAAA,CAAU,aAAa,CAAA;QAEvD,IAAI,CAAC,YAAY,UAAA,IAAc,CAAC,YAAY,UAAA,CAAW,IAAA,CAAK,IAAI,CAAA,EAAG;YACjE,OAAO,QAAQ,OAAA,CAAS;QACzB;QAED,MAAM,UAAU,CAAE,CAAA;QAElB,MAAM,YAAY,YAAY,UAAA,CAAW,IAAA,CAAK,IAAI,CAAA;QAElD,eAAe,iBAAA,GAAoB,UAAU,cAAA,KAAmB,KAAA,IAAY,UAAU,cAAA,GAAiB;QAEvG,IAAI,UAAU,eAAA,KAAoB,KAAA,GAAW;YAC3C,QAAQ,IAAA,CAAK,OAAO,aAAA,CAAc,gBAAgB,wBAAwB,UAAU,eAAe,CAAC;QACrG;QAED,MAAM,aAAa,UAAU,mBAAA,IAAuB;YAAC;YAAG;YAAG,CAAC;SAAA;QAC5D,eAAe,aAAA,GAAgB,IAAI,+MAAA,CAAK,EAAG,MAAA,CAAO,UAAA,CAAW,CAAC,CAAA,EAAG,UAAA,CAAW,CAAC,CAAA,EAAG,UAAA,CAAW,CAAC,CAAA,EAAG,oBAAoB;QAEnH,IAAI,UAAU,oBAAA,KAAyB,KAAA,GAAW;YAChD,QAAQ,IAAA,CACN,OAAO,aAAA,CAAc,gBAAgB,oBAAoB,UAAU,oBAAA,EAAsB,cAAc;QAE1G;QAED,OAAO,QAAQ,GAAA,CAAI,OAAO;IAC3B;AACH;AAOA,MAAM,2BAA2B;IAC/B,YAAY,MAAA,CAAQ;QAClB,IAAA,CAAK,MAAA,GAAS;QACd,IAAA,CAAK,IAAA,GAAO,WAAW,kBAAA;IACxB;IAED,gBAAgB,aAAA,EAAe;QAC7B,MAAM,SAAS,IAAA,CAAK,MAAA;QACpB,MAAM,cAAc,OAAO,IAAA,CAAK,SAAA,CAAU,aAAa,CAAA;QAEvD,IAAI,CAAC,YAAY,UAAA,IAAc,CAAC,YAAY,UAAA,CAAW,IAAA,CAAK,IAAI,CAAA,EAAG,OAAO;QAE1E,OAAO,8NAAA;IACR;IAED,qBAAqB,aAAA,EAAe,cAAA,EAAgB;QAClD,MAAM,SAAS,IAAA,CAAK,MAAA;QACpB,MAAM,cAAc,OAAO,IAAA,CAAK,SAAA,CAAU,aAAa,CAAA;QAEvD,IAAI,CAAC,YAAY,UAAA,IAAc,CAAC,YAAY,UAAA,CAAW,IAAA,CAAK,IAAI,CAAA,EAAG;YACjE,OAAO,QAAQ,OAAA,CAAS;QACzB;QAED,MAAM,UAAU,CAAE,CAAA;QAElB,MAAM,YAAY,YAAY,UAAA,CAAW,IAAA,CAAK,IAAI,CAAA;QAElD,eAAe,SAAA,GAAY,UAAU,UAAA,KAAe,KAAA,IAAY,UAAU,UAAA,GAAa;QAEvF,IAAI,UAAU,WAAA,KAAgB,KAAA,GAAW;YACvC,QAAQ,IAAA,CAAK,OAAO,aAAA,CAAc,gBAAgB,WAAW,UAAU,WAAW,CAAC;QACpF;QAED,OAAO,QAAQ,GAAA,CAAI,OAAO;IAC3B;AACH;AAOA,MAAM,iCAAiC;IACrC,YAAY,MAAA,CAAQ;QAClB,IAAA,CAAK,MAAA,GAAS;QACd,IAAA,CAAK,IAAA,GAAO,WAAW,wBAAA;IACxB;IAED,gBAAgB,aAAA,EAAe;QAC7B,MAAM,SAAS,IAAA,CAAK,MAAA;QACpB,MAAM,cAAc,OAAO,IAAA,CAAK,SAAA,CAAU,aAAa,CAAA;QAEvD,IAAI,CAAC,YAAY,UAAA,IAAc,CAAC,YAAY,UAAA,CAAW,IAAA,CAAK,IAAI,CAAA,EAAG,OAAO;QAE1E,OAAO,8NAAA;IACR;IAED,qBAAqB,aAAA,EAAe,cAAA,EAAgB;QAClD,MAAM,SAAS,IAAA,CAAK,MAAA;QACpB,MAAM,cAAc,OAAO,IAAA,CAAK,SAAA,CAAU,aAAa,CAAA;QAEvD,IAAI,CAAC,YAAY,UAAA,IAAc,CAAC,YAAY,UAAA,CAAW,IAAA,CAAK,IAAI,CAAA,EAAG;YACjE,OAAO,QAAQ,OAAA,CAAS;QACzB;QAED,MAAM,UAAU,CAAE,CAAA;QAElB,MAAM,YAAY,YAAY,UAAA,CAAW,IAAA,CAAK,IAAI,CAAA;QAElD,IAAI,UAAU,kBAAA,KAAuB,KAAA,GAAW;YAC9C,eAAe,UAAA,GAAa,UAAU,kBAAA;QACvC;QAED,IAAI,UAAU,kBAAA,KAAuB,KAAA,GAAW;YAC9C,eAAe,kBAAA,GAAqB,UAAU,kBAAA;QAC/C;QAED,IAAI,UAAU,iBAAA,KAAsB,KAAA,GAAW;YAC7C,QAAQ,IAAA,CAAK,OAAO,aAAA,CAAc,gBAAgB,iBAAiB,UAAU,iBAAiB,CAAC;QAChG;QAED,OAAO,QAAQ,GAAA,CAAI,OAAO;IAC3B;AACH;AAOA,MAAM,2BAA2B;IAC/B,YAAY,MAAA,CAAQ;QAClB,IAAA,CAAK,MAAA,GAAS;QACd,IAAA,CAAK,IAAA,GAAO,WAAW,kBAAA;IACxB;IAED,YAAY,YAAA,EAAc;QACxB,MAAM,SAAS,IAAA,CAAK,MAAA;QACpB,MAAM,OAAO,OAAO,IAAA;QAEpB,MAAM,aAAa,KAAK,QAAA,CAAS,YAAY,CAAA;QAE7C,IAAI,CAAC,WAAW,UAAA,IAAc,CAAC,WAAW,UAAA,CAAW,IAAA,CAAK,IAAI,CAAA,EAAG;YAC/D,OAAO;QACR;QAED,MAAM,YAAY,WAAW,UAAA,CAAW,IAAA,CAAK,IAAI,CAAA;QACjD,MAAM,SAAS,OAAO,OAAA,CAAQ,UAAA;QAE9B,IAAI,CAAC,QAAQ;YACX,IAAI,KAAK,kBAAA,IAAsB,KAAK,kBAAA,CAAmB,OAAA,CAAQ,IAAA,CAAK,IAAI,KAAK,GAAG;gBAC9E,MAAM,IAAI,MAAM,6EAA6E;YACrG,OAAa;gBAEL,OAAO;YACR;QACF;QAED,OAAO,OAAO,gBAAA,CAAiB,cAAc,UAAU,MAAA,EAAQ,MAAM;IACtE;AACH;AAOA,MAAM,yBAAyB;IAC7B,YAAY,MAAA,CAAQ;QAClB,IAAA,CAAK,MAAA,GAAS;QACd,IAAA,CAAK,IAAA,GAAO,WAAW,gBAAA;QACvB,IAAA,CAAK,WAAA,GAAc;IACpB;IAED,YAAY,YAAA,EAAc;QACxB,MAAM,OAAO,IAAA,CAAK,IAAA;QAClB,MAAM,SAAS,IAAA,CAAK,MAAA;QACpB,MAAM,OAAO,OAAO,IAAA;QAEpB,MAAM,aAAa,KAAK,QAAA,CAAS,YAAY,CAAA;QAE7C,IAAI,CAAC,WAAW,UAAA,IAAc,CAAC,WAAW,UAAA,CAAW,IAAI,CAAA,EAAG;YAC1D,OAAO;QACR;QAED,MAAM,YAAY,WAAW,UAAA,CAAW,IAAI,CAAA;QAC5C,MAAM,SAAS,KAAK,MAAA,CAAO,UAAU,MAAM,CAAA;QAE3C,IAAI,SAAS,OAAO,aAAA;QACpB,IAAI,OAAO,GAAA,EAAK;YACd,MAAM,UAAU,OAAO,OAAA,CAAQ,OAAA,CAAQ,UAAA,CAAW,OAAO,GAAG;YAC5D,IAAI,YAAY,MAAM,SAAS;QAChC;QAED,OAAO,IAAA,CAAK,aAAA,CAAa,EAAG,IAAA,CAAK,SAAU,WAAA,EAAa;YACtD,IAAI,aAAa,OAAO,OAAO,gBAAA,CAAiB,cAAc,UAAU,MAAA,EAAQ,MAAM;YAEtF,IAAI,KAAK,kBAAA,IAAsB,KAAK,kBAAA,CAAmB,OAAA,CAAQ,IAAI,KAAK,GAAG;gBACzE,MAAM,IAAI,MAAM,2DAA2D;YAC5E;YAGD,OAAO,OAAO,WAAA,CAAY,YAAY;QAC5C,CAAK;IACF;IAED,gBAAgB;QACd,IAAI,CAAC,IAAA,CAAK,WAAA,EAAa;YACrB,IAAA,CAAK,WAAA,GAAc,IAAI,QAAQ,SAAU,OAAA,EAAS;gBAChD,MAAM,QAAQ,IAAI,MAAO;gBAIzB,MAAM,GAAA,GAAM;gBAEZ,MAAM,MAAA,GAAS,MAAM,OAAA,GAAU,WAAY;oBACzC,QAAQ,MAAM,MAAA,KAAW,CAAC;gBAC3B;YACT,CAAO;QACF;QAED,OAAO,IAAA,CAAK,WAAA;IACb;AACH;AAOA,MAAM,yBAAyB;IAC7B,YAAY,MAAA,CAAQ;QAClB,IAAA,CAAK,MAAA,GAAS;QACd,IAAA,CAAK,IAAA,GAAO,WAAW,gBAAA;QACvB,IAAA,CAAK,WAAA,GAAc;IACpB;IAED,YAAY,YAAA,EAAc;QACxB,MAAM,OAAO,IAAA,CAAK,IAAA;QAClB,MAAM,SAAS,IAAA,CAAK,MAAA;QACpB,MAAM,OAAO,OAAO,IAAA;QAEpB,MAAM,aAAa,KAAK,QAAA,CAAS,YAAY,CAAA;QAE7C,IAAI,CAAC,WAAW,UAAA,IAAc,CAAC,WAAW,UAAA,CAAW,IAAI,CAAA,EAAG;YAC1D,OAAO;QACR;QAED,MAAM,YAAY,WAAW,UAAA,CAAW,IAAI,CAAA;QAC5C,MAAM,SAAS,KAAK,MAAA,CAAO,UAAU,MAAM,CAAA;QAE3C,IAAI,SAAS,OAAO,aAAA;QACpB,IAAI,OAAO,GAAA,EAAK;YACd,MAAM,UAAU,OAAO,OAAA,CAAQ,OAAA,CAAQ,UAAA,CAAW,OAAO,GAAG;YAC5D,IAAI,YAAY,MAAM,SAAS;QAChC;QAED,OAAO,IAAA,CAAK,aAAA,CAAa,EAAG,IAAA,CAAK,SAAU,WAAA,EAAa;YACtD,IAAI,aAAa,OAAO,OAAO,gBAAA,CAAiB,cAAc,UAAU,MAAA,EAAQ,MAAM;YAEtF,IAAI,KAAK,kBAAA,IAAsB,KAAK,kBAAA,CAAmB,OAAA,CAAQ,IAAI,KAAK,GAAG;gBACzE,MAAM,IAAI,MAAM,2DAA2D;YAC5E;YAGD,OAAO,OAAO,WAAA,CAAY,YAAY;QAC5C,CAAK;IACF;IAED,gBAAgB;QACd,IAAI,CAAC,IAAA,CAAK,WAAA,EAAa;YACrB,IAAA,CAAK,WAAA,GAAc,IAAI,QAAQ,SAAU,OAAA,EAAS;gBAChD,MAAM,QAAQ,IAAI,MAAO;gBAGzB,MAAM,GAAA,GACJ;gBACF,MAAM,MAAA,GAAS,MAAM,OAAA,GAAU,WAAY;oBACzC,QAAQ,MAAM,MAAA,KAAW,CAAC;gBAC3B;YACT,CAAO;QACF;QAED,OAAO,IAAA,CAAK,WAAA;IACb;AACH;AAOA,MAAM,uBAAuB;IAC3B,YAAY,MAAA,CAAQ;QAClB,IAAA,CAAK,IAAA,GAAO,WAAW,uBAAA;QACvB,IAAA,CAAK,MAAA,GAAS;IACf;IAED,eAAe,KAAA,EAAO;QACpB,MAAM,OAAO,IAAA,CAAK,MAAA,CAAO,IAAA;QACzB,MAAM,aAAa,KAAK,WAAA,CAAY,KAAK,CAAA;QAEzC,IAAI,WAAW,UAAA,IAAc,WAAW,UAAA,CAAW,IAAA,CAAK,IAAI,CAAA,EAAG;YAC7D,MAAM,eAAe,WAAW,UAAA,CAAW,IAAA,CAAK,IAAI,CAAA;YAEpD,MAAM,SAAS,IAAA,CAAK,MAAA,CAAO,aAAA,CAAc,UAAU,aAAa,MAAM;YACtE,MAAM,UAAU,IAAA,CAAK,MAAA,CAAO,OAAA,CAAQ,cAAA;YAEpC,IAAI,CAAC,WAAW,CAAC,QAAQ,SAAA,EAAW;gBAClC,IAAI,KAAK,kBAAA,IAAsB,KAAK,kBAAA,CAAmB,OAAA,CAAQ,IAAA,CAAK,IAAI,KAAK,GAAG;oBAC9E,MAAM,IAAI,MAAM,oFAAoF;gBAC9G,OAAe;oBAEL,OAAO;gBACR;YACF;YAED,OAAO,OAAO,IAAA,CAAK,SAAU,GAAA,EAAK;gBAChC,MAAM,aAAa,aAAa,UAAA,IAAc;gBAC9C,MAAM,aAAa,aAAa,UAAA,IAAc;gBAE9C,MAAM,QAAQ,aAAa,KAAA;gBAC3B,MAAM,SAAS,aAAa,UAAA;gBAE5B,MAAM,SAAS,IAAI,WAAW,KAAK,YAAY,UAAU;gBAEzD,IAAI,QAAQ,qBAAA,EAAuB;oBACjC,OAAO,QACJ,qBAAA,CAAsB,OAAO,QAAQ,QAAQ,aAAa,IAAA,EAAM,aAAa,MAAM,EACnF,IAAA,CAAK,SAAUC,IAAAA,EAAK;wBACnB,OAAOA,KAAI,MAAA;oBACzB,CAAa;gBACb,OAAe;oBAEL,OAAO,QAAQ,KAAA,CAAM,IAAA,CAAK,WAAY;wBACpC,MAAM,SAAS,IAAI,YAAY,QAAQ,MAAM;wBAC7C,QAAQ,gBAAA,CACN,IAAI,WAAW,MAAM,GACrB,OACA,QACA,QACA,aAAa,IAAA,EACb,aAAa,MAAA;wBAEf,OAAO;oBACnB,CAAW;gBACF;YACT,CAAO;QACP,OAAW;YACL,OAAO;QACR;IACF;AACH;AAQA,MAAM,sBAAsB;IAC1B,YAAY,MAAA,CAAQ;QAClB,IAAA,CAAK,IAAA,GAAO,WAAW,uBAAA;QACvB,IAAA,CAAK,MAAA,GAAS;IACf;IAED,eAAe,SAAA,EAAW;QACxB,MAAM,OAAO,IAAA,CAAK,MAAA,CAAO,IAAA;QACzB,MAAM,UAAU,KAAK,KAAA,CAAM,SAAS,CAAA;QAEpC,IAAI,CAAC,QAAQ,UAAA,IAAc,CAAC,QAAQ,UAAA,CAAW,IAAA,CAAK,IAAI,CAAA,IAAK,QAAQ,IAAA,KAAS,KAAA,GAAW;YACvF,OAAO;QACR;QAED,MAAM,UAAU,KAAK,MAAA,CAAO,QAAQ,IAAI,CAAA;QAIxC,KAAA,MAAW,aAAa,QAAQ,UAAA,CAAY;YAC1C,IACE,UAAU,IAAA,KAAS,gBAAgB,SAAA,IACnC,UAAU,IAAA,KAAS,gBAAgB,cAAA,IACnC,UAAU,IAAA,KAAS,gBAAgB,YAAA,IACnC,UAAU,IAAA,KAAS,KAAA,GACnB;gBACA,OAAO;YACR;QACF;QAED,MAAM,eAAe,QAAQ,UAAA,CAAW,IAAA,CAAK,IAAI,CAAA;QACjD,MAAM,gBAAgB,aAAa,UAAA;QAInC,MAAM,UAAU,CAAE,CAAA;QAClB,MAAM,aAAa,CAAE;QAErB,IAAA,MAAW,OAAO,cAAe;YAC/B,QAAQ,IAAA,CACN,IAAA,CAAK,MAAA,CAAO,aAAA,CAAc,YAAY,aAAA,CAAc,GAAG,CAAC,EAAE,IAAA,CAAK,CAAC,aAAa;gBAC3E,UAAA,CAAW,GAAG,CAAA,GAAI;gBAClB,OAAO,UAAA,CAAW,GAAG,CAAA;YAC/B,CAAS;QAEJ;QAED,IAAI,QAAQ,MAAA,GAAS,GAAG;YACtB,OAAO;QACR;QAED,QAAQ,IAAA,CAAK,IAAA,CAAK,MAAA,CAAO,cAAA,CAAe,SAAS,CAAC;QAElD,OAAO,QAAQ,GAAA,CAAI,OAAO,EAAE,IAAA,CAAK,CAAC,YAAY;YAC5C,MAAM,aAAa,QAAQ,GAAA,CAAK;YAChC,MAAM,SAAS,WAAW,OAAA,GAAU,WAAW,QAAA,GAAW;gBAAC,UAAU;aAAA;YACrE,MAAM,QAAQ,OAAA,CAAQ,CAAC,CAAA,CAAE,KAAA;YACzB,MAAM,kBAAkB,CAAE,CAAA;YAE1B,KAAA,MAAW,QAAQ,OAAQ;gBAEzB,MAAM,IAAI,IAAI,iNAAA,CAAS;gBACvB,MAAM,IAAI,IAAI,iNAAA,CAAS;gBACvB,MAAM,IAAI,IAAI,oNAAA,CAAY;gBAC1B,MAAM,IAAI,IAAI,iNAAA,CAAQ,GAAG,GAAG,CAAC;gBAE7B,MAAM,gBAAgB,IAAI,uNAAA,CAAc,KAAK,QAAA,EAAU,KAAK,QAAA,EAAU,KAAK;gBAE3E,IAAA,IAAS,IAAI,GAAG,IAAI,OAAO,IAAK;oBAC9B,IAAI,WAAW,WAAA,EAAa;wBAC1B,EAAE,mBAAA,CAAoB,WAAW,WAAA,EAAa,CAAC;oBAChD;oBAED,IAAI,WAAW,QAAA,EAAU;wBACvB,EAAE,mBAAA,CAAoB,WAAW,QAAA,EAAU,CAAC;oBAC7C;oBAED,IAAI,WAAW,KAAA,EAAO;wBACpB,EAAE,mBAAA,CAAoB,WAAW,KAAA,EAAO,CAAC;oBAC1C;oBAED,cAAc,WAAA,CAAY,GAAG,EAAE,OAAA,CAAQ,GAAG,GAAG,CAAC,CAAC;gBAChD;gBAGD,IAAA,MAAW,iBAAiB,WAAY;oBACtC,IAAI,kBAAkB,YAAY;wBAChC,MAAM,OAAO,UAAA,CAAW,aAAa,CAAA;wBACrC,cAAc,aAAA,GAAgB,IAAI,kOAAA,CAAyB,KAAK,KAAA,EAAO,KAAK,QAAA,EAAU,KAAK,UAAU;oBACjH,OAAA,IAAqB,kBAAkB,iBAAiB,kBAAkB,cAAc,kBAAkB,SAAS;wBACvG,KAAK,QAAA,CAAS,YAAA,CAAa,eAAe,UAAA,CAAW,aAAa,CAAC;oBACpE;gBACF;gBAGD,kNAAA,CAAS,SAAA,CAAU,IAAA,CAAK,IAAA,CAAK,eAAe,IAAI;gBAEhD,IAAA,CAAK,MAAA,CAAO,mBAAA,CAAoB,aAAa;gBAE7C,gBAAgB,IAAA,CAAK,aAAa;YACnC;YAED,IAAI,WAAW,OAAA,EAAS;gBACtB,WAAW,KAAA,CAAO;gBAElB,WAAW,GAAA,CAAI,GAAG,eAAe;gBAEjC,OAAO;YACR;YAED,OAAO,eAAA,CAAgB,CAAC,CAAA;QAC9B,CAAK;IACF;AACH;AAGA,MAAM,gCAAgC;AACtC,MAAM,iCAAiC;AACvC,MAAM,+BAA+B;IAAE,MAAM;IAAY,KAAK;AAAY;AAE1E,MAAM,oBAAoB;IACxB,YAAY,IAAA,CAAM;QAChB,IAAA,CAAK,IAAA,GAAO,WAAW,eAAA;QACvB,IAAA,CAAK,OAAA,GAAU;QACf,IAAA,CAAK,IAAA,GAAO;QAEZ,MAAM,aAAa,IAAI,SAAS,MAAM,GAAG,8BAA8B;QAEvE,IAAA,CAAK,MAAA,GAAS;YACZ,WAAO,gQAAA,EAAW,IAAI,WAAW,KAAK,KAAA,CAAM,GAAG,CAAC,CAAC,CAAC;YAClD,SAAS,WAAW,SAAA,CAAU,GAAG,IAAI;YACrC,QAAQ,WAAW,SAAA,CAAU,GAAG,IAAI;QACrC;QAED,IAAI,IAAA,CAAK,MAAA,CAAO,KAAA,KAAU,+BAA+B;YACvD,MAAM,IAAI,MAAM,mDAAmD;QACpE,OAAA,IAAU,IAAA,CAAK,MAAA,CAAO,OAAA,GAAU,GAAK;YACpC,MAAM,IAAI,MAAM,gDAAgD;QACjE;QAED,MAAM,sBAAsB,IAAA,CAAK,MAAA,CAAO,MAAA,GAAS;QACjD,MAAM,YAAY,IAAI,SAAS,MAAM,8BAA8B;QACnE,IAAI,aAAa;QAEjB,MAAO,aAAa,oBAAqB;YACvC,MAAM,cAAc,UAAU,SAAA,CAAU,YAAY,IAAI;YACxD,cAAc;YAEd,MAAM,YAAY,UAAU,SAAA,CAAU,YAAY,IAAI;YACtD,cAAc;YAEd,IAAI,cAAc,6BAA6B,IAAA,EAAM;gBACnD,MAAM,eAAe,IAAI,WAAW,MAAM,iCAAiC,YAAY,WAAW;gBAClG,IAAA,CAAK,OAAA,OAAU,gQAAA,EAAW,YAAY;YAC9C,OAAA,IAAiB,cAAc,6BAA6B,GAAA,EAAK;gBACzD,MAAM,aAAa,iCAAiC;gBACpD,IAAA,CAAK,IAAA,GAAO,KAAK,KAAA,CAAM,YAAY,aAAa,WAAW;YAC5D;YAID,cAAc;QACf;QAED,IAAI,IAAA,CAAK,OAAA,KAAY,MAAM;YACzB,MAAM,IAAI,MAAM,2CAA2C;QAC5D;IACF;AACH;AAOA,MAAM,kCAAkC;IACtC,YAAY,IAAA,EAAM,WAAA,CAAa;QAC7B,IAAI,CAAC,aAAa;YAChB,MAAM,IAAI,MAAM,qDAAqD;QACtE;QAED,IAAA,CAAK,IAAA,GAAO,WAAW,0BAAA;QACvB,IAAA,CAAK,IAAA,GAAO;QACZ,IAAA,CAAK,WAAA,GAAc;QACnB,IAAA,CAAK,WAAA,CAAY,OAAA,CAAS;IAC3B;IAED,gBAAgB,SAAA,EAAW,MAAA,EAAQ;QACjC,MAAM,OAAO,IAAA,CAAK,IAAA;QAClB,MAAM,cAAc,IAAA,CAAK,WAAA;QACzB,MAAM,kBAAkB,UAAU,UAAA,CAAW,IAAA,CAAK,IAAI,CAAA,CAAE,UAAA;QACxD,MAAM,mBAAmB,UAAU,UAAA,CAAW,IAAA,CAAK,IAAI,CAAA,CAAE,UAAA;QACzD,MAAM,oBAAoB,CAAE;QAC5B,MAAM,yBAAyB,CAAE;QACjC,MAAM,mBAAmB,CAAE;QAE3B,IAAA,MAAW,iBAAiB,iBAAkB;YAC5C,MAAM,qBAAqB,UAAA,CAAW,aAAa,CAAA,IAAK,cAAc,WAAA,CAAa;YAEnF,iBAAA,CAAkB,kBAAkB,CAAA,GAAI,gBAAA,CAAiB,aAAa,CAAA;QACvE;QAED,IAAA,MAAW,iBAAiB,UAAU,UAAA,CAAY;YAChD,MAAM,qBAAqB,UAAA,CAAW,aAAa,CAAA,IAAK,cAAc,WAAA,CAAa;YAEnF,IAAI,gBAAA,CAAiB,aAAa,CAAA,KAAM,KAAA,GAAW;gBACjD,MAAM,cAAc,KAAK,SAAA,CAAU,UAAU,UAAA,CAAW,aAAa,CAAC,CAAA;gBACtE,MAAM,gBAAgB,qBAAA,CAAsB,YAAY,aAAa,CAAA;gBAErE,gBAAA,CAAiB,kBAAkB,CAAA,GAAI,cAAc,IAAA;gBACrD,sBAAA,CAAuB,kBAAkB,CAAA,GAAI,YAAY,UAAA,KAAe;YACzE;QACF;QAED,OAAO,OAAO,aAAA,CAAc,cAAc,eAAe,EAAE,IAAA,CAAK,SAAU,UAAA,EAAY;YACpF,OAAO,IAAI,QAAQ,SAAU,OAAA,EAAS,MAAA,EAAQ;gBAC5C,YAAY,eAAA,CACV,YACA,SAAU,QAAA,EAAU;oBAClB,IAAA,MAAW,iBAAiB,SAAS,UAAA,CAAY;wBAC/C,MAAM,YAAY,SAAS,UAAA,CAAW,aAAa,CAAA;wBACnD,MAAM,aAAa,sBAAA,CAAuB,aAAa,CAAA;wBAEvD,IAAI,eAAe,KAAA,GAAW,UAAU,UAAA,GAAa;oBACtD;oBAED,QAAQ,QAAQ;gBACjB,GACD,mBACA,kBACA,sBACA;YAEV,CAAO;QACP,CAAK;IACF;AACH;AAOA,MAAM,8BAA8B;IAClC,aAAc;QACZ,IAAA,CAAK,IAAA,GAAO,WAAW,qBAAA;IACxB;IAED,cAAc,OAAA,EAAS,SAAA,EAAW;QAChC,IAAA,CACG,UAAU,QAAA,KAAa,KAAA,KAAa,UAAU,QAAA,KAAa,QAAQ,OAAA,KACpE,UAAU,MAAA,KAAW,KAAA,KACrB,UAAU,QAAA,KAAa,KAAA,KACvB,UAAU,KAAA,KAAU,KAAA,GACpB;YAEA,OAAO;QACR;QAED,UAAU,QAAQ,KAAA,CAAO;QAEzB,IAAI,UAAU,QAAA,KAAa,KAAA,GAAW;YACpC,QAAQ,OAAA,GAAU,UAAU,QAAA;QAC7B;QAED,IAAI,UAAU,MAAA,KAAW,KAAA,GAAW;YAClC,QAAQ,MAAA,CAAO,SAAA,CAAU,UAAU,MAAM;QAC1C;QAED,IAAI,UAAU,QAAA,KAAa,KAAA,GAAW;YACpC,QAAQ,QAAA,GAAW,UAAU,QAAA;QAC9B;QAED,IAAI,UAAU,KAAA,KAAU,KAAA,GAAW;YACjC,QAAQ,MAAA,CAAO,SAAA,CAAU,UAAU,KAAK;QACzC;QAED,QAAQ,WAAA,GAAc;QAEtB,OAAO;IACR;AACH;AAOA,MAAM,8BAA8B;IAClC,aAAc;QACZ,IAAA,CAAK,IAAA,GAAO,WAAW,qBAAA;IACxB;AACH;AAQA,MAAM,mCAAmC,qNAAA,CAAY;IACnD,YAAY,kBAAA,EAAoB,YAAA,EAAc,UAAA,EAAY,YAAA,CAAc;QACtE,KAAA,CAAM,oBAAoB,cAAc,YAAY,YAAY;IACjE;IAED,iBAAiB,KAAA,EAAO;QAItB,MAAM,SAAS,IAAA,CAAK,YAAA,EAClB,SAAS,IAAA,CAAK,YAAA,EACd,YAAY,IAAA,CAAK,SAAA,EACjB,SAAS,QAAQ,YAAY,IAAI;QAEnC,IAAA,IAAS,IAAI,GAAG,MAAM,WAAW,IAAK;YACpC,MAAA,CAAO,CAAC,CAAA,GAAI,MAAA,CAAO,SAAS,CAAC,CAAA;QAC9B;QAED,OAAO;IACR;IAED,aAAa,EAAA,EAAI,EAAA,EAAI,CAAA,EAAG,EAAA,EAAI;QAC1B,MAAM,SAAS,IAAA,CAAK,YAAA;QACpB,MAAM,SAAS,IAAA,CAAK,YAAA;QACpB,MAAM,SAAS,IAAA,CAAK,SAAA;QAEpB,MAAM,UAAU,SAAS;QACzB,MAAM,UAAU,SAAS;QAEzB,MAAM,KAAK,KAAK;QAEhB,MAAM,IAAA,CAAK,IAAI,EAAA,IAAM;QACrB,MAAM,KAAK,IAAI;QACf,MAAM,MAAM,KAAK;QAEjB,MAAM,UAAU,KAAK;QACrB,MAAM,UAAU,UAAU;QAE1B,MAAM,KAAK,CAAA,IAAK,MAAM,IAAI;QAC1B,MAAM,KAAK,MAAM;QACjB,MAAM,KAAK,IAAI;QACf,MAAM,KAAK,KAAK,KAAK;QAIrB,IAAA,IAAS,IAAI,GAAG,MAAM,QAAQ,IAAK;YACjC,MAAM,KAAK,MAAA,CAAO,UAAU,IAAI,MAAM,CAAA;YACtC,MAAM,KAAK,MAAA,CAAO,UAAU,IAAI,OAAO,CAAA,GAAI;YAC3C,MAAM,KAAK,MAAA,CAAO,UAAU,IAAI,MAAM,CAAA;YACtC,MAAM,KAAK,MAAA,CAAO,UAAU,CAAC,CAAA,GAAI;YAEjC,MAAA,CAAO,CAAC,CAAA,GAAI,KAAK,KAAK,KAAK,KAAK,KAAK,KAAK,KAAK;QAChD;QAED,OAAO;IACR;AACH;AAEA,MAAM,KAAqB,aAAA,GAAA,IAAI,oNAAA,CAAY;AAE3C,MAAM,6CAA6C,2BAA2B;IAC5E,aAAa,EAAA,EAAI,EAAA,EAAI,CAAA,EAAG,EAAA,EAAI;QAC1B,MAAM,SAAS,KAAA,CAAM,aAAa,IAAI,IAAI,GAAG,EAAE;QAE/C,GAAG,SAAA,CAAU,MAAM,EAAE,SAAA,CAAW,EAAC,OAAA,CAAQ,MAAM;QAE/C,OAAO;IACR;AACH;AAQA,MAAM,kBAAkB;IACtB,OAAO;IAAA,oBAAA;IAEP,YAAY;IACZ,YAAY;IACZ,YAAY;IACZ,YAAY;IACZ,YAAY;IACZ,QAAQ;IACR,QAAQ;IACR,YAAY;IACZ,QAAQ;IACR,OAAO;IACP,WAAW;IACX,YAAY;IACZ,WAAW;IACX,gBAAgB;IAChB,cAAc;IACd,eAAe;IACf,gBAAgB;AAClB;AAEA,MAAM,wBAAwB;IAC5B,MAAM;IACN,MAAM;IACN,MAAM;IACN,MAAM;IACN,MAAM;IACN,MAAM;AACR;AAEA,MAAM,gBAAgB;IACpB,MAAM,uNAAA;IACN,MAAM,sNAAA;IACN,MAAM,oOAAA;IACN,MAAM,mOAAA;IACN,MAAM,mOAAA;IACN,MAAM,kOAAA;AACR;AAEA,MAAM,kBAAkB;IACtB,OAAO,6NAAA;IACP,OAAO,gOAAA;IACP,OAAO,wNAAA;AACT;AAEA,MAAM,mBAAmB;IACvB,QAAQ;IACR,MAAM;IACN,MAAM;IACN,MAAM;IACN,MAAM;IACN,MAAM;IACN,MAAM;AACR;AAEA,MAAM,aAAa;IACjB,UAAU;IACV,QAAQ;IACR,SAAS;IAAA,2BAAA;IAAA,gDAAA;IAAA,gDAAA;IAIT,GAAI,2PAAA,IAAW,MACX;QACE,YAAY;QACZ,YAAY;QACZ,YAAY;QACZ,YAAY;IACb,IACD;QACE,YAAY;QACZ,YAAY;IACpB,CAAA;IAEE,SAAS;IACT,WAAW;IACX,UAAU;AACZ;AAEA,MAAM,kBAAkB;IACtB,OAAO;IACP,aAAa;IACb,UAAU;IACV,SAAS;AACX;AAEA,MAAM,gBAAgB;IACpB,aAAa,KAAA;IAAA,0FAAA;IAAA,uFAAA;IAEb,QAAQ,2NAAA;IACR,MAAM,6NAAA;AACR;AAEA,MAAM,cAAc;IAClB,QAAQ;IACR,MAAM;IACN,OAAO;AACT;AAKA,SAAS,sBAAsB,KAAA,EAAO;IACpC,IAAI,KAAA,CAAM,iBAAiB,CAAA,KAAM,KAAA,GAAW;QAC1C,KAAA,CAAM,iBAAiB,CAAA,GAAI,IAAI,8NAAA,CAAqB;YAClD,OAAO;YACP,UAAU;YACV,WAAW;YACX,WAAW;YACX,aAAa;YACb,WAAW;YACX,MAAM,mNAAA;QACZ,CAAK;IACF;IAED,OAAO,KAAA,CAAM,iBAAiB,CAAA;AAChC;AAEA,SAAS,+BAA+B,eAAA,EAAiB,MAAA,EAAQ,SAAA,EAAW;IAG1E,IAAA,MAAW,QAAQ,UAAU,UAAA,CAAY;QACvC,IAAI,eAAA,CAAgB,IAAI,CAAA,KAAM,KAAA,GAAW;YACvC,OAAO,QAAA,CAAS,cAAA,GAAiB,OAAO,QAAA,CAAS,cAAA,IAAkB,CAAE;YACrE,OAAO,QAAA,CAAS,cAAA,CAAe,IAAI,CAAA,GAAI,UAAU,UAAA,CAAW,IAAI,CAAA;QACjE;IACF;AACH;AAMA,SAAS,uBAAuB,MAAA,EAAQ,OAAA,EAAS;IAC/C,IAAI,QAAQ,MAAA,KAAW,KAAA,GAAW;QAChC,IAAI,OAAO,QAAQ,MAAA,KAAW,UAAU;YACtC,OAAO,MAAA,CAAO,OAAO,QAAA,EAAU,QAAQ,MAAM;QACnD,OAAW;YACL,QAAQ,IAAA,CAAK,wDAAwD,QAAQ,MAAM;QACpF;IACF;AACH;AAUA,SAAS,gBAAgB,QAAA,EAAU,OAAA,EAAS,MAAA,EAAQ;IAClD,IAAI,mBAAmB;IACvB,IAAI,iBAAiB;IACrB,IAAI,gBAAgB;IAEpB,IAAA,IAAS,IAAI,GAAG,KAAK,QAAQ,MAAA,EAAQ,IAAI,IAAI,IAAK;QAChD,MAAM,SAAS,OAAA,CAAQ,CAAC,CAAA;QAExB,IAAI,OAAO,QAAA,KAAa,KAAA,GAAW,mBAAmB;QACtD,IAAI,OAAO,MAAA,KAAW,KAAA,GAAW,iBAAiB;QAClD,IAAI,OAAO,OAAA,KAAY,KAAA,GAAW,gBAAgB;QAElD,IAAI,oBAAoB,kBAAkB,eAAe;IAC1D;IAED,IAAI,CAAC,oBAAoB,CAAC,kBAAkB,CAAC,eAAe,OAAO,QAAQ,OAAA,CAAQ,QAAQ;IAE3F,MAAM,2BAA2B,CAAE,CAAA;IACnC,MAAM,yBAAyB,CAAE,CAAA;IACjC,MAAM,wBAAwB,CAAE,CAAA;IAEhC,IAAA,IAAS,IAAI,GAAG,KAAK,QAAQ,MAAA,EAAQ,IAAI,IAAI,IAAK;QAChD,MAAM,SAAS,OAAA,CAAQ,CAAC,CAAA;QAExB,IAAI,kBAAkB;YACpB,MAAM,kBACJ,OAAO,QAAA,KAAa,KAAA,IAAY,OAAO,aAAA,CAAc,YAAY,OAAO,QAAQ,IAAI,SAAS,UAAA,CAAW,QAAA;YAE1G,yBAAyB,IAAA,CAAK,eAAe;QAC9C;QAED,IAAI,gBAAgB;YAClB,MAAM,kBACJ,OAAO,MAAA,KAAW,KAAA,IAAY,OAAO,aAAA,CAAc,YAAY,OAAO,MAAM,IAAI,SAAS,UAAA,CAAW,MAAA;YAEtG,uBAAuB,IAAA,CAAK,eAAe;QAC5C;QAED,IAAI,eAAe;YACjB,MAAM,kBACJ,OAAO,OAAA,KAAY,KAAA,IAAY,OAAO,aAAA,CAAc,YAAY,OAAO,OAAO,IAAI,SAAS,UAAA,CAAW,KAAA;YAExG,sBAAsB,IAAA,CAAK,eAAe;QAC3C;IACF;IAED,OAAO,QAAQ,GAAA,CAAI;QACjB,QAAQ,GAAA,CAAI,wBAAwB;QACpC,QAAQ,GAAA,CAAI,sBAAsB;QAClC,QAAQ,GAAA,CAAI,qBAAqB;KAClC,EAAE,IAAA,CAAK,SAAU,SAAA,EAAW;QAC3B,MAAM,iBAAiB,SAAA,CAAU,CAAC,CAAA;QAClC,MAAM,eAAe,SAAA,CAAU,CAAC,CAAA;QAChC,MAAM,cAAc,SAAA,CAAU,CAAC,CAAA;QAE/B,IAAI,kBAAkB,SAAS,eAAA,CAAgB,QAAA,GAAW;QAC1D,IAAI,gBAAgB,SAAS,eAAA,CAAgB,MAAA,GAAS;QACtD,IAAI,eAAe,SAAS,eAAA,CAAgB,KAAA,GAAQ;QACpD,SAAS,oBAAA,GAAuB;QAEhC,OAAO;IACX,CAAG;AACH;AAMA,SAAS,mBAAmB,IAAA,EAAM,OAAA,EAAS;IACzC,KAAK,kBAAA,CAAoB;IAEzB,IAAI,QAAQ,OAAA,KAAY,KAAA,GAAW;QACjC,IAAA,IAAS,IAAI,GAAG,KAAK,QAAQ,OAAA,CAAQ,MAAA,EAAQ,IAAI,IAAI,IAAK;YACxD,KAAK,qBAAA,CAAsB,CAAC,CAAA,GAAI,QAAQ,OAAA,CAAQ,CAAC,CAAA;QAClD;IACF;IAGD,IAAI,QAAQ,MAAA,IAAU,MAAM,OAAA,CAAQ,QAAQ,MAAA,CAAO,WAAW,GAAG;QAC/D,MAAM,cAAc,QAAQ,MAAA,CAAO,WAAA;QAEnC,IAAI,KAAK,qBAAA,CAAsB,MAAA,KAAW,YAAY,MAAA,EAAQ;YAC5D,KAAK,qBAAA,GAAwB,CAAE;YAE/B,IAAA,IAAS,IAAI,GAAG,KAAK,YAAY,MAAA,EAAQ,IAAI,IAAI,IAAK;gBACpD,KAAK,qBAAA,CAAsB,WAAA,CAAY,CAAC,CAAC,CAAA,GAAI;YAC9C;QACP,OAAW;YACL,QAAQ,IAAA,CAAK,sEAAsE;QACpF;IACF;AACH;AAEA,SAAS,mBAAmB,YAAA,EAAc;IACxC,IAAI;IAEJ,MAAM,iBAAiB,aAAa,UAAA,IAAc,aAAa,UAAA,CAAW,WAAW,0BAA0B,CAAA;IAE/G,IAAI,gBAAgB;QAClB,cACE,WACA,eAAe,UAAA,GACf,MACA,eAAe,OAAA,GACf,MACA,oBAAoB,eAAe,UAAU;IACnD,OAAS;QACL,cAAc,aAAa,OAAA,GAAU,MAAM,oBAAoB,aAAa,UAAU,IAAI,MAAM,aAAa,IAAA;IAC9G;IAED,IAAI,aAAa,OAAA,KAAY,KAAA,GAAW;QACtC,IAAA,IAAS,IAAI,GAAG,KAAK,aAAa,OAAA,CAAQ,MAAA,EAAQ,IAAI,IAAI,IAAK;YAC7D,eAAe,MAAM,oBAAoB,aAAa,OAAA,CAAQ,CAAC,CAAC;QACjE;IACF;IAED,OAAO;AACT;AAEA,SAAS,oBAAoB,UAAA,EAAY;IACvC,IAAI,gBAAgB;IAEpB,MAAM,OAAO,OAAO,IAAA,CAAK,UAAU,EAAE,IAAA,CAAM;IAE3C,IAAA,IAAS,IAAI,GAAG,KAAK,KAAK,MAAA,EAAQ,IAAI,IAAI,IAAK;QAC7C,iBAAiB,IAAA,CAAK,CAAC,CAAA,GAAI,MAAM,UAAA,CAAW,IAAA,CAAK,CAAC,CAAC,CAAA,GAAI;IACxD;IAED,OAAO;AACT;AAEA,SAAS,4BAA4B,WAAA,EAAa;IAIhD,OAAQ,aAAW;QACjB,KAAK;YACH,OAAO,IAAI;QAEb,KAAK;YACH,OAAO,IAAI;QAEb,KAAK;YACH,OAAO,IAAI;QAEb,KAAK;YACH,OAAO,IAAI;QAEb;YACE,MAAM,IAAI,MAAM,mEAAmE;IACtF;AACH;AAEA,SAAS,oBAAoB,GAAA,EAAK;IAChC,IAAI,IAAI,MAAA,CAAO,gBAAgB,IAAI,KAAK,IAAI,MAAA,CAAO,oBAAoB,MAAM,GAAG,OAAO;IACvF,IAAI,IAAI,MAAA,CAAO,eAAe,IAAI,KAAK,IAAI,MAAA,CAAO,oBAAoB,MAAM,GAAG,OAAO;IAEtF,OAAO;AACT;AAEA,MAAM,kBAAkC,aAAA,GAAA,IAAI,iNAAA,CAAS;AAIrD,MAAM,WAAW;IACf,YAAY,OAAO,CAAA,CAAA,EAAI,UAAU,CAAA,CAAA,CAAI;QACnC,IAAA,CAAK,IAAA,GAAO;QACZ,IAAA,CAAK,UAAA,GAAa,CAAE;QACpB,IAAA,CAAK,OAAA,GAAU,CAAE;QACjB,IAAA,CAAK,OAAA,GAAU;QAGf,IAAA,CAAK,KAAA,GAAQ,IAAI,aAAc;QAG/B,IAAA,CAAK,YAAA,GAAe,aAAA,GAAA,IAAI,IAAK;QAG7B,IAAA,CAAK,cAAA,GAAiB,CAAE;QAGxB,IAAA,CAAK,SAAA,GAAY,CAAE;QAGnB,IAAA,CAAK,SAAA,GAAY;YAAE,MAAM,CAAA;YAAI,MAAM,CAAA;QAAI;QACvC,IAAA,CAAK,WAAA,GAAc;YAAE,MAAM,CAAA;YAAI,MAAM,CAAA;QAAI;QACzC,IAAA,CAAK,UAAA,GAAa;YAAE,MAAM,CAAA;YAAI,MAAM,CAAA;QAAI;QAExC,IAAA,CAAK,WAAA,GAAc,CAAE;QACrB,IAAA,CAAK,YAAA,GAAe,CAAE;QAGtB,IAAA,CAAK,aAAA,GAAgB,CAAE;QAKvB,IAAI,WAAW;QACf,IAAI,YAAY;QAChB,IAAI,iBAAiB,CAAA;QAErB,IAAI,OAAO,cAAc,eAAe,OAAO,UAAU,SAAA,KAAc,aAAa;YAClF,WAAW,iCAAiC,IAAA,CAAK,UAAU,SAAS,MAAM;YAC1E,YAAY,UAAU,SAAA,CAAU,OAAA,CAAQ,SAAS,IAAI,CAAA;YACrD,iBAAiB,YAAY,UAAU,SAAA,CAAU,KAAA,CAAM,qBAAqB,CAAA,CAAE,CAAC,CAAA,GAAI,CAAA;QACpF;QAED,IAAI,OAAO,sBAAsB,eAAe,YAAa,aAAa,iBAAiB,IAAK;YAC9F,IAAA,CAAK,aAAA,GAAgB,IAAI,uNAAA,CAAc,IAAA,CAAK,OAAA,CAAQ,OAAO;QACjE,OAAW;YACL,IAAA,CAAK,aAAA,GAAgB,IAAI,2NAAA,CAAkB,IAAA,CAAK,OAAA,CAAQ,OAAO;QAChE;QAED,IAAA,CAAK,aAAA,CAAc,cAAA,CAAe,IAAA,CAAK,OAAA,CAAQ,WAAW;QAC1D,IAAA,CAAK,aAAA,CAAc,gBAAA,CAAiB,IAAA,CAAK,OAAA,CAAQ,aAAa;QAE9D,IAAA,CAAK,UAAA,GAAa,IAAI,oNAAA,CAAW,IAAA,CAAK,OAAA,CAAQ,OAAO;QACrD,IAAA,CAAK,UAAA,CAAW,eAAA,CAAgB,aAAa;QAE7C,IAAI,IAAA,CAAK,OAAA,CAAQ,WAAA,KAAgB,mBAAmB;YAClD,IAAA,CAAK,UAAA,CAAW,kBAAA,CAAmB,IAAI;QACxC;IACF;IAED,cAAc,UAAA,EAAY;QACxB,IAAA,CAAK,UAAA,GAAa;IACnB;IAED,WAAW,OAAA,EAAS;QAClB,IAAA,CAAK,OAAA,GAAU;IAChB;IAED,MAAM,MAAA,EAAQ,OAAA,EAAS;QACrB,MAAM,SAAS,IAAA;QACf,MAAM,OAAO,IAAA,CAAK,IAAA;QAClB,MAAM,aAAa,IAAA,CAAK,UAAA;QAGxB,IAAA,CAAK,KAAA,CAAM,SAAA,CAAW;QACtB,IAAA,CAAK,SAAA,GAAY,CAAE;QAGnB,IAAA,CAAK,UAAA,CAAW,SAAU,GAAA,EAAK;YAC7B,OAAO,IAAI,SAAA,IAAa,IAAI,SAAA,CAAW;QAC7C,CAAK;QAED,QAAQ,GAAA,CACN,IAAA,CAAK,UAAA,CAAW,SAAU,GAAA,EAAK;YAC7B,OAAO,IAAI,UAAA,IAAc,IAAI,UAAA,CAAY;QACjD,CAAO,GAEA,IAAA,CAAK,WAAY;YAChB,OAAO,QAAQ,GAAA,CAAI;gBACjB,OAAO,eAAA,CAAgB,OAAO;gBAC9B,OAAO,eAAA,CAAgB,WAAW;gBAClC,OAAO,eAAA,CAAgB,QAAQ;aAChC;QACT,CAAO,EACA,IAAA,CAAK,SAAU,YAAA,EAAc;YAC5B,MAAM,SAAS;gBACb,OAAO,YAAA,CAAa,CAAC,CAAA,CAAE,KAAK,KAAA,IAAS,CAAC,CAAA;gBACtC,QAAQ,YAAA,CAAa,CAAC,CAAA;gBACtB,YAAY,YAAA,CAAa,CAAC,CAAA;gBAC1B,SAAS,YAAA,CAAa,CAAC,CAAA;gBACvB,OAAO,KAAK,KAAA;gBACZ;gBACA,UAAU,CAAE;YACb;YAED,+BAA+B,YAAY,QAAQ,IAAI;YAEvD,uBAAuB,QAAQ,IAAI;YAEnC,OAAO,QAAQ,GAAA,CACb,OAAO,UAAA,CAAW,SAAU,GAAA,EAAK;gBAC/B,OAAO,IAAI,SAAA,IAAa,IAAI,SAAA,CAAU,MAAM;YACxD,CAAW,GACD,IAAA,CAAK,WAAY;gBACjB,KAAA,MAAW,SAAS,OAAO,MAAA,CAAQ;oBACjC,MAAM,iBAAA,CAAmB;gBAC1B;gBAED,OAAO,MAAM;YACvB,CAAS;QACT,CAAO,EACA,KAAA,CAAM,OAAO;IACjB;IAAA;;GAAA,GAKD,YAAY;QACV,MAAM,WAAW,IAAA,CAAK,IAAA,CAAK,KAAA,IAAS,CAAE,CAAA;QACtC,MAAM,WAAW,IAAA,CAAK,IAAA,CAAK,KAAA,IAAS,CAAE,CAAA;QACtC,MAAM,WAAW,IAAA,CAAK,IAAA,CAAK,MAAA,IAAU,CAAE,CAAA;QAIvC,IAAA,IAAS,YAAY,GAAG,aAAa,SAAS,MAAA,EAAQ,YAAY,YAAY,YAAa;YACzF,MAAM,SAAS,QAAA,CAAS,SAAS,CAAA,CAAE,MAAA;YAEnC,IAAA,IAAS,IAAI,GAAG,KAAK,OAAO,MAAA,EAAQ,IAAI,IAAI,IAAK;gBAC/C,QAAA,CAAS,MAAA,CAAO,CAAC,CAAC,CAAA,CAAE,MAAA,GAAS;YAC9B;QACF;QAID,IAAA,IAAS,YAAY,GAAG,aAAa,SAAS,MAAA,EAAQ,YAAY,YAAY,YAAa;YACzF,MAAM,UAAU,QAAA,CAAS,SAAS,CAAA;YAElC,IAAI,QAAQ,IAAA,KAAS,KAAA,GAAW;gBAC9B,IAAA,CAAK,WAAA,CAAY,IAAA,CAAK,SAAA,EAAW,QAAQ,IAAI;gBAK7C,IAAI,QAAQ,IAAA,KAAS,KAAA,GAAW;oBAC9B,QAAA,CAAS,QAAQ,IAAI,CAAA,CAAE,aAAA,GAAgB;gBACxC;YACF;YAED,IAAI,QAAQ,MAAA,KAAW,KAAA,GAAW;gBAChC,IAAA,CAAK,WAAA,CAAY,IAAA,CAAK,WAAA,EAAa,QAAQ,MAAM;YAClD;QACF;IACF;IAAA;;;;;;;;GAAA,GAWD,YAAY,KAAA,EAAO,KAAA,EAAO;QACxB,IAAI,UAAU,KAAA,GAAW;QAEzB,IAAI,MAAM,IAAA,CAAK,KAAK,CAAA,KAAM,KAAA,GAAW;YACnC,MAAM,IAAA,CAAK,KAAK,CAAA,GAAI,MAAM,IAAA,CAAK,KAAK,CAAA,GAAI;QACzC;QAED,MAAM,IAAA,CAAK,KAAK,CAAA;IACjB;IAAA,uEAAA,GAGD,YAAY,KAAA,EAAO,KAAA,EAAO,MAAA,EAAQ;QAChC,IAAI,MAAM,IAAA,CAAK,KAAK,CAAA,IAAK,GAAG,OAAO;QAEnC,MAAM,MAAM,OAAO,KAAA,CAAO;QAI1B,MAAM,iBAAiB,CAAC,UAAU,UAAU;YAC1C,MAAM,WAAW,IAAA,CAAK,YAAA,CAAa,GAAA,CAAI,QAAQ;YAC/C,IAAI,YAAY,MAAM;gBACpB,IAAA,CAAK,YAAA,CAAa,GAAA,CAAI,OAAO,QAAQ;YACtC;YAED,KAAA,MAAW,CAAC,GAAG,KAAK,CAAA,IAAK,SAAS,QAAA,CAAS,OAAA,GAAW;gBACpD,eAAe,OAAO,MAAM,QAAA,CAAS,CAAC,CAAC;YACxC;QACF;QAED,eAAe,QAAQ,GAAG;QAE1B,IAAI,IAAA,IAAQ,eAAe,MAAM,IAAA,CAAK,KAAK,CAAA;QAE3C,OAAO;IACR;IAED,WAAW,IAAA,EAAM;QACf,MAAM,aAAa,OAAO,MAAA,CAAO,IAAA,CAAK,OAAO;QAC7C,WAAW,IAAA,CAAK,IAAI;QAEpB,IAAA,IAAS,IAAI,GAAG,IAAI,WAAW,MAAA,EAAQ,IAAK;YAC1C,MAAM,SAAS,KAAK,UAAA,CAAW,CAAC,CAAC;YAEjC,IAAI,QAAQ,OAAO;QACpB;QAED,OAAO;IACR;IAED,WAAW,IAAA,EAAM;QACf,MAAM,aAAa,OAAO,MAAA,CAAO,IAAA,CAAK,OAAO;QAC7C,WAAW,OAAA,CAAQ,IAAI;QAEvB,MAAM,UAAU,CAAE,CAAA;QAElB,IAAA,IAAS,IAAI,GAAG,IAAI,WAAW,MAAA,EAAQ,IAAK;YAC1C,MAAM,SAAS,KAAK,UAAA,CAAW,CAAC,CAAC;YAEjC,IAAI,QAAQ,QAAQ,IAAA,CAAK,MAAM;QAChC;QAED,OAAO;IACR;IAAA;;;;;GAAA,GAQD,cAAc,IAAA,EAAM,KAAA,EAAO;QACzB,MAAM,WAAW,OAAO,MAAM;QAC9B,IAAI,aAAa,IAAA,CAAK,KAAA,CAAM,GAAA,CAAI,QAAQ;QAExC,IAAI,CAAC,YAAY;YACf,OAAQ,MAAI;gBACV,KAAK;oBACH,aAAa,IAAA,CAAK,SAAA,CAAU,KAAK;oBACjC;gBAEF,KAAK;oBACH,aAAa,IAAA,CAAK,UAAA,CAAW,SAAU,GAAA,EAAK;wBAC1C,OAAO,IAAI,QAAA,IAAY,IAAI,QAAA,CAAS,KAAK;oBACrD,CAAW;oBACD;gBAEF,KAAK;oBACH,aAAa,IAAA,CAAK,UAAA,CAAW,SAAU,GAAA,EAAK;wBAC1C,OAAO,IAAI,QAAA,IAAY,IAAI,QAAA,CAAS,KAAK;oBACrD,CAAW;oBACD;gBAEF,KAAK;oBACH,aAAa,IAAA,CAAK,YAAA,CAAa,KAAK;oBACpC;gBAEF,KAAK;oBACH,aAAa,IAAA,CAAK,UAAA,CAAW,SAAU,GAAA,EAAK;wBAC1C,OAAO,IAAI,cAAA,IAAkB,IAAI,cAAA,CAAe,KAAK;oBACjE,CAAW;oBACD;gBAEF,KAAK;oBACH,aAAa,IAAA,CAAK,UAAA,CAAW,KAAK;oBAClC;gBAEF,KAAK;oBACH,aAAa,IAAA,CAAK,UAAA,CAAW,SAAU,GAAA,EAAK;wBAC1C,OAAO,IAAI,YAAA,IAAgB,IAAI,YAAA,CAAa,KAAK;oBAC7D,CAAW;oBACD;gBAEF,KAAK;oBACH,aAAa,IAAA,CAAK,UAAA,CAAW,SAAU,GAAA,EAAK;wBAC1C,OAAO,IAAI,WAAA,IAAe,IAAI,WAAA,CAAY,KAAK;oBAC3D,CAAW;oBACD;gBAEF,KAAK;oBACH,aAAa,IAAA,CAAK,QAAA,CAAS,KAAK;oBAChC;gBAEF,KAAK;oBACH,aAAa,IAAA,CAAK,UAAA,CAAW,SAAU,GAAA,EAAK;wBAC1C,OAAO,IAAI,aAAA,IAAiB,IAAI,aAAA,CAAc,KAAK;oBAC/D,CAAW;oBACD;gBAEF,KAAK;oBACH,aAAa,IAAA,CAAK,UAAA,CAAW,KAAK;oBAClC;gBAEF;oBACE,aAAa,IAAA,CAAK,UAAA,CAAW,SAAU,GAAA,EAAK;wBAC1C,OAAO,OAAO,IAAA,IAAQ,IAAI,aAAA,IAAiB,IAAI,aAAA,CAAc,MAAM,KAAK;oBACpF,CAAW;oBAED,IAAI,CAAC,YAAY;wBACf,MAAM,IAAI,MAAM,mBAAmB,IAAI;oBACxC;oBAED;YACH;YAED,IAAA,CAAK,KAAA,CAAM,GAAA,CAAI,UAAU,UAAU;QACpC;QAED,OAAO;IACR;IAAA;;;;GAAA,GAOD,gBAAgB,IAAA,EAAM;QACpB,IAAI,eAAe,IAAA,CAAK,KAAA,CAAM,GAAA,CAAI,IAAI;QAEtC,IAAI,CAAC,cAAc;YACjB,MAAM,SAAS,IAAA;YACf,MAAM,OAAO,IAAA,CAAK,IAAA,CAAK,OAAA,CAAQ,SAAS,SAAS,OAAO,GAAA,CAAI,CAAA,IAAK,CAAE,CAAA;YAEnE,eAAe,QAAQ,GAAA,CACrB,KAAK,GAAA,CAAI,SAAU,GAAA,EAAK,KAAA,EAAO;gBAC7B,OAAO,OAAO,aAAA,CAAc,MAAM,KAAK;YACjD,CAAS;YAGH,IAAA,CAAK,KAAA,CAAM,GAAA,CAAI,MAAM,YAAY;QAClC;QAED,OAAO;IACR;IAAA;;;;GAAA,GAOD,WAAW,WAAA,EAAa;QACtB,MAAM,YAAY,IAAA,CAAK,IAAA,CAAK,OAAA,CAAQ,WAAW,CAAA;QAC/C,MAAM,SAAS,IAAA,CAAK,UAAA;QAEpB,IAAI,UAAU,IAAA,IAAQ,UAAU,IAAA,KAAS,eAAe;YACtD,MAAM,IAAI,MAAM,uBAAuB,UAAU,IAAA,GAAO,gCAAgC;QACzF;QAGD,IAAI,UAAU,GAAA,KAAQ,KAAA,KAAa,gBAAgB,GAAG;YACpD,OAAO,QAAQ,OAAA,CAAQ,IAAA,CAAK,UAAA,CAAW,WAAW,eAAe,CAAA,CAAE,IAAI;QACxE;QAED,MAAM,UAAU,IAAA,CAAK,OAAA;QAErB,OAAO,IAAI,QAAQ,SAAU,OAAA,EAAS,MAAA,EAAQ;YAC5C,OAAO,IAAA,CAAK,qNAAA,CAAY,UAAA,CAAW,UAAU,GAAA,EAAK,QAAQ,IAAI,GAAG,SAAS,KAAA,GAAW,WAAY;gBAC/F,OAAO,IAAI,MAAM,8CAA8C,UAAU,GAAA,GAAM,IAAI,CAAC;YAC5F,CAAO;QACP,CAAK;IACF;IAAA;;;;GAAA,GAOD,eAAe,eAAA,EAAiB;QAC9B,MAAM,gBAAgB,IAAA,CAAK,IAAA,CAAK,WAAA,CAAY,eAAe,CAAA;QAE3D,OAAO,IAAA,CAAK,aAAA,CAAc,UAAU,cAAc,MAAM,EAAE,IAAA,CAAK,SAAU,MAAA,EAAQ;YAC/E,MAAM,aAAa,cAAc,UAAA,IAAc;YAC/C,MAAM,aAAa,cAAc,UAAA,IAAc;YAC/C,OAAO,OAAO,KAAA,CAAM,YAAY,aAAa,UAAU;QAC7D,CAAK;IACF;IAAA;;;;GAAA,GAOD,aAAa,aAAA,EAAe;QAC1B,MAAM,SAAS,IAAA;QACf,MAAM,OAAO,IAAA,CAAK,IAAA;QAElB,MAAM,cAAc,IAAA,CAAK,IAAA,CAAK,SAAA,CAAU,aAAa,CAAA;QAErD,IAAI,YAAY,UAAA,KAAe,KAAA,KAAa,YAAY,MAAA,KAAW,KAAA,GAAW;YAC5E,MAAM,WAAW,gBAAA,CAAiB,YAAY,IAAI,CAAA;YAClD,MAAM,aAAa,qBAAA,CAAsB,YAAY,aAAa,CAAA;YAClE,MAAM,aAAa,YAAY,UAAA,KAAe;YAE9C,MAAM,QAAQ,IAAI,WAAW,YAAY,KAAA,GAAQ,QAAQ;YACzD,OAAO,QAAQ,OAAA,CAAQ,IAAI,yNAAA,CAAgB,OAAO,UAAU,UAAU,CAAC;QACxE;QAED,MAAM,qBAAqB,CAAE,CAAA;QAE7B,IAAI,YAAY,UAAA,KAAe,KAAA,GAAW;YACxC,mBAAmB,IAAA,CAAK,IAAA,CAAK,aAAA,CAAc,cAAc,YAAY,UAAU,CAAC;QACtF,OAAW;YACL,mBAAmB,IAAA,CAAK,IAAI;QAC7B;QAED,IAAI,YAAY,MAAA,KAAW,KAAA,GAAW;YACpC,mBAAmB,IAAA,CAAK,IAAA,CAAK,aAAA,CAAc,cAAc,YAAY,MAAA,CAAO,OAAA,CAAQ,UAAU,CAAC;YAC/F,mBAAmB,IAAA,CAAK,IAAA,CAAK,aAAA,CAAc,cAAc,YAAY,MAAA,CAAO,MAAA,CAAO,UAAU,CAAC;QAC/F;QAED,OAAO,QAAQ,GAAA,CAAI,kBAAkB,EAAE,IAAA,CAAK,SAAU,WAAA,EAAa;YACjE,MAAM,aAAa,WAAA,CAAY,CAAC,CAAA;YAEhC,MAAM,WAAW,gBAAA,CAAiB,YAAY,IAAI,CAAA;YAClD,MAAM,aAAa,qBAAA,CAAsB,YAAY,aAAa,CAAA;YAGlE,MAAM,eAAe,WAAW,iBAAA;YAChC,MAAM,YAAY,eAAe;YACjC,MAAM,aAAa,YAAY,UAAA,IAAc;YAC7C,MAAM,aACJ,YAAY,UAAA,KAAe,KAAA,IAAY,KAAK,WAAA,CAAY,YAAY,UAAU,CAAA,CAAE,UAAA,GAAa,KAAA;YAC/F,MAAM,aAAa,YAAY,UAAA,KAAe;YAC9C,IAAI,OAAO;YAGX,IAAI,cAAc,eAAe,WAAW;gBAG1C,MAAM,UAAU,KAAK,KAAA,CAAM,aAAa,UAAU;gBAClD,MAAM,aACJ,uBACA,YAAY,UAAA,GACZ,MACA,YAAY,aAAA,GACZ,MACA,UACA,MACA,YAAY,KAAA;gBACd,IAAI,KAAK,OAAO,KAAA,CAAM,GAAA,CAAI,UAAU;gBAEpC,IAAI,CAAC,IAAI;oBACP,QAAQ,IAAI,WAAW,YAAY,UAAU,YAAa,YAAY,KAAA,GAAQ,aAAc,YAAY;oBAGxG,KAAK,IAAI,2NAAA,CAAkB,OAAO,aAAa,YAAY;oBAE3D,OAAO,KAAA,CAAM,GAAA,CAAI,YAAY,EAAE;gBAChC;gBAED,kBAAkB,IAAI,oOAAA,CACpB,IACA,UACC,aAAa,aAAc,cAC5B;YAEV,OAAa;gBACL,IAAI,eAAe,MAAM;oBACvB,QAAQ,IAAI,WAAW,YAAY,KAAA,GAAQ,QAAQ;gBAC7D,OAAe;oBACL,QAAQ,IAAI,WAAW,YAAY,YAAY,YAAY,KAAA,GAAQ,QAAQ;gBAC5E;gBAED,kBAAkB,IAAI,yNAAA,CAAgB,OAAO,UAAU,UAAU;YAClE;YAGD,IAAI,YAAY,MAAA,KAAW,KAAA,GAAW;gBACpC,MAAM,kBAAkB,iBAAiB,MAAA;gBACzC,MAAM,oBAAoB,qBAAA,CAAsB,YAAY,MAAA,CAAO,OAAA,CAAQ,aAAa,CAAA;gBAExF,MAAM,oBAAoB,YAAY,MAAA,CAAO,OAAA,CAAQ,UAAA,IAAc;gBACnE,MAAM,mBAAmB,YAAY,MAAA,CAAO,MAAA,CAAO,UAAA,IAAc;gBAEjE,MAAM,gBAAgB,IAAI,kBACxB,WAAA,CAAY,CAAC,CAAA,EACb,mBACA,YAAY,MAAA,CAAO,KAAA,GAAQ;gBAE7B,MAAM,eAAe,IAAI,WAAW,WAAA,CAAY,CAAC,CAAA,EAAG,kBAAkB,YAAY,MAAA,CAAO,KAAA,GAAQ,QAAQ;gBAEzG,IAAI,eAAe,MAAM;oBAEvB,kBAAkB,IAAI,yNAAA,CACpB,gBAAgB,KAAA,CAAM,KAAA,CAAO,GAC7B,gBAAgB,QAAA,EAChB,gBAAgB,UAAA;gBAEnB;gBAED,IAAA,IAAS,IAAI,GAAG,KAAK,cAAc,MAAA,EAAQ,IAAI,IAAI,IAAK;oBACtD,MAAM,QAAQ,aAAA,CAAc,CAAC,CAAA;oBAE7B,gBAAgB,IAAA,CAAK,OAAO,YAAA,CAAa,IAAI,QAAQ,CAAC;oBACtD,IAAI,YAAY,GAAG,gBAAgB,IAAA,CAAK,OAAO,YAAA,CAAa,IAAI,WAAW,CAAC,CAAC;oBAC7E,IAAI,YAAY,GAAG,gBAAgB,IAAA,CAAK,OAAO,YAAA,CAAa,IAAI,WAAW,CAAC,CAAC;oBAC7E,IAAI,YAAY,GAAG,gBAAgB,IAAA,CAAK,OAAO,YAAA,CAAa,IAAI,WAAW,CAAC,CAAC;oBAC7E,IAAI,YAAY,GAAG,MAAM,IAAI,MAAM,mEAAmE;gBACvG;YACF;YAED,OAAO;QACb,CAAK;IACF;IAAA;;;;GAAA,GAOD,YAAY,YAAA,EAAc;QACxB,MAAM,OAAO,IAAA,CAAK,IAAA;QAClB,MAAM,UAAU,IAAA,CAAK,OAAA;QACrB,MAAM,aAAa,KAAK,QAAA,CAAS,YAAY,CAAA;QAC7C,MAAM,cAAc,WAAW,MAAA;QAC/B,MAAM,YAAY,KAAK,MAAA,CAAO,WAAW,CAAA;QAEzC,IAAI,SAAS,IAAA,CAAK,aAAA;QAElB,IAAI,UAAU,GAAA,EAAK;YACjB,MAAM,UAAU,QAAQ,OAAA,CAAQ,UAAA,CAAW,UAAU,GAAG;YACxD,IAAI,YAAY,MAAM,SAAS;QAChC;QAED,OAAO,IAAA,CAAK,gBAAA,CAAiB,cAAc,aAAa,MAAM;IAC/D;IAED,iBAAiB,YAAA,EAAc,WAAA,EAAa,MAAA,EAAQ;QAClD,MAAM,SAAS,IAAA;QACf,MAAM,OAAO,IAAA,CAAK,IAAA;QAElB,MAAM,aAAa,KAAK,QAAA,CAAS,YAAY,CAAA;QAC7C,MAAM,YAAY,KAAK,MAAA,CAAO,WAAW,CAAA;QAEzC,MAAM,WAAA,CAAY,UAAU,GAAA,IAAO,UAAU,UAAA,IAAc,MAAM,WAAW,OAAA;QAE5E,IAAI,IAAA,CAAK,YAAA,CAAa,QAAQ,CAAA,EAAG;YAE/B,OAAO,IAAA,CAAK,YAAA,CAAa,QAAQ,CAAA;QAClC;QAED,MAAM,UAAU,IAAA,CAAK,eAAA,CAAgB,aAAa,MAAM,EACrD,IAAA,CAAK,SAAU,OAAA,EAAS;YACvB,QAAQ,KAAA,GAAQ;YAEhB,QAAQ,IAAA,GAAO,WAAW,IAAA,IAAQ,UAAU,IAAA,IAAQ;YAEpD,IACE,QAAQ,IAAA,KAAS,MACjB,OAAO,UAAU,GAAA,KAAQ,YACzB,UAAU,GAAA,CAAI,UAAA,CAAW,aAAa,MAAM,OAC5C;gBACA,QAAQ,IAAA,GAAO,UAAU,GAAA;YAC1B;YAED,MAAM,WAAW,KAAK,QAAA,IAAY,CAAE;YACpC,MAAM,UAAU,QAAA,CAAS,WAAW,OAAO,CAAA,IAAK,CAAE;YAElD,QAAQ,SAAA,GAAY,aAAA,CAAc,QAAQ,SAAS,CAAA,IAAK,sNAAA;YACxD,QAAQ,SAAA,GAAY,aAAA,CAAc,QAAQ,SAAS,CAAA,IAAK,kOAAA;YACxD,QAAQ,KAAA,GAAQ,eAAA,CAAgB,QAAQ,KAAK,CAAA,IAAK,wNAAA;YAClD,QAAQ,KAAA,GAAQ,eAAA,CAAgB,QAAQ,KAAK,CAAA,IAAK,wNAAA;YAElD,OAAO,YAAA,CAAa,GAAA,CAAI,SAAS;gBAAE,UAAU;YAAA,CAAc;YAE3D,OAAO;QACf,CAAO,EACA,KAAA,CAAM,WAAY;YACjB,OAAO;QACf,CAAO;QAEH,IAAA,CAAK,YAAA,CAAa,QAAQ,CAAA,GAAI;QAE9B,OAAO;IACR;IAED,gBAAgB,WAAA,EAAa,MAAA,EAAQ;QACnC,MAAM,SAAS,IAAA;QACf,MAAM,OAAO,IAAA,CAAK,IAAA;QAClB,MAAM,UAAU,IAAA,CAAK,OAAA;QAErB,IAAI,IAAA,CAAK,WAAA,CAAY,WAAW,CAAA,KAAM,KAAA,GAAW;YAC/C,OAAO,IAAA,CAAK,WAAA,CAAY,WAAW,CAAA,CAAE,IAAA,CAAK,CAAC,UAAY,QAAQ,KAAA,EAAO;QACvE;QAED,MAAM,YAAY,KAAK,MAAA,CAAO,WAAW,CAAA;QAEzC,MAAM,MAAM,KAAK,GAAA,IAAO,KAAK,SAAA;QAE7B,IAAI,YAAY,UAAU,GAAA,IAAO;QACjC,IAAI,cAAc;QAElB,IAAI,UAAU,UAAA,KAAe,KAAA,GAAW;YAGtC,YAAY,OAAO,aAAA,CAAc,cAAc,UAAU,UAAU,EAAE,IAAA,CAAK,SAAU,UAAA,EAAY;gBAC9F,cAAc;gBACd,MAAM,OAAO,IAAI,KAAK;oBAAC,UAAU;iBAAA,EAAG;oBAAE,MAAM,UAAU,QAAA;gBAAA,CAAU;gBAChE,YAAY,IAAI,eAAA,CAAgB,IAAI;gBACpC,OAAO;YACf,CAAO;QACP,OAAA,IAAe,UAAU,GAAA,KAAQ,KAAA,GAAW;YACtC,MAAM,IAAI,MAAM,6BAA6B,cAAc,gCAAgC;QAC5F;QAED,MAAM,UAAU,QAAQ,OAAA,CAAQ,SAAS,EACtC,IAAA,CAAK,SAAUC,UAAAA,EAAW;YACzB,OAAO,IAAI,QAAQ,SAAU,OAAA,EAAS,MAAA,EAAQ;gBAC5C,IAAI,SAAS;gBAEb,IAAI,OAAO,mBAAA,KAAwB,MAAM;oBACvC,SAAS,SAAU,WAAA,EAAa;wBAC9B,MAAM,UAAU,IAAI,iNAAA,CAAQ,WAAW;wBACvC,QAAQ,WAAA,GAAc;wBAEtB,QAAQ,OAAO;oBAChB;gBACF;gBAED,OAAO,IAAA,CAAK,qNAAA,CAAY,UAAA,CAAWA,YAAW,QAAQ,IAAI,GAAG,QAAQ,KAAA,GAAW,MAAM;YAChG,CAAS;QACT,CAAO,EACA,IAAA,CAAK,SAAU,OAAA,EAAS;YAGvB,IAAI,gBAAgB,MAAM;gBACxB,IAAI,eAAA,CAAgB,SAAS;YAC9B;YAED,uBAAuB,SAAS,SAAS;YAEzC,QAAQ,QAAA,CAAS,QAAA,GAAW,UAAU,QAAA,IAAY,oBAAoB,UAAU,GAAG;YAEnF,OAAO;QACf,CAAO,EACA,KAAA,CAAM,SAAU,KAAA,EAAO;YACtB,QAAQ,KAAA,CAAM,2CAA2C,SAAS;YAClE,MAAM;QACd,CAAO;QAEH,IAAA,CAAK,WAAA,CAAY,WAAW,CAAA,GAAI;QAChC,OAAO;IACR;IAAA;;;;;;GAAA,GASD,cAAc,cAAA,EAAgB,OAAA,EAAS,MAAA,EAAQ,UAAA,EAAY;QACzD,MAAM,SAAS,IAAA;QAEf,OAAO,IAAA,CAAK,aAAA,CAAc,WAAW,OAAO,KAAK,EAAE,IAAA,CAAK,SAAU,OAAA,EAAS;YACzE,IAAI,CAAC,SAAS,OAAO;YAErB,IAAI,OAAO,QAAA,KAAa,KAAA,KAAa,OAAO,QAAA,GAAW,GAAG;gBACxD,UAAU,QAAQ,KAAA,CAAO;gBACzB,QAAQ,OAAA,GAAU,OAAO,QAAA;YAC1B;YAED,IAAI,OAAO,UAAA,CAAW,WAAW,qBAAqB,CAAA,EAAG;gBACvD,MAAM,YACJ,OAAO,UAAA,KAAe,KAAA,IAAY,OAAO,UAAA,CAAW,WAAW,qBAAqB,CAAA,GAAI,KAAA;gBAE1F,IAAI,WAAW;oBACb,MAAM,gBAAgB,OAAO,YAAA,CAAa,GAAA,CAAI,OAAO;oBACrD,UAAU,OAAO,UAAA,CAAW,WAAW,qBAAqB,CAAA,CAAE,aAAA,CAAc,SAAS,SAAS;oBAC9F,OAAO,YAAA,CAAa,GAAA,CAAI,SAAS,aAAa;gBAC/C;YACF;YAED,IAAI,eAAe,KAAA,GAAW;gBAE5B,IAAI,OAAO,eAAe,UACxB,aAAa,eAAe,eAAe,iBAAiB;gBAG9D,IAAI,gBAAgB,SAAS,QAAQ,UAAA,GAAa;qBAC7C,QAAQ,QAAA,GAAW,eAAe,iBAAiB,eAAe;YACxE;YAED,cAAA,CAAe,OAAO,CAAA,GAAI;YAE1B,OAAO;QACb,CAAK;IACF;IAAA;;;;;;;GAAA,GAUD,oBAAoB,IAAA,EAAM;QACxB,MAAM,WAAW,KAAK,QAAA;QACtB,IAAI,WAAW,KAAK,QAAA;QAEpB,MAAM,wBAAwB,SAAS,UAAA,CAAW,OAAA,KAAY,KAAA;QAC9D,MAAM,kBAAkB,SAAS,UAAA,CAAW,KAAA,KAAU,KAAA;QACtD,MAAM,iBAAiB,SAAS,UAAA,CAAW,MAAA,KAAW,KAAA;QAEtD,IAAI,KAAK,QAAA,EAAU;YACjB,MAAM,WAAW,oBAAoB,SAAS,IAAA;YAE9C,IAAI,iBAAiB,IAAA,CAAK,KAAA,CAAM,GAAA,CAAI,QAAQ;YAE5C,IAAI,CAAC,gBAAgB;gBACnB,iBAAiB,IAAI,wNAAA,CAAgB;gBACrC,kNAAA,CAAS,SAAA,CAAU,IAAA,CAAK,IAAA,CAAK,gBAAgB,QAAQ;gBACrD,eAAe,KAAA,CAAM,IAAA,CAAK,SAAS,KAAK;gBACxC,eAAe,GAAA,GAAM,SAAS,GAAA;gBAC9B,eAAe,eAAA,GAAkB;gBAEjC,IAAA,CAAK,KAAA,CAAM,GAAA,CAAI,UAAU,cAAc;YACxC;YAED,WAAW;QACjB,OAAA,IAAe,KAAK,MAAA,EAAQ;YACtB,MAAM,WAAW,uBAAuB,SAAS,IAAA;YAEjD,IAAI,eAAe,IAAA,CAAK,KAAA,CAAM,GAAA,CAAI,QAAQ;YAE1C,IAAI,CAAC,cAAc;gBACjB,eAAe,IAAI,2NAAA,CAAmB;gBACtC,kNAAA,CAAS,SAAA,CAAU,IAAA,CAAK,IAAA,CAAK,cAAc,QAAQ;gBACnD,aAAa,KAAA,CAAM,IAAA,CAAK,SAAS,KAAK;gBACtC,aAAa,GAAA,GAAM,SAAS,GAAA;gBAE5B,IAAA,CAAK,KAAA,CAAM,GAAA,CAAI,UAAU,YAAY;YACtC;YAED,WAAW;QACZ;QAGD,IAAI,yBAAyB,mBAAmB,gBAAgB;YAC9D,IAAI,WAAW,oBAAoB,SAAS,IAAA,GAAO;YAEnD,IAAI,uBAAuB,YAAY;YACvC,IAAI,iBAAiB,YAAY;YACjC,IAAI,gBAAgB,YAAY;YAEhC,IAAI,iBAAiB,IAAA,CAAK,KAAA,CAAM,GAAA,CAAI,QAAQ;YAE5C,IAAI,CAAC,gBAAgB;gBACnB,iBAAiB,SAAS,KAAA,CAAO;gBAEjC,IAAI,iBAAiB,eAAe,YAAA,GAAe;gBACnD,IAAI,gBAAgB,eAAe,WAAA,GAAc;gBAEjD,IAAI,uBAAuB;oBAEzB,IAAI,eAAe,WAAA,EAAa,eAAe,WAAA,CAAY,CAAA,IAAK,CAAA;oBAChE,IAAI,eAAe,oBAAA,EAAsB,eAAe,oBAAA,CAAqB,CAAA,IAAK,CAAA;gBACnF;gBAED,IAAA,CAAK,KAAA,CAAM,GAAA,CAAI,UAAU,cAAc;gBAEvC,IAAA,CAAK,YAAA,CAAa,GAAA,CAAI,gBAAgB,IAAA,CAAK,YAAA,CAAa,GAAA,CAAI,QAAQ,CAAC;YACtE;YAED,WAAW;QACZ;QAED,KAAK,QAAA,GAAW;IACjB;IAED,kBAAqC;QACnC,OAAO,8NAAA;IACR;IAAA;;;;GAAA,GAOD,aAAa,aAAA,EAAe;QAC1B,MAAM,SAAS,IAAA;QACf,MAAM,OAAO,IAAA,CAAK,IAAA;QAClB,MAAM,aAAa,IAAA,CAAK,UAAA;QACxB,MAAM,cAAc,KAAK,SAAA,CAAU,aAAa,CAAA;QAEhD,IAAI;QACJ,MAAM,iBAAiB,CAAE;QACzB,MAAM,qBAAqB,YAAY,UAAA,IAAc,CAAE;QAEvD,MAAM,UAAU,CAAE,CAAA;QAElB,IAAI,kBAAA,CAAmB,WAAW,mBAAmB,CAAA,EAAG;YACtD,MAAM,eAAe,UAAA,CAAW,WAAW,mBAAmB,CAAA;YAC9D,eAAe,aAAa,eAAA,CAAiB;YAC7C,QAAQ,IAAA,CAAK,aAAa,YAAA,CAAa,gBAAgB,aAAa,MAAM,CAAC;QACjF,OAAW;YAIL,MAAM,oBAAoB,YAAY,oBAAA,IAAwB,CAAE;YAEhE,eAAe,KAAA,GAAQ,IAAI,+MAAA,CAAM,GAAK,GAAK,CAAG;YAC9C,eAAe,OAAA,GAAU;YAEzB,IAAI,MAAM,OAAA,CAAQ,kBAAkB,eAAe,GAAG;gBACpD,MAAM,QAAQ,kBAAkB,eAAA;gBAEhC,eAAe,KAAA,CAAM,MAAA,CAAO,KAAA,CAAM,CAAC,CAAA,EAAG,KAAA,CAAM,CAAC,CAAA,EAAG,KAAA,CAAM,CAAC,CAAA,EAAG,oBAAoB;gBAC9E,eAAe,OAAA,GAAU,KAAA,CAAM,CAAC,CAAA;YACjC;YAED,IAAI,kBAAkB,gBAAA,KAAqB,KAAA,GAAW;gBACpD,QAAQ,IAAA,CAAK,OAAO,aAAA,CAAc,gBAAgB,OAAO,kBAAkB,gBAAA,EAAkB,cAAc,CAAC;YAC7G;YAED,eAAe,SAAA,GAAY,kBAAkB,cAAA,KAAmB,KAAA,IAAY,kBAAkB,cAAA,GAAiB;YAC/G,eAAe,SAAA,GACb,kBAAkB,eAAA,KAAoB,KAAA,IAAY,kBAAkB,eAAA,GAAkB;YAExF,IAAI,kBAAkB,wBAAA,KAA6B,KAAA,GAAW;gBAC5D,QAAQ,IAAA,CAAK,OAAO,aAAA,CAAc,gBAAgB,gBAAgB,kBAAkB,wBAAwB,CAAC;gBAC7G,QAAQ,IAAA,CAAK,OAAO,aAAA,CAAc,gBAAgB,gBAAgB,kBAAkB,wBAAwB,CAAC;YAC9G;YAED,eAAe,IAAA,CAAK,UAAA,CAAW,SAAU,GAAA,EAAK;gBAC5C,OAAO,IAAI,eAAA,IAAmB,IAAI,eAAA,CAAgB,aAAa;YACvE,CAAO;YAED,QAAQ,IAAA,CACN,QAAQ,GAAA,CACN,IAAA,CAAK,UAAA,CAAW,SAAU,GAAA,EAAK;gBAC7B,OAAO,IAAI,oBAAA,IAAwB,IAAI,oBAAA,CAAqB,eAAe,cAAc;YACrG,CAAW;QAGN;QAED,IAAI,YAAY,WAAA,KAAgB,MAAM;YACpC,eAAe,IAAA,GAAO,oNAAA;QACvB;QAED,MAAM,YAAY,YAAY,SAAA,IAAa,YAAY,MAAA;QAEvD,IAAI,cAAc,YAAY,KAAA,EAAO;YACnC,eAAe,WAAA,GAAc;YAG7B,eAAe,UAAA,GAAa;QAClC,OAAW;YACL,eAAe,WAAA,GAAc;YAE7B,IAAI,cAAc,YAAY,IAAA,EAAM;gBAClC,eAAe,SAAA,GAAY,YAAY,WAAA,KAAgB,KAAA,IAAY,YAAY,WAAA,GAAc;YAC9F;QACF;QAED,IAAI,YAAY,aAAA,KAAkB,KAAA,KAAa,iBAAiB,2NAAA,EAAmB;YACjF,QAAQ,IAAA,CAAK,OAAO,aAAA,CAAc,gBAAgB,aAAa,YAAY,aAAa,CAAC;YAEzF,eAAe,WAAA,GAAc,IAAI,iNAAA,CAAQ,GAAG,CAAC;YAE7C,IAAI,YAAY,aAAA,CAAc,KAAA,KAAU,KAAA,GAAW;gBACjD,MAAM,QAAQ,YAAY,aAAA,CAAc,KAAA;gBAExC,eAAe,WAAA,CAAY,GAAA,CAAI,OAAO,KAAK;YAC5C;QACF;QAED,IAAI,YAAY,gBAAA,KAAqB,KAAA,KAAa,iBAAiB,2NAAA,EAAmB;YACpF,QAAQ,IAAA,CAAK,OAAO,aAAA,CAAc,gBAAgB,SAAS,YAAY,gBAAgB,CAAC;YAExF,IAAI,YAAY,gBAAA,CAAiB,QAAA,KAAa,KAAA,GAAW;gBACvD,eAAe,cAAA,GAAiB,YAAY,gBAAA,CAAiB,QAAA;YAC9D;QACF;QAED,IAAI,YAAY,cAAA,KAAmB,KAAA,KAAa,iBAAiB,2NAAA,EAAmB;YAClF,MAAM,iBAAiB,YAAY,cAAA;YACnC,eAAe,QAAA,GAAW,IAAI,+MAAA,CAAK,EAAG,MAAA,CACpC,cAAA,CAAe,CAAC,CAAA,EAChB,cAAA,CAAe,CAAC,CAAA,EAChB,cAAA,CAAe,CAAC,CAAA,EAChB;QAEH;QAED,IAAI,YAAY,eAAA,KAAoB,KAAA,KAAa,iBAAiB,2NAAA,EAAmB;YACnF,QAAQ,IAAA,CAAK,OAAO,aAAA,CAAc,gBAAgB,eAAe,YAAY,eAAA,EAAiB,cAAc,CAAC;QAC9G;QAED,OAAO,QAAQ,GAAA,CAAI,OAAO,EAAE,IAAA,CAAK,WAAY;YAC3C,MAAM,WAAW,IAAI,aAAa,cAAc;YAEhD,IAAI,YAAY,IAAA,EAAM,SAAS,IAAA,GAAO,YAAY,IAAA;YAElD,uBAAuB,UAAU,WAAW;YAE5C,OAAO,YAAA,CAAa,GAAA,CAAI,UAAU;gBAAE,WAAW;YAAA,CAAe;YAE9D,IAAI,YAAY,UAAA,EAAY,+BAA+B,YAAY,UAAU,WAAW;YAE5F,OAAO;QACb,CAAK;IACF;IAAA,+EAAA,GAGD,iBAAiB,YAAA,EAAc;QAC7B,MAAM,gBAAgB,yNAAA,CAAgB,gBAAA,CAAiB,gBAAgB,EAAE;QAEzE,IAAI,iBAAiB,IAAA,CAAK,aAAA,EAAe;YACvC,OAAO,gBAAgB,MAAM,EAAE,IAAA,CAAK,aAAA,CAAc,aAAa,CAAA;QACrE,OAAW;YACL,IAAA,CAAK,aAAA,CAAc,aAAa,CAAA,GAAI;YAEpC,OAAO;QACR;IACF;IAAA;;;;;;;GAAA,GAUD,eAAe,UAAA,EAAY;QACzB,MAAM,SAAS,IAAA;QACf,MAAM,aAAa,IAAA,CAAK,UAAA;QACxB,MAAM,QAAQ,IAAA,CAAK,cAAA;QAEnB,SAAS,qBAAqB,SAAA,EAAW;YACvC,OAAO,UAAA,CAAW,WAAW,0BAA0B,CAAA,CACpD,eAAA,CAAgB,WAAW,MAAM,EACjC,IAAA,CAAK,SAAU,QAAA,EAAU;gBACxB,OAAO,uBAAuB,UAAU,WAAW,MAAM;YACnE,CAAS;QACJ;QAED,MAAM,UAAU,CAAE,CAAA;QAElB,IAAA,IAAS,IAAI,GAAG,KAAK,WAAW,MAAA,EAAQ,IAAI,IAAI,IAAK;YACnD,MAAM,YAAY,UAAA,CAAW,CAAC,CAAA;YAC9B,MAAM,WAAW,mBAAmB,SAAS;YAG7C,MAAM,SAAS,KAAA,CAAM,QAAQ,CAAA;YAE7B,IAAI,QAAQ;gBAEV,QAAQ,IAAA,CAAK,OAAO,OAAO;YACnC,OAAa;gBACL,IAAI;gBAEJ,IAAI,UAAU,UAAA,IAAc,UAAU,UAAA,CAAW,WAAW,0BAA0B,CAAA,EAAG;oBAEvF,kBAAkB,qBAAqB,SAAS;gBAC1D,OAAe;oBAEL,kBAAkB,uBAAuB,IAAI,wNAAA,CAAc,GAAI,WAAW,MAAM;gBACjF;gBAGD,KAAA,CAAM,QAAQ,CAAA,GAAI;oBAAE;oBAAsB,SAAS;gBAAiB;gBAEpE,QAAQ,IAAA,CAAK,eAAe;YAC7B;QACF;QAED,OAAO,QAAQ,GAAA,CAAI,OAAO;IAC3B;IAAA;;;;GAAA,GAOD,SAAS,SAAA,EAAW;QAClB,MAAM,SAAS,IAAA;QACf,MAAM,OAAO,IAAA,CAAK,IAAA;QAClB,MAAM,aAAa,IAAA,CAAK,UAAA;QAExB,MAAM,UAAU,KAAK,MAAA,CAAO,SAAS,CAAA;QACrC,MAAM,aAAa,QAAQ,UAAA;QAE3B,MAAM,UAAU,CAAE,CAAA;QAElB,IAAA,IAAS,IAAI,GAAG,KAAK,WAAW,MAAA,EAAQ,IAAI,IAAI,IAAK;YACnD,MAAM,WACJ,UAAA,CAAW,CAAC,CAAA,CAAE,QAAA,KAAa,KAAA,IACvB,sBAAsB,IAAA,CAAK,KAAK,IAChC,IAAA,CAAK,aAAA,CAAc,YAAY,UAAA,CAAW,CAAC,CAAA,CAAE,QAAQ;YAE3D,QAAQ,IAAA,CAAK,QAAQ;QACtB;QAED,QAAQ,IAAA,CAAK,OAAO,cAAA,CAAe,UAAU,CAAC;QAE9C,OAAO,QAAQ,GAAA,CAAI,OAAO,EAAE,IAAA,CAAK,SAAU,OAAA,EAAS;YAClD,MAAM,YAAY,QAAQ,KAAA,CAAM,GAAG,QAAQ,MAAA,GAAS,CAAC;YACrD,MAAM,aAAa,OAAA,CAAQ,QAAQ,MAAA,GAAS,CAAC,CAAA;YAE7C,MAAM,SAAS,CAAE,CAAA;YAEjB,IAAA,IAAS,IAAI,GAAG,KAAK,WAAW,MAAA,EAAQ,IAAI,IAAI,IAAK;gBACnD,MAAM,WAAW,UAAA,CAAW,CAAC,CAAA;gBAC7B,MAAM,YAAY,UAAA,CAAW,CAAC,CAAA;gBAI9B,IAAI;gBAEJ,MAAM,WAAW,SAAA,CAAU,CAAC,CAAA;gBAE5B,IACE,UAAU,IAAA,KAAS,gBAAgB,SAAA,IACnC,UAAU,IAAA,KAAS,gBAAgB,cAAA,IACnC,UAAU,IAAA,KAAS,gBAAgB,YAAA,IACnC,UAAU,IAAA,KAAS,KAAA,GACnB;oBAEA,OAAO,QAAQ,aAAA,KAAkB,OAAO,IAAI,qNAAA,CAAY,UAAU,QAAQ,IAAI,IAAI,8MAAA,CAAK,UAAU,QAAQ;oBAEzG,IAAI,KAAK,aAAA,KAAkB,MAAM;wBAE/B,KAAK,oBAAA,CAAsB;oBAC5B;oBAED,IAAI,UAAU,IAAA,KAAS,gBAAgB,cAAA,EAAgB;wBACrD,KAAK,QAAA,OAAW,6QAAA,EAAoB,KAAK,QAAA,EAAU,+NAAqB;oBACzE,OAAA,IAAU,UAAU,IAAA,KAAS,gBAAgB,YAAA,EAAc;wBAC1D,KAAK,QAAA,OAAW,6QAAA,EAAoB,KAAK,QAAA,EAAU,6NAAmB;oBACvE;gBACF,OAAA,IAAU,UAAU,IAAA,KAAS,gBAAgB,KAAA,EAAO;oBACnD,OAAO,IAAI,sNAAA,CAAa,UAAU,QAAQ;gBAC3C,OAAA,IAAU,UAAU,IAAA,KAAS,gBAAgB,UAAA,EAAY;oBACxD,OAAO,IAAI,8MAAA,CAAK,UAAU,QAAQ;gBACnC,OAAA,IAAU,UAAU,IAAA,KAAS,gBAAgB,SAAA,EAAW;oBACvD,OAAO,IAAI,kNAAA,CAAS,UAAU,QAAQ;gBACvC,OAAA,IAAU,UAAU,IAAA,KAAS,gBAAgB,MAAA,EAAQ;oBACpD,OAAO,IAAI,gNAAA,CAAO,UAAU,QAAQ;gBAC9C,OAAe;oBACL,MAAM,IAAI,MAAM,mDAAmD,UAAU,IAAI;gBAClF;gBAED,IAAI,OAAO,IAAA,CAAK,KAAK,QAAA,CAAS,eAAe,EAAE,MAAA,GAAS,GAAG;oBACzD,mBAAmB,MAAM,OAAO;gBACjC;gBAED,KAAK,IAAA,GAAO,OAAO,gBAAA,CAAiB,QAAQ,IAAA,IAAQ,UAAU,SAAS;gBAEvE,uBAAuB,MAAM,OAAO;gBAEpC,IAAI,UAAU,UAAA,EAAY,+BAA+B,YAAY,MAAM,SAAS;gBAEpF,OAAO,mBAAA,CAAoB,IAAI;gBAE/B,OAAO,IAAA,CAAK,IAAI;YACjB;YAED,IAAA,IAAS,IAAI,GAAG,KAAK,OAAO,MAAA,EAAQ,IAAI,IAAI,IAAK;gBAC/C,OAAO,YAAA,CAAa,GAAA,CAAI,MAAA,CAAO,CAAC,CAAA,EAAG;oBACjC,QAAQ;oBACR,YAAY;gBACtB,CAAS;YACF;YAED,IAAI,OAAO,MAAA,KAAW,GAAG;gBACvB,IAAI,QAAQ,UAAA,EAAY,+BAA+B,YAAY,MAAA,CAAO,CAAC,CAAA,EAAG,OAAO;gBAErF,OAAO,MAAA,CAAO,CAAC,CAAA;YAChB;YAED,MAAM,QAAQ,IAAI,+MAAA,CAAO;YAEzB,IAAI,QAAQ,UAAA,EAAY,+BAA+B,YAAY,OAAO,OAAO;YAEjF,OAAO,YAAA,CAAa,GAAA,CAAI,OAAO;gBAAE,QAAQ;YAAA,CAAW;YAEpD,IAAA,IAAS,IAAI,GAAG,KAAK,OAAO,MAAA,EAAQ,IAAI,IAAI,IAAK;gBAC/C,MAAM,GAAA,CAAI,MAAA,CAAO,CAAC,CAAC;YACpB;YAED,OAAO;QACb,CAAK;IACF;IAAA;;;;GAAA,GAOD,WAAW,WAAA,EAAa;QACtB,IAAI;QACJ,MAAM,YAAY,IAAA,CAAK,IAAA,CAAK,OAAA,CAAQ,WAAW,CAAA;QAC/C,MAAM,SAAS,SAAA,CAAU,UAAU,IAAI,CAAA;QAEvC,IAAI,CAAC,QAAQ;YACX,QAAQ,IAAA,CAAK,8CAA8C;YAC3D;QACD;QAED,IAAI,UAAU,IAAA,KAAS,eAAe;YACpC,SAAS,IAAI,2NAAA,CACX,mNAAA,CAAU,QAAA,CAAS,OAAO,IAAI,GAC9B,OAAO,WAAA,IAAe,GACtB,OAAO,KAAA,IAAS,GAChB,OAAO,IAAA,IAAQ;QAEvB,OAAA,IAAe,UAAU,IAAA,KAAS,gBAAgB;YAC5C,SAAS,IAAI,4NAAA,CAAmB,CAAC,OAAO,IAAA,EAAM,OAAO,IAAA,EAAM,OAAO,IAAA,EAAM,CAAC,OAAO,IAAA,EAAM,OAAO,KAAA,EAAO,OAAO,IAAI;QAChH;QAED,IAAI,UAAU,IAAA,EAAM,OAAO,IAAA,GAAO,IAAA,CAAK,gBAAA,CAAiB,UAAU,IAAI;QAEtE,uBAAuB,QAAQ,SAAS;QAExC,OAAO,QAAQ,OAAA,CAAQ,MAAM;IAC9B;IAAA;;;;GAAA,GAOD,SAAS,SAAA,EAAW;QAClB,MAAM,UAAU,IAAA,CAAK,IAAA,CAAK,KAAA,CAAM,SAAS,CAAA;QAEzC,MAAM,UAAU,CAAE,CAAA;QAElB,IAAA,IAAS,IAAI,GAAG,KAAK,QAAQ,MAAA,CAAO,MAAA,EAAQ,IAAI,IAAI,IAAK;YACvD,QAAQ,IAAA,CAAK,IAAA,CAAK,gBAAA,CAAiB,QAAQ,MAAA,CAAO,CAAC,CAAC,CAAC;QACtD;QAED,IAAI,QAAQ,mBAAA,KAAwB,KAAA,GAAW;YAC7C,QAAQ,IAAA,CAAK,IAAA,CAAK,aAAA,CAAc,YAAY,QAAQ,mBAAmB,CAAC;QAC9E,OAAW;YACL,QAAQ,IAAA,CAAK,IAAI;QAClB;QAED,OAAO,QAAQ,GAAA,CAAI,OAAO,EAAE,IAAA,CAAK,SAAU,OAAA,EAAS;YAClD,MAAM,sBAAsB,QAAQ,GAAA,CAAK;YACzC,MAAM,aAAa;YAKnB,MAAM,QAAQ,CAAE,CAAA;YAChB,MAAM,eAAe,CAAE,CAAA;YAEvB,IAAA,IAAS,IAAI,GAAG,KAAK,WAAW,MAAA,EAAQ,IAAI,IAAI,IAAK;gBACnD,MAAM,YAAY,UAAA,CAAW,CAAC,CAAA;gBAE9B,IAAI,WAAW;oBACb,MAAM,IAAA,CAAK,SAAS;oBAEpB,MAAM,MAAM,IAAI,iNAAA,CAAS;oBAEzB,IAAI,wBAAwB,MAAM;wBAChC,IAAI,SAAA,CAAU,oBAAoB,KAAA,EAAO,IAAI,EAAE;oBAChD;oBAED,aAAa,IAAA,CAAK,GAAG;gBAC/B,OAAe;oBACL,QAAQ,IAAA,CAAK,oDAAoD,QAAQ,MAAA,CAAO,CAAC,CAAC;gBACnF;YACF;YAED,OAAO,IAAI,kNAAA,CAAS,OAAO,YAAY;QAC7C,CAAK;IACF;IAAA;;;;GAAA,GAOD,cAAc,cAAA,EAAgB;QAC5B,MAAM,OAAO,IAAA,CAAK,IAAA;QAClB,MAAM,SAAS,IAAA;QAEf,MAAM,eAAe,KAAK,UAAA,CAAW,cAAc,CAAA;QACnD,MAAM,gBAAgB,aAAa,IAAA,GAAO,aAAa,IAAA,GAAO,eAAe;QAE7E,MAAM,eAAe,CAAE,CAAA;QACvB,MAAM,wBAAwB,CAAE,CAAA;QAChC,MAAM,yBAAyB,CAAE,CAAA;QACjC,MAAM,kBAAkB,CAAE,CAAA;QAC1B,MAAM,iBAAiB,CAAE,CAAA;QAEzB,IAAA,IAAS,IAAI,GAAG,KAAK,aAAa,QAAA,CAAS,MAAA,EAAQ,IAAI,IAAI,IAAK;YAC9D,MAAM,UAAU,aAAa,QAAA,CAAS,CAAC,CAAA;YACvC,MAAM,UAAU,aAAa,QAAA,CAAS,QAAQ,OAAO,CAAA;YACrD,MAAM,SAAS,QAAQ,MAAA;YACvB,MAAM,OAAO,OAAO,IAAA;YACpB,MAAM,QAAQ,aAAa,UAAA,KAAe,KAAA,IAAY,aAAa,UAAA,CAAW,QAAQ,KAAK,CAAA,GAAI,QAAQ,KAAA;YACvG,MAAM,SAAS,aAAa,UAAA,KAAe,KAAA,IAAY,aAAa,UAAA,CAAW,QAAQ,MAAM,CAAA,GAAI,QAAQ,MAAA;YAEzG,IAAI,OAAO,IAAA,KAAS,KAAA,GAAW;YAE/B,aAAa,IAAA,CAAK,IAAA,CAAK,aAAA,CAAc,QAAQ,IAAI,CAAC;YAClD,sBAAsB,IAAA,CAAK,IAAA,CAAK,aAAA,CAAc,YAAY,KAAK,CAAC;YAChE,uBAAuB,IAAA,CAAK,IAAA,CAAK,aAAA,CAAc,YAAY,MAAM,CAAC;YAClE,gBAAgB,IAAA,CAAK,OAAO;YAC5B,eAAe,IAAA,CAAK,MAAM;QAC3B;QAED,OAAO,QAAQ,GAAA,CAAI;YACjB,QAAQ,GAAA,CAAI,YAAY;YACxB,QAAQ,GAAA,CAAI,qBAAqB;YACjC,QAAQ,GAAA,CAAI,sBAAsB;YAClC,QAAQ,GAAA,CAAI,eAAe;YAC3B,QAAQ,GAAA,CAAI,cAAc;SAC3B,EAAE,IAAA,CAAK,SAAU,YAAA,EAAc;YAC9B,MAAM,QAAQ,YAAA,CAAa,CAAC,CAAA;YAC5B,MAAM,iBAAiB,YAAA,CAAa,CAAC,CAAA;YACrC,MAAM,kBAAkB,YAAA,CAAa,CAAC,CAAA;YACtC,MAAM,WAAW,YAAA,CAAa,CAAC,CAAA;YAC/B,MAAM,UAAU,YAAA,CAAa,CAAC,CAAA;YAE9B,MAAM,SAAS,CAAE,CAAA;YAEjB,IAAA,IAAS,IAAI,GAAG,KAAK,MAAM,MAAA,EAAQ,IAAI,IAAI,IAAK;gBAC9C,MAAM,OAAO,KAAA,CAAM,CAAC,CAAA;gBACpB,MAAM,gBAAgB,cAAA,CAAe,CAAC,CAAA;gBACtC,MAAM,iBAAiB,eAAA,CAAgB,CAAC,CAAA;gBACxC,MAAM,UAAU,QAAA,CAAS,CAAC,CAAA;gBAC1B,MAAM,SAAS,OAAA,CAAQ,CAAC,CAAA;gBAExB,IAAI,SAAS,KAAA,GAAW;gBAExB,IAAI,KAAK,YAAA,EAAc;oBACrB,KAAK,YAAA,CAAc;gBACpB;gBAED,MAAM,gBAAgB,OAAO,sBAAA,CAAuB,MAAM,eAAe,gBAAgB,SAAS,MAAM;gBAExG,IAAI,eAAe;oBACjB,IAAA,IAAS,IAAI,GAAG,IAAI,cAAc,MAAA,EAAQ,IAAK;wBAC7C,OAAO,IAAA,CAAK,aAAA,CAAc,CAAC,CAAC;oBAC7B;gBACF;YACF;YAED,OAAO,IAAI,uNAAA,CAAc,eAAe,KAAA,GAAW,MAAM;QAC/D,CAAK;IACF;IAED,eAAe,SAAA,EAAW;QACxB,MAAM,OAAO,IAAA,CAAK,IAAA;QAClB,MAAM,SAAS,IAAA;QACf,MAAM,UAAU,KAAK,KAAA,CAAM,SAAS,CAAA;QAEpC,IAAI,QAAQ,IAAA,KAAS,KAAA,GAAW,OAAO;QAEvC,OAAO,OAAO,aAAA,CAAc,QAAQ,QAAQ,IAAI,EAAE,IAAA,CAAK,SAAU,IAAA,EAAM;YACrE,MAAM,OAAO,OAAO,WAAA,CAAY,OAAO,SAAA,EAAW,QAAQ,IAAA,EAAM,IAAI;YAGpE,IAAI,QAAQ,OAAA,KAAY,KAAA,GAAW;gBACjC,KAAK,QAAA,CAAS,SAAU,CAAA,EAAG;oBACzB,IAAI,CAAC,EAAE,MAAA,EAAQ;oBAEf,IAAA,IAAS,IAAI,GAAG,KAAK,QAAQ,OAAA,CAAQ,MAAA,EAAQ,IAAI,IAAI,IAAK;wBACxD,EAAE,qBAAA,CAAsB,CAAC,CAAA,GAAI,QAAQ,OAAA,CAAQ,CAAC,CAAA;oBAC/C;gBACX,CAAS;YACF;YAED,OAAO;QACb,CAAK;IACF;IAAA;;;;GAAA,GAOD,SAAS,SAAA,EAAW;QAClB,MAAM,OAAO,IAAA,CAAK,IAAA;QAClB,MAAM,SAAS,IAAA;QAEf,MAAM,UAAU,KAAK,KAAA,CAAM,SAAS,CAAA;QAEpC,MAAM,cAAc,OAAO,gBAAA,CAAiB,SAAS;QAErD,MAAM,eAAe,CAAE,CAAA;QACvB,MAAM,cAAc,QAAQ,QAAA,IAAY,CAAE,CAAA;QAE1C,IAAA,IAAS,IAAI,GAAG,KAAK,YAAY,MAAA,EAAQ,IAAI,IAAI,IAAK;YACpD,aAAa,IAAA,CAAK,OAAO,aAAA,CAAc,QAAQ,WAAA,CAAY,CAAC,CAAC,CAAC;QAC/D;QAED,MAAM,kBACJ,QAAQ,IAAA,KAAS,KAAA,IAAY,QAAQ,OAAA,CAAQ,IAAI,IAAI,OAAO,aAAA,CAAc,QAAQ,QAAQ,IAAI;QAEhG,OAAO,QAAQ,GAAA,CAAI;YAAC;YAAa,QAAQ,GAAA,CAAI,YAAY;YAAG,eAAe;SAAC,EAAE,IAAA,CAAK,SAAU,OAAA,EAAS;YACpG,MAAM,OAAO,OAAA,CAAQ,CAAC,CAAA;YACtB,MAAM,WAAW,OAAA,CAAQ,CAAC,CAAA;YAC1B,MAAM,WAAW,OAAA,CAAQ,CAAC,CAAA;YAE1B,IAAI,aAAa,MAAM;gBAGrB,KAAK,QAAA,CAAS,SAAU,IAAA,EAAM;oBAC5B,IAAI,CAAC,KAAK,aAAA,EAAe;oBAEzB,KAAK,IAAA,CAAK,UAAU,eAAe;gBAC7C,CAAS;YACF;YAED,IAAA,IAAS,IAAI,GAAG,KAAK,SAAS,MAAA,EAAQ,IAAI,IAAI,IAAK;gBACjD,KAAK,GAAA,CAAI,QAAA,CAAS,CAAC,CAAC;YACrB;YAED,OAAO;QACb,CAAK;IACF;IAAA,4CAAA;IAAA,6EAAA;IAID,iBAAiB,SAAA,EAAW;QAC1B,MAAM,OAAO,IAAA,CAAK,IAAA;QAClB,MAAM,aAAa,IAAA,CAAK,UAAA;QACxB,MAAM,SAAS,IAAA;QAKf,IAAI,IAAA,CAAK,SAAA,CAAU,SAAS,CAAA,KAAM,KAAA,GAAW;YAC3C,OAAO,IAAA,CAAK,SAAA,CAAU,SAAS,CAAA;QAChC;QAED,MAAM,UAAU,KAAK,KAAA,CAAM,SAAS,CAAA;QAGpC,MAAM,WAAW,QAAQ,IAAA,GAAO,OAAO,gBAAA,CAAiB,QAAQ,IAAI,IAAI;QAExE,MAAM,UAAU,CAAE,CAAA;QAElB,MAAM,cAAc,OAAO,UAAA,CAAW,SAAU,GAAA,EAAK;YACnD,OAAO,IAAI,cAAA,IAAkB,IAAI,cAAA,CAAe,SAAS;QAC/D,CAAK;QAED,IAAI,aAAa;YACf,QAAQ,IAAA,CAAK,WAAW;QACzB;QAED,IAAI,QAAQ,MAAA,KAAW,KAAA,GAAW;YAChC,QAAQ,IAAA,CACN,OAAO,aAAA,CAAc,UAAU,QAAQ,MAAM,EAAE,IAAA,CAAK,SAAU,MAAA,EAAQ;gBACpE,OAAO,OAAO,WAAA,CAAY,OAAO,WAAA,EAAa,QAAQ,MAAA,EAAQ,MAAM;YAC9E,CAAS;QAEJ;QAED,OACG,UAAA,CAAW,SAAU,GAAA,EAAK;YACzB,OAAO,IAAI,oBAAA,IAAwB,IAAI,oBAAA,CAAqB,SAAS;QAC7E,CAAO,EACA,OAAA,CAAQ,SAAU,OAAA,EAAS;YAC1B,QAAQ,IAAA,CAAK,OAAO;QAC5B,CAAO;QAEH,IAAA,CAAK,SAAA,CAAU,SAAS,CAAA,GAAI,QAAQ,GAAA,CAAI,OAAO,EAAE,IAAA,CAAK,SAAU,OAAA,EAAS;YACvE,IAAI;YAGJ,IAAI,QAAQ,MAAA,KAAW,MAAM;gBAC3B,OAAO,IAAI,8MAAA,CAAM;YACzB,OAAA,IAAiB,QAAQ,MAAA,GAAS,GAAG;gBAC7B,OAAO,IAAI,+MAAA,CAAO;YAC1B,OAAA,IAAiB,QAAQ,MAAA,KAAW,GAAG;gBAC/B,OAAO,OAAA,CAAQ,CAAC,CAAA;YACxB,OAAa;gBACL,OAAO,IAAI,kNAAA,CAAU;YACtB;YAED,IAAI,SAAS,OAAA,CAAQ,CAAC,CAAA,EAAG;gBACvB,IAAA,IAAS,IAAI,GAAG,KAAK,QAAQ,MAAA,EAAQ,IAAI,IAAI,IAAK;oBAChD,KAAK,GAAA,CAAI,OAAA,CAAQ,CAAC,CAAC;gBACpB;YACF;YAED,IAAI,QAAQ,IAAA,EAAM;gBAChB,KAAK,QAAA,CAAS,IAAA,GAAO,QAAQ,IAAA;gBAC7B,KAAK,IAAA,GAAO;YACb;YAED,uBAAuB,MAAM,OAAO;YAEpC,IAAI,QAAQ,UAAA,EAAY,+BAA+B,YAAY,MAAM,OAAO;YAEhF,IAAI,QAAQ,MAAA,KAAW,KAAA,GAAW;gBAChC,MAAM,SAAS,IAAI,iNAAA,CAAS;gBAC5B,OAAO,SAAA,CAAU,QAAQ,MAAM;gBAC/B,KAAK,YAAA,CAAa,MAAM;YAChC,OAAa;gBACL,IAAI,QAAQ,WAAA,KAAgB,KAAA,GAAW;oBACrC,KAAK,QAAA,CAAS,SAAA,CAAU,QAAQ,WAAW;gBAC5C;gBAED,IAAI,QAAQ,QAAA,KAAa,KAAA,GAAW;oBAClC,KAAK,UAAA,CAAW,SAAA,CAAU,QAAQ,QAAQ;gBAC3C;gBAED,IAAI,QAAQ,KAAA,KAAU,KAAA,GAAW;oBAC/B,KAAK,KAAA,CAAM,SAAA,CAAU,QAAQ,KAAK;gBACnC;YACF;YAED,IAAI,CAAC,OAAO,YAAA,CAAa,GAAA,CAAI,IAAI,GAAG;gBAClC,OAAO,YAAA,CAAa,GAAA,CAAI,MAAM,CAAA,CAAE;YACjC;YAED,OAAO,YAAA,CAAa,GAAA,CAAI,IAAI,EAAE,KAAA,GAAQ;YAEtC,OAAO;QACb,CAAK;QAED,OAAO,IAAA,CAAK,SAAA,CAAU,SAAS,CAAA;IAChC;IAAA;;;;GAAA,GAOD,UAAU,UAAA,EAAY;QACpB,MAAM,aAAa,IAAA,CAAK,UAAA;QACxB,MAAM,WAAW,IAAA,CAAK,IAAA,CAAK,MAAA,CAAO,UAAU,CAAA;QAC5C,MAAM,SAAS,IAAA;QAIf,MAAM,QAAQ,IAAI,+MAAA,CAAO;QACzB,IAAI,SAAS,IAAA,EAAM,MAAM,IAAA,GAAO,OAAO,gBAAA,CAAiB,SAAS,IAAI;QAErE,uBAAuB,OAAO,QAAQ;QAEtC,IAAI,SAAS,UAAA,EAAY,+BAA+B,YAAY,OAAO,QAAQ;QAEnF,MAAM,UAAU,SAAS,KAAA,IAAS,CAAE,CAAA;QAEpC,MAAM,UAAU,CAAE,CAAA;QAElB,IAAA,IAAS,IAAI,GAAG,KAAK,QAAQ,MAAA,EAAQ,IAAI,IAAI,IAAK;YAChD,QAAQ,IAAA,CAAK,OAAO,aAAA,CAAc,QAAQ,OAAA,CAAQ,CAAC,CAAC,CAAC;QACtD;QAED,OAAO,QAAQ,GAAA,CAAI,OAAO,EAAE,IAAA,CAAK,SAAU,KAAA,EAAO;YAChD,IAAA,IAAS,IAAI,GAAG,KAAK,MAAM,MAAA,EAAQ,IAAI,IAAI,IAAK;gBAC9C,MAAM,GAAA,CAAI,KAAA,CAAM,CAAC,CAAC;YACnB;YAID,MAAM,qBAAqB,CAAC,SAAS;gBACnC,MAAM,sBAAsB,aAAA,GAAA,IAAI,IAAK;gBAErC,KAAA,MAAW,CAAC,KAAK,KAAK,CAAA,IAAK,OAAO,YAAA,CAAc;oBAC9C,IAAI,eAAe,kNAAA,IAAY,eAAe,iNAAA,EAAS;wBACrD,oBAAoB,GAAA,CAAI,KAAK,KAAK;oBACnC;gBACF;gBAED,KAAK,QAAA,CAAS,CAACC,UAAS;oBACtB,MAAM,WAAW,OAAO,YAAA,CAAa,GAAA,CAAIA,KAAI;oBAE7C,IAAI,YAAY,MAAM;wBACpB,oBAAoB,GAAA,CAAIA,OAAM,QAAQ;oBACvC;gBACX,CAAS;gBAED,OAAO;YACR;YAED,OAAO,YAAA,GAAe,mBAAmB,KAAK;YAE9C,OAAO;QACb,CAAK;IACF;IAED,uBAAuB,IAAA,EAAM,aAAA,EAAe,cAAA,EAAgB,OAAA,EAAS,MAAA,EAAQ;QAC3E,MAAM,SAAS,CAAE,CAAA;QAEjB,MAAM,aAAa,KAAK,IAAA,GAAO,KAAK,IAAA,GAAO,KAAK,IAAA;QAChD,MAAM,cAAc,CAAE,CAAA;QAEtB,IAAI,eAAA,CAAgB,OAAO,IAAI,CAAA,KAAM,gBAAgB,OAAA,EAAS;YAC5D,KAAK,QAAA,CAAS,SAAU,MAAA,EAAQ;gBAC9B,IAAI,OAAO,qBAAA,EAAuB;oBAChC,YAAY,IAAA,CAAK,OAAO,IAAA,GAAO,OAAO,IAAA,GAAO,OAAO,IAAI;gBACzD;YACT,CAAO;QACP,OAAW;YACL,YAAY,IAAA,CAAK,UAAU;QAC5B;QAED,IAAI;QAEJ,OAAQ,eAAA,CAAgB,OAAO,IAAI,CAAA,EAAC;YAClC,KAAK,gBAAgB,OAAA;gBACnB,qBAAqB,6NAAA;gBACrB;YAEF,KAAK,gBAAgB,QAAA;gBACnB,qBAAqB,iOAAA;gBACrB;YAEF,KAAK,gBAAgB,QAAA;YACrB,KAAK,gBAAgB,KAAA;gBACnB,qBAAqB,6NAAA;gBACrB;YAEF;gBACE,OAAQ,eAAe,QAAA,EAAQ;oBAC7B,KAAK;wBACH,qBAAqB,6NAAA;wBACrB;oBACF,KAAK;oBACL,KAAK;oBACL;wBACE,qBAAqB,6NAAA;wBACrB;gBACH;gBAED;QACH;QAED,MAAM,gBAAgB,QAAQ,aAAA,KAAkB,KAAA,IAAY,aAAA,CAAc,QAAQ,aAAa,CAAA,GAAI,2NAAA;QAEnG,MAAM,cAAc,IAAA,CAAK,qBAAA,CAAsB,cAAc;QAE7D,IAAA,IAAS,IAAI,GAAG,KAAK,YAAY,MAAA,EAAQ,IAAI,IAAI,IAAK;YACpD,MAAM,QAAQ,IAAI,mBAChB,WAAA,CAAY,CAAC,CAAA,GAAI,MAAM,eAAA,CAAgB,OAAO,IAAI,CAAA,EAClD,cAAc,KAAA,EACd,aACA;YAIF,IAAI,QAAQ,aAAA,KAAkB,eAAe;gBAC3C,IAAA,CAAK,kCAAA,CAAmC,KAAK;YAC9C;YAED,OAAO,IAAA,CAAK,KAAK;QAClB;QAED,OAAO;IACR;IAED,sBAAsB,QAAA,EAAU;QAC9B,IAAI,cAAc,SAAS,KAAA;QAE3B,IAAI,SAAS,UAAA,EAAY;YACvB,MAAM,QAAQ,4BAA4B,YAAY,WAAW;YACjE,MAAM,SAAS,IAAI,aAAa,YAAY,MAAM;YAElD,IAAA,IAAS,IAAI,GAAG,KAAK,YAAY,MAAA,EAAQ,IAAI,IAAI,IAAK;gBACpD,MAAA,CAAO,CAAC,CAAA,GAAI,WAAA,CAAY,CAAC,CAAA,GAAI;YAC9B;YAED,cAAc;QACf;QAED,OAAO;IACR;IAED,mCAAmC,KAAA,EAAO;QACxC,MAAM,iBAAA,GAAoB,SAAS,wCAAwC,MAAA,EAAQ;YAKjF,MAAM,kBACJ,IAAA,YAAgB,iOAAA,GAA0B,uCAAuC;YAEnF,OAAO,IAAI,gBAAgB,IAAA,CAAK,KAAA,EAAO,IAAA,CAAK,MAAA,EAAQ,IAAA,CAAK,YAAA,CAAY,IAAK,GAAG,MAAM;QACpF;QAGD,MAAM,iBAAA,CAAkB,yCAAA,GAA4C;IACrE;AACH;AAOA,SAAS,cAAc,QAAA,EAAU,YAAA,EAAc,MAAA,EAAQ;IACrD,MAAM,aAAa,aAAa,UAAA;IAEhC,MAAM,MAAM,IAAI,8MAAA,CAAM;IAEtB,IAAI,WAAW,QAAA,KAAa,KAAA,GAAW;QACrC,MAAM,WAAW,OAAO,IAAA,CAAK,SAAA,CAAU,WAAW,QAAQ,CAAA;QAE1D,MAAM,MAAM,SAAS,GAAA;QACrB,MAAM,MAAM,SAAS,GAAA;QAIrB,IAAI,QAAQ,KAAA,KAAa,QAAQ,KAAA,GAAW;YAC1C,IAAI,GAAA,CAAI,IAAI,iNAAA,CAAQ,GAAA,CAAI,CAAC,CAAA,EAAG,GAAA,CAAI,CAAC,CAAA,EAAG,GAAA,CAAI,CAAC,CAAC,GAAG,IAAI,iNAAA,CAAQ,GAAA,CAAI,CAAC,CAAA,EAAG,GAAA,CAAI,CAAC,CAAA,EAAG,GAAA,CAAI,CAAC,CAAC,CAAC;YAEhF,IAAI,SAAS,UAAA,EAAY;gBACvB,MAAM,WAAW,4BAA4B,qBAAA,CAAsB,SAAS,aAAa,CAAC;gBAC1F,IAAI,GAAA,CAAI,cAAA,CAAe,QAAQ;gBAC/B,IAAI,GAAA,CAAI,cAAA,CAAe,QAAQ;YAChC;QACP,OAAW;YACL,QAAQ,IAAA,CAAK,qEAAqE;YAElF;QACD;IACL,OAAS;QACL;IACD;IAED,MAAM,UAAU,aAAa,OAAA;IAE7B,IAAI,YAAY,KAAA,GAAW;QACzB,MAAM,kBAAkB,IAAI,iNAAA,CAAS;QACrC,MAAM,SAAS,IAAI,iNAAA,CAAS;QAE5B,IAAA,IAAS,IAAI,GAAG,KAAK,QAAQ,MAAA,EAAQ,IAAI,IAAI,IAAK;YAChD,MAAM,SAAS,OAAA,CAAQ,CAAC,CAAA;YAExB,IAAI,OAAO,QAAA,KAAa,KAAA,GAAW;gBACjC,MAAM,WAAW,OAAO,IAAA,CAAK,SAAA,CAAU,OAAO,QAAQ,CAAA;gBACtD,MAAM,MAAM,SAAS,GAAA;gBACrB,MAAM,MAAM,SAAS,GAAA;gBAIrB,IAAI,QAAQ,KAAA,KAAa,QAAQ,KAAA,GAAW;oBAE1C,OAAO,IAAA,CAAK,KAAK,GAAA,CAAI,KAAK,GAAA,CAAI,GAAA,CAAI,CAAC,CAAC,GAAG,KAAK,GAAA,CAAI,GAAA,CAAI,CAAC,CAAC,CAAC,CAAC;oBACxD,OAAO,IAAA,CAAK,KAAK,GAAA,CAAI,KAAK,GAAA,CAAI,GAAA,CAAI,CAAC,CAAC,GAAG,KAAK,GAAA,CAAI,GAAA,CAAI,CAAC,CAAC,CAAC,CAAC;oBACxD,OAAO,IAAA,CAAK,KAAK,GAAA,CAAI,KAAK,GAAA,CAAI,GAAA,CAAI,CAAC,CAAC,GAAG,KAAK,GAAA,CAAI,GAAA,CAAI,CAAC,CAAC,CAAC,CAAC;oBAExD,IAAI,SAAS,UAAA,EAAY;wBACvB,MAAM,WAAW,4BAA4B,qBAAA,CAAsB,SAAS,aAAa,CAAC;wBAC1F,OAAO,cAAA,CAAe,QAAQ;oBAC/B;oBAMD,gBAAgB,GAAA,CAAI,MAAM;gBACpC,OAAe;oBACL,QAAQ,IAAA,CAAK,qEAAqE;gBACnF;YACF;QACF;QAGD,IAAI,cAAA,CAAe,eAAe;IACnC;IAED,SAAS,WAAA,GAAc;IAEvB,MAAM,SAAS,IAAI,gNAAA,CAAQ;IAE3B,IAAI,SAAA,CAAU,OAAO,MAAM;IAC3B,OAAO,MAAA,GAAS,IAAI,GAAA,CAAI,UAAA,CAAW,IAAI,GAAG,IAAI;IAE9C,SAAS,cAAA,GAAiB;AAC5B;AAQA,SAAS,uBAAuB,QAAA,EAAU,YAAA,EAAc,MAAA,EAAQ;IAC9D,MAAM,aAAa,aAAa,UAAA;IAEhC,MAAM,UAAU,CAAE,CAAA;IAElB,SAAS,wBAAwB,aAAA,EAAe,aAAA,EAAe;QAC7D,OAAO,OAAO,aAAA,CAAc,YAAY,aAAa,EAAE,IAAA,CAAK,SAAU,QAAA,EAAU;YAC9E,SAAS,YAAA,CAAa,eAAe,QAAQ;QACnD,CAAK;IACF;IAED,IAAA,MAAW,qBAAqB,WAAY;QAC1C,MAAM,qBAAqB,UAAA,CAAW,iBAAiB,CAAA,IAAK,kBAAkB,WAAA,CAAa;QAG3F,IAAI,sBAAsB,SAAS,UAAA,EAAY;QAE/C,QAAQ,IAAA,CAAK,wBAAwB,UAAA,CAAW,iBAAiB,CAAA,EAAG,kBAAkB,CAAC;IACxF;IAED,IAAI,aAAa,OAAA,KAAY,KAAA,KAAa,CAAC,SAAS,KAAA,EAAO;QACzD,MAAM,WAAW,OAAO,aAAA,CAAc,YAAY,aAAa,OAAO,EAAE,IAAA,CAAK,SAAUC,SAAAA,EAAU;YAC/F,SAAS,QAAA,CAASA,SAAQ;QAChC,CAAK;QAED,QAAQ,IAAA,CAAK,QAAQ;IACtB;IAED,uBAAuB,UAAU,YAAY;IAE7C,cAAc,UAAU,cAAc,MAAM;IAE5C,OAAO,QAAQ,GAAA,CAAI,OAAO,EAAE,IAAA,CAAK,WAAY;QAC3C,OAAO,aAAa,OAAA,KAAY,KAAA,IAAY,gBAAgB,UAAU,aAAa,OAAA,EAAS,MAAM,IAAI;IAC1G,CAAG;AACH","debugId":null}},
    {"offset": {"line": 4435, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/three-stdlib@2.36.1_three@0.182.0/node_modules/three-stdlib/loaders/DRACOLoader.js","sources":["file:///C:/coqueli/frontend/node_modules/.pnpm/three-stdlib%402.36.1_three%400.182.0/node_modules/src/loaders/DRACOLoader.js"],"sourcesContent":["import { BufferAttribute, BufferGeometry, FileLoader, Loader } from 'three'\n\nconst _taskCache = new WeakMap()\n\nclass DRACOLoader extends Loader {\n  constructor(manager) {\n    super(manager)\n\n    this.decoderPath = ''\n    this.decoderConfig = {}\n    this.decoderBinary = null\n    this.decoderPending = null\n\n    this.workerLimit = 4\n    this.workerPool = []\n    this.workerNextTaskID = 1\n    this.workerSourceURL = ''\n\n    this.defaultAttributeIDs = {\n      position: 'POSITION',\n      normal: 'NORMAL',\n      color: 'COLOR',\n      uv: 'TEX_COORD',\n    }\n    this.defaultAttributeTypes = {\n      position: 'Float32Array',\n      normal: 'Float32Array',\n      color: 'Float32Array',\n      uv: 'Float32Array',\n    }\n  }\n\n  setDecoderPath(path) {\n    this.decoderPath = path\n\n    return this\n  }\n\n  setDecoderConfig(config) {\n    this.decoderConfig = config\n\n    return this\n  }\n\n  setWorkerLimit(workerLimit) {\n    this.workerLimit = workerLimit\n\n    return this\n  }\n\n  load(url, onLoad, onProgress, onError) {\n    const loader = new FileLoader(this.manager)\n\n    loader.setPath(this.path)\n    loader.setResponseType('arraybuffer')\n    loader.setRequestHeader(this.requestHeader)\n    loader.setWithCredentials(this.withCredentials)\n\n    loader.load(\n      url,\n      (buffer) => {\n        const taskConfig = {\n          attributeIDs: this.defaultAttributeIDs,\n          attributeTypes: this.defaultAttributeTypes,\n          useUniqueIDs: false,\n        }\n\n        this.decodeGeometry(buffer, taskConfig).then(onLoad).catch(onError)\n      },\n      onProgress,\n      onError,\n    )\n  }\n\n  /** @deprecated Kept for backward-compatibility with previous DRACOLoader versions. */\n  decodeDracoFile(buffer, callback, attributeIDs, attributeTypes) {\n    const taskConfig = {\n      attributeIDs: attributeIDs || this.defaultAttributeIDs,\n      attributeTypes: attributeTypes || this.defaultAttributeTypes,\n      useUniqueIDs: !!attributeIDs,\n    }\n\n    this.decodeGeometry(buffer, taskConfig).then(callback)\n  }\n\n  decodeGeometry(buffer, taskConfig) {\n    // TODO: For backward-compatibility, support 'attributeTypes' objects containing\n    // references (rather than names) to typed array constructors. These must be\n    // serialized before sending them to the worker.\n    for (const attribute in taskConfig.attributeTypes) {\n      const type = taskConfig.attributeTypes[attribute]\n\n      if (type.BYTES_PER_ELEMENT !== undefined) {\n        taskConfig.attributeTypes[attribute] = type.name\n      }\n    }\n\n    //\n\n    const taskKey = JSON.stringify(taskConfig)\n\n    // Check for an existing task using this buffer. A transferred buffer cannot be transferred\n    // again from this thread.\n    if (_taskCache.has(buffer)) {\n      const cachedTask = _taskCache.get(buffer)\n\n      if (cachedTask.key === taskKey) {\n        return cachedTask.promise\n      } else if (buffer.byteLength === 0) {\n        // Technically, it would be possible to wait for the previous task to complete,\n        // transfer the buffer back, and decode again with the second configuration. That\n        // is complex, and I don't know of any reason to decode a Draco buffer twice in\n        // different ways, so this is left unimplemented.\n        throw new Error(\n          'THREE.DRACOLoader: Unable to re-decode a buffer with different ' +\n            'settings. Buffer has already been transferred.',\n        )\n      }\n    }\n\n    //\n\n    let worker\n    const taskID = this.workerNextTaskID++\n    const taskCost = buffer.byteLength\n\n    // Obtain a worker and assign a task, and construct a geometry instance\n    // when the task completes.\n    const geometryPending = this._getWorker(taskID, taskCost)\n      .then((_worker) => {\n        worker = _worker\n\n        return new Promise((resolve, reject) => {\n          worker._callbacks[taskID] = { resolve, reject }\n\n          worker.postMessage({ type: 'decode', id: taskID, taskConfig, buffer }, [buffer])\n\n          // this.debug();\n        })\n      })\n      .then((message) => this._createGeometry(message.geometry))\n\n    // Remove task from the task list.\n    // Note: replaced '.finally()' with '.catch().then()' block - iOS 11 support (#19416)\n    geometryPending\n      .catch(() => true)\n      .then(() => {\n        if (worker && taskID) {\n          this._releaseTask(worker, taskID)\n\n          // this.debug();\n        }\n      })\n\n    // Cache the task result.\n    _taskCache.set(buffer, {\n      key: taskKey,\n      promise: geometryPending,\n    })\n\n    return geometryPending\n  }\n\n  _createGeometry(geometryData) {\n    const geometry = new BufferGeometry()\n\n    if (geometryData.index) {\n      geometry.setIndex(new BufferAttribute(geometryData.index.array, 1))\n    }\n\n    for (let i = 0; i < geometryData.attributes.length; i++) {\n      const attribute = geometryData.attributes[i]\n      const name = attribute.name\n      const array = attribute.array\n      const itemSize = attribute.itemSize\n\n      geometry.setAttribute(name, new BufferAttribute(array, itemSize))\n    }\n\n    return geometry\n  }\n\n  _loadLibrary(url, responseType) {\n    const loader = new FileLoader(this.manager)\n    loader.setPath(this.decoderPath)\n    loader.setResponseType(responseType)\n    loader.setWithCredentials(this.withCredentials)\n\n    return new Promise((resolve, reject) => {\n      loader.load(url, resolve, undefined, reject)\n    })\n  }\n\n  preload() {\n    this._initDecoder()\n\n    return this\n  }\n\n  _initDecoder() {\n    if (this.decoderPending) return this.decoderPending\n\n    const useJS = typeof WebAssembly !== 'object' || this.decoderConfig.type === 'js'\n    const librariesPending = []\n\n    if (useJS) {\n      librariesPending.push(this._loadLibrary('draco_decoder.js', 'text'))\n    } else {\n      librariesPending.push(this._loadLibrary('draco_wasm_wrapper.js', 'text'))\n      librariesPending.push(this._loadLibrary('draco_decoder.wasm', 'arraybuffer'))\n    }\n\n    this.decoderPending = Promise.all(librariesPending).then((libraries) => {\n      const jsContent = libraries[0]\n\n      if (!useJS) {\n        this.decoderConfig.wasmBinary = libraries[1]\n      }\n\n      const fn = DRACOWorker.toString()\n\n      const body = [\n        '/* draco decoder */',\n        jsContent,\n        '',\n        '/* worker */',\n        fn.substring(fn.indexOf('{') + 1, fn.lastIndexOf('}')),\n      ].join('\\n')\n\n      this.workerSourceURL = URL.createObjectURL(new Blob([body]))\n    })\n\n    return this.decoderPending\n  }\n\n  _getWorker(taskID, taskCost) {\n    return this._initDecoder().then(() => {\n      if (this.workerPool.length < this.workerLimit) {\n        const worker = new Worker(this.workerSourceURL)\n\n        worker._callbacks = {}\n        worker._taskCosts = {}\n        worker._taskLoad = 0\n\n        worker.postMessage({ type: 'init', decoderConfig: this.decoderConfig })\n\n        worker.onmessage = function (e) {\n          const message = e.data\n\n          switch (message.type) {\n            case 'decode':\n              worker._callbacks[message.id].resolve(message)\n              break\n\n            case 'error':\n              worker._callbacks[message.id].reject(message)\n              break\n\n            default:\n              console.error('THREE.DRACOLoader: Unexpected message, \"' + message.type + '\"')\n          }\n        }\n\n        this.workerPool.push(worker)\n      } else {\n        this.workerPool.sort(function (a, b) {\n          return a._taskLoad > b._taskLoad ? -1 : 1\n        })\n      }\n\n      const worker = this.workerPool[this.workerPool.length - 1]\n      worker._taskCosts[taskID] = taskCost\n      worker._taskLoad += taskCost\n      return worker\n    })\n  }\n\n  _releaseTask(worker, taskID) {\n    worker._taskLoad -= worker._taskCosts[taskID]\n    delete worker._callbacks[taskID]\n    delete worker._taskCosts[taskID]\n  }\n\n  debug() {\n    console.log(\n      'Task load: ',\n      this.workerPool.map((worker) => worker._taskLoad),\n    )\n  }\n\n  dispose() {\n    for (let i = 0; i < this.workerPool.length; ++i) {\n      this.workerPool[i].terminate()\n    }\n\n    this.workerPool.length = 0\n\n    return this\n  }\n}\n\n/* WEB WORKER */\n\nfunction DRACOWorker() {\n  let decoderConfig\n  let decoderPending\n\n  onmessage = function (e) {\n    const message = e.data\n\n    switch (message.type) {\n      case 'init':\n        decoderConfig = message.decoderConfig\n        decoderPending = new Promise(function (resolve /*, reject*/) {\n          decoderConfig.onModuleLoaded = function (draco) {\n            // Module is Promise-like. Wrap before resolving to avoid loop.\n            resolve({ draco: draco })\n          }\n\n          DracoDecoderModule(decoderConfig)\n        })\n        break\n\n      case 'decode':\n        const buffer = message.buffer\n        const taskConfig = message.taskConfig\n        decoderPending.then((module) => {\n          const draco = module.draco\n          const decoder = new draco.Decoder()\n          const decoderBuffer = new draco.DecoderBuffer()\n          decoderBuffer.Init(new Int8Array(buffer), buffer.byteLength)\n\n          try {\n            const geometry = decodeGeometry(draco, decoder, decoderBuffer, taskConfig)\n\n            const buffers = geometry.attributes.map((attr) => attr.array.buffer)\n\n            if (geometry.index) buffers.push(geometry.index.array.buffer)\n\n            self.postMessage({ type: 'decode', id: message.id, geometry }, buffers)\n          } catch (error) {\n            console.error(error)\n\n            self.postMessage({ type: 'error', id: message.id, error: error.message })\n          } finally {\n            draco.destroy(decoderBuffer)\n            draco.destroy(decoder)\n          }\n        })\n        break\n    }\n  }\n\n  function decodeGeometry(draco, decoder, decoderBuffer, taskConfig) {\n    const attributeIDs = taskConfig.attributeIDs\n    const attributeTypes = taskConfig.attributeTypes\n\n    let dracoGeometry\n    let decodingStatus\n\n    const geometryType = decoder.GetEncodedGeometryType(decoderBuffer)\n\n    if (geometryType === draco.TRIANGULAR_MESH) {\n      dracoGeometry = new draco.Mesh()\n      decodingStatus = decoder.DecodeBufferToMesh(decoderBuffer, dracoGeometry)\n    } else if (geometryType === draco.POINT_CLOUD) {\n      dracoGeometry = new draco.PointCloud()\n      decodingStatus = decoder.DecodeBufferToPointCloud(decoderBuffer, dracoGeometry)\n    } else {\n      throw new Error('THREE.DRACOLoader: Unexpected geometry type.')\n    }\n\n    if (!decodingStatus.ok() || dracoGeometry.ptr === 0) {\n      throw new Error('THREE.DRACOLoader: Decoding failed: ' + decodingStatus.error_msg())\n    }\n\n    const geometry = { index: null, attributes: [] }\n\n    // Gather all vertex attributes.\n    for (const attributeName in attributeIDs) {\n      const attributeType = self[attributeTypes[attributeName]]\n\n      let attribute\n      let attributeID\n\n      // A Draco file may be created with default vertex attributes, whose attribute IDs\n      // are mapped 1:1 from their semantic name (POSITION, NORMAL, ...). Alternatively,\n      // a Draco file may contain a custom set of attributes, identified by known unique\n      // IDs. glTF files always do the latter, and `.drc` files typically do the former.\n      if (taskConfig.useUniqueIDs) {\n        attributeID = attributeIDs[attributeName]\n        attribute = decoder.GetAttributeByUniqueId(dracoGeometry, attributeID)\n      } else {\n        attributeID = decoder.GetAttributeId(dracoGeometry, draco[attributeIDs[attributeName]])\n\n        if (attributeID === -1) continue\n\n        attribute = decoder.GetAttribute(dracoGeometry, attributeID)\n      }\n\n      geometry.attributes.push(decodeAttribute(draco, decoder, dracoGeometry, attributeName, attributeType, attribute))\n    }\n\n    // Add index.\n    if (geometryType === draco.TRIANGULAR_MESH) {\n      geometry.index = decodeIndex(draco, decoder, dracoGeometry)\n    }\n\n    draco.destroy(dracoGeometry)\n\n    return geometry\n  }\n\n  function decodeIndex(draco, decoder, dracoGeometry) {\n    const numFaces = dracoGeometry.num_faces()\n    const numIndices = numFaces * 3\n    const byteLength = numIndices * 4\n\n    const ptr = draco._malloc(byteLength)\n    decoder.GetTrianglesUInt32Array(dracoGeometry, byteLength, ptr)\n    const index = new Uint32Array(draco.HEAPF32.buffer, ptr, numIndices).slice()\n    draco._free(ptr)\n\n    return { array: index, itemSize: 1 }\n  }\n\n  function decodeAttribute(draco, decoder, dracoGeometry, attributeName, attributeType, attribute) {\n    const numComponents = attribute.num_components()\n    const numPoints = dracoGeometry.num_points()\n    const numValues = numPoints * numComponents\n    const byteLength = numValues * attributeType.BYTES_PER_ELEMENT\n    const dataType = getDracoDataType(draco, attributeType)\n\n    const ptr = draco._malloc(byteLength)\n    decoder.GetAttributeDataArrayForAllPoints(dracoGeometry, attribute, dataType, byteLength, ptr)\n    const array = new attributeType(draco.HEAPF32.buffer, ptr, numValues).slice()\n    draco._free(ptr)\n\n    return {\n      name: attributeName,\n      array: array,\n      itemSize: numComponents,\n    }\n  }\n\n  function getDracoDataType(draco, attributeType) {\n    switch (attributeType) {\n      case Float32Array:\n        return draco.DT_FLOAT32\n      case Int8Array:\n        return draco.DT_INT8\n      case Int16Array:\n        return draco.DT_INT16\n      case Int32Array:\n        return draco.DT_INT32\n      case Uint8Array:\n        return draco.DT_UINT8\n      case Uint16Array:\n        return draco.DT_UINT16\n      case Uint32Array:\n        return draco.DT_UINT32\n    }\n  }\n}\n\nexport { DRACOLoader }\n"],"names":["worker"],"mappings":"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","debugId":null}},
    {"offset": {"line": 4801, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/three-stdlib@2.36.1_three@0.182.0/node_modules/three-stdlib/loaders/FBXLoader.js","sources":["file:///C:/coqueli/frontend/node_modules/.pnpm/three-stdlib%402.36.1_three%400.182.0/node_modules/src/loaders/FBXLoader.js"],"sourcesContent":["import {\n  AmbientLight,\n  AnimationClip,\n  Bone,\n  BufferGeometry,\n  ClampToEdgeWrapping,\n  Color,\n  DirectionalLight,\n  EquirectangularReflectionMapping,\n  Euler,\n  FileLoader,\n  Float32BufferAttribute,\n  Group,\n  Line,\n  LineBasicMaterial,\n  Loader,\n  LoaderUtils,\n  MathUtils,\n  Matrix3,\n  Matrix4,\n  Mesh,\n  MeshLambertMaterial,\n  MeshPhongMaterial,\n  NumberKeyframeTrack,\n  Object3D,\n  OrthographicCamera,\n  PerspectiveCamera,\n  PointLight,\n  PropertyBinding,\n  Quaternion,\n  QuaternionKeyframeTrack,\n  RepeatWrapping,\n  Skeleton,\n  SkinnedMesh,\n  SpotLight,\n  Texture,\n  TextureLoader,\n  Uint16BufferAttribute,\n  Vector3,\n  Vector4,\n  VectorKeyframeTrack,\n} from 'three'\nimport { unzlibSync } from 'fflate'\nimport { NURBSCurve } from '../curves/NURBSCurve'\nimport { decodeText } from '../_polyfill/LoaderUtils'\nimport { UV1 } from '../_polyfill/uv1'\n\n/**\n * Loader loads FBX file and generates Group representing FBX scene.\n * Requires FBX file to be >= 7.0 and in ASCII or >= 6400 in Binary format\n * Versions lower than this may load but will probably have errors\n *\n * Needs Support:\n *  Morph normals / blend shape normals\n *\n * FBX format references:\n * \thttps://help.autodesk.com/view/FBX/2017/ENU/?guid=__cpp_ref_index_html (C++ SDK reference)\n *\n * Binary format specification:\n *\thttps://code.blender.org/2013/08/fbx-binary-file-format-specification/\n */\n\nlet fbxTree\nlet connections\nlet sceneGraph\n\nclass FBXLoader extends Loader {\n  constructor(manager) {\n    super(manager)\n  }\n\n  load(url, onLoad, onProgress, onError) {\n    const scope = this\n\n    const path = scope.path === '' ? LoaderUtils.extractUrlBase(url) : scope.path\n\n    const loader = new FileLoader(this.manager)\n    loader.setPath(scope.path)\n    loader.setResponseType('arraybuffer')\n    loader.setRequestHeader(scope.requestHeader)\n    loader.setWithCredentials(scope.withCredentials)\n\n    loader.load(\n      url,\n      function (buffer) {\n        try {\n          onLoad(scope.parse(buffer, path))\n        } catch (e) {\n          if (onError) {\n            onError(e)\n          } else {\n            console.error(e)\n          }\n\n          scope.manager.itemError(url)\n        }\n      },\n      onProgress,\n      onError,\n    )\n  }\n\n  parse(FBXBuffer, path) {\n    if (isFbxFormatBinary(FBXBuffer)) {\n      fbxTree = new BinaryParser().parse(FBXBuffer)\n    } else {\n      const FBXText = convertArrayBufferToString(FBXBuffer)\n\n      if (!isFbxFormatASCII(FBXText)) {\n        throw new Error('THREE.FBXLoader: Unknown format.')\n      }\n\n      if (getFbxVersion(FBXText) < 7000) {\n        throw new Error('THREE.FBXLoader: FBX version not supported, FileVersion: ' + getFbxVersion(FBXText))\n      }\n\n      fbxTree = new TextParser().parse(FBXText)\n    }\n\n    // console.log( fbxTree );\n\n    const textureLoader = new TextureLoader(this.manager)\n      .setPath(this.resourcePath || path)\n      .setCrossOrigin(this.crossOrigin)\n\n    return new FBXTreeParser(textureLoader, this.manager).parse(fbxTree)\n  }\n}\n\n// Parse the FBXTree object returned by the BinaryParser or TextParser and return a Group\nclass FBXTreeParser {\n  constructor(textureLoader, manager) {\n    this.textureLoader = textureLoader\n    this.manager = manager\n  }\n\n  parse() {\n    connections = this.parseConnections()\n\n    const images = this.parseImages()\n    const textures = this.parseTextures(images)\n    const materials = this.parseMaterials(textures)\n    const deformers = this.parseDeformers()\n    const geometryMap = new GeometryParser().parse(deformers)\n\n    this.parseScene(deformers, geometryMap, materials)\n\n    return sceneGraph\n  }\n\n  // Parses FBXTree.Connections which holds parent-child connections between objects (e.g. material -> texture, model->geometry )\n  // and details the connection type\n  parseConnections() {\n    const connectionMap = new Map()\n\n    if ('Connections' in fbxTree) {\n      const rawConnections = fbxTree.Connections.connections\n\n      rawConnections.forEach(function (rawConnection) {\n        const fromID = rawConnection[0]\n        const toID = rawConnection[1]\n        const relationship = rawConnection[2]\n\n        if (!connectionMap.has(fromID)) {\n          connectionMap.set(fromID, {\n            parents: [],\n            children: [],\n          })\n        }\n\n        const parentRelationship = { ID: toID, relationship: relationship }\n        connectionMap.get(fromID).parents.push(parentRelationship)\n\n        if (!connectionMap.has(toID)) {\n          connectionMap.set(toID, {\n            parents: [],\n            children: [],\n          })\n        }\n\n        const childRelationship = { ID: fromID, relationship: relationship }\n        connectionMap.get(toID).children.push(childRelationship)\n      })\n    }\n\n    return connectionMap\n  }\n\n  // Parse FBXTree.Objects.Video for embedded image data\n  // These images are connected to textures in FBXTree.Objects.Textures\n  // via FBXTree.Connections.\n  parseImages() {\n    const images = {}\n    const blobs = {}\n\n    if ('Video' in fbxTree.Objects) {\n      const videoNodes = fbxTree.Objects.Video\n\n      for (const nodeID in videoNodes) {\n        const videoNode = videoNodes[nodeID]\n\n        const id = parseInt(nodeID)\n\n        images[id] = videoNode.RelativeFilename || videoNode.Filename\n\n        // raw image data is in videoNode.Content\n        if ('Content' in videoNode) {\n          const arrayBufferContent = videoNode.Content instanceof ArrayBuffer && videoNode.Content.byteLength > 0\n          const base64Content = typeof videoNode.Content === 'string' && videoNode.Content !== ''\n\n          if (arrayBufferContent || base64Content) {\n            const image = this.parseImage(videoNodes[nodeID])\n\n            blobs[videoNode.RelativeFilename || videoNode.Filename] = image\n          }\n        }\n      }\n    }\n\n    for (const id in images) {\n      const filename = images[id]\n\n      if (blobs[filename] !== undefined) images[id] = blobs[filename]\n      else images[id] = images[id].split('\\\\').pop()\n    }\n\n    return images\n  }\n\n  // Parse embedded image data in FBXTree.Video.Content\n  parseImage(videoNode) {\n    const content = videoNode.Content\n    const fileName = videoNode.RelativeFilename || videoNode.Filename\n    const extension = fileName.slice(fileName.lastIndexOf('.') + 1).toLowerCase()\n\n    let type\n\n    switch (extension) {\n      case 'bmp':\n        type = 'image/bmp'\n        break\n\n      case 'jpg':\n      case 'jpeg':\n        type = 'image/jpeg'\n        break\n\n      case 'png':\n        type = 'image/png'\n        break\n\n      case 'tif':\n        type = 'image/tiff'\n        break\n\n      case 'tga':\n        if (this.manager.getHandler('.tga') === null) {\n          console.warn('FBXLoader: TGA loader not found, skipping ', fileName)\n        }\n\n        type = 'image/tga'\n        break\n\n      default:\n        console.warn('FBXLoader: Image type \"' + extension + '\" is not supported.')\n        return\n    }\n\n    if (typeof content === 'string') {\n      // ASCII format\n\n      return 'data:' + type + ';base64,' + content\n    } else {\n      // Binary Format\n\n      const array = new Uint8Array(content)\n      return window.URL.createObjectURL(new Blob([array], { type: type }))\n    }\n  }\n\n  // Parse nodes in FBXTree.Objects.Texture\n  // These contain details such as UV scaling, cropping, rotation etc and are connected\n  // to images in FBXTree.Objects.Video\n  parseTextures(images) {\n    const textureMap = new Map()\n\n    if ('Texture' in fbxTree.Objects) {\n      const textureNodes = fbxTree.Objects.Texture\n      for (const nodeID in textureNodes) {\n        const texture = this.parseTexture(textureNodes[nodeID], images)\n        textureMap.set(parseInt(nodeID), texture)\n      }\n    }\n\n    return textureMap\n  }\n\n  // Parse individual node in FBXTree.Objects.Texture\n  parseTexture(textureNode, images) {\n    const texture = this.loadTexture(textureNode, images)\n\n    texture.ID = textureNode.id\n\n    texture.name = textureNode.attrName\n\n    const wrapModeU = textureNode.WrapModeU\n    const wrapModeV = textureNode.WrapModeV\n\n    const valueU = wrapModeU !== undefined ? wrapModeU.value : 0\n    const valueV = wrapModeV !== undefined ? wrapModeV.value : 0\n\n    // http://download.autodesk.com/us/fbx/SDKdocs/FBX_SDK_Help/files/fbxsdkref/class_k_fbx_texture.html#889640e63e2e681259ea81061b85143a\n    // 0: repeat(default), 1: clamp\n\n    texture.wrapS = valueU === 0 ? RepeatWrapping : ClampToEdgeWrapping\n    texture.wrapT = valueV === 0 ? RepeatWrapping : ClampToEdgeWrapping\n\n    if ('Scaling' in textureNode) {\n      const values = textureNode.Scaling.value\n\n      texture.repeat.x = values[0]\n      texture.repeat.y = values[1]\n    }\n\n    return texture\n  }\n\n  // load a texture specified as a blob or data URI, or via an external URL using TextureLoader\n  loadTexture(textureNode, images) {\n    let fileName\n\n    const currentPath = this.textureLoader.path\n\n    const children = connections.get(textureNode.id).children\n\n    if (children !== undefined && children.length > 0 && images[children[0].ID] !== undefined) {\n      fileName = images[children[0].ID]\n\n      if (fileName.indexOf('blob:') === 0 || fileName.indexOf('data:') === 0) {\n        this.textureLoader.setPath(undefined)\n      }\n    }\n\n    let texture\n\n    const extension = textureNode.FileName.slice(-3).toLowerCase()\n\n    if (extension === 'tga') {\n      const loader = this.manager.getHandler('.tga')\n\n      if (loader === null) {\n        console.warn('FBXLoader: TGA loader not found, creating placeholder texture for', textureNode.RelativeFilename)\n        texture = new Texture()\n      } else {\n        loader.setPath(this.textureLoader.path)\n        texture = loader.load(fileName)\n      }\n    } else if (extension === 'psd') {\n      console.warn(\n        'FBXLoader: PSD textures are not supported, creating placeholder texture for',\n        textureNode.RelativeFilename,\n      )\n      texture = new Texture()\n    } else {\n      texture = this.textureLoader.load(fileName)\n    }\n\n    this.textureLoader.setPath(currentPath)\n\n    return texture\n  }\n\n  // Parse nodes in FBXTree.Objects.Material\n  parseMaterials(textureMap) {\n    const materialMap = new Map()\n\n    if ('Material' in fbxTree.Objects) {\n      const materialNodes = fbxTree.Objects.Material\n\n      for (const nodeID in materialNodes) {\n        const material = this.parseMaterial(materialNodes[nodeID], textureMap)\n\n        if (material !== null) materialMap.set(parseInt(nodeID), material)\n      }\n    }\n\n    return materialMap\n  }\n\n  // Parse single node in FBXTree.Objects.Material\n  // Materials are connected to texture maps in FBXTree.Objects.Textures\n  // FBX format currently only supports Lambert and Phong shading models\n  parseMaterial(materialNode, textureMap) {\n    const ID = materialNode.id\n    const name = materialNode.attrName\n    let type = materialNode.ShadingModel\n\n    // Case where FBX wraps shading model in property object.\n    if (typeof type === 'object') {\n      type = type.value\n    }\n\n    // Ignore unused materials which don't have any connections.\n    if (!connections.has(ID)) return null\n\n    const parameters = this.parseParameters(materialNode, textureMap, ID)\n\n    let material\n\n    switch (type.toLowerCase()) {\n      case 'phong':\n        material = new MeshPhongMaterial()\n        break\n      case 'lambert':\n        material = new MeshLambertMaterial()\n        break\n      default:\n        console.warn('THREE.FBXLoader: unknown material type \"%s\". Defaulting to MeshPhongMaterial.', type)\n        material = new MeshPhongMaterial()\n        break\n    }\n\n    material.setValues(parameters)\n    material.name = name\n\n    return material\n  }\n\n  // Parse FBX material and return parameters suitable for a three.js material\n  // Also parse the texture map and return any textures associated with the material\n  parseParameters(materialNode, textureMap, ID) {\n    const parameters = {}\n\n    if (materialNode.BumpFactor) {\n      parameters.bumpScale = materialNode.BumpFactor.value\n    }\n\n    if (materialNode.Diffuse) {\n      parameters.color = new Color().fromArray(materialNode.Diffuse.value)\n    } else if (\n      materialNode.DiffuseColor &&\n      (materialNode.DiffuseColor.type === 'Color' || materialNode.DiffuseColor.type === 'ColorRGB')\n    ) {\n      // The blender exporter exports diffuse here instead of in materialNode.Diffuse\n      parameters.color = new Color().fromArray(materialNode.DiffuseColor.value)\n    }\n\n    if (materialNode.DisplacementFactor) {\n      parameters.displacementScale = materialNode.DisplacementFactor.value\n    }\n\n    if (materialNode.Emissive) {\n      parameters.emissive = new Color().fromArray(materialNode.Emissive.value)\n    } else if (\n      materialNode.EmissiveColor &&\n      (materialNode.EmissiveColor.type === 'Color' || materialNode.EmissiveColor.type === 'ColorRGB')\n    ) {\n      // The blender exporter exports emissive color here instead of in materialNode.Emissive\n      parameters.emissive = new Color().fromArray(materialNode.EmissiveColor.value)\n    }\n\n    if (materialNode.EmissiveFactor) {\n      parameters.emissiveIntensity = parseFloat(materialNode.EmissiveFactor.value)\n    }\n\n    if (materialNode.Opacity) {\n      parameters.opacity = parseFloat(materialNode.Opacity.value)\n    }\n\n    if (parameters.opacity < 1.0) {\n      parameters.transparent = true\n    }\n\n    if (materialNode.ReflectionFactor) {\n      parameters.reflectivity = materialNode.ReflectionFactor.value\n    }\n\n    if (materialNode.Shininess) {\n      parameters.shininess = materialNode.Shininess.value\n    }\n\n    if (materialNode.Specular) {\n      parameters.specular = new Color().fromArray(materialNode.Specular.value)\n    } else if (materialNode.SpecularColor && materialNode.SpecularColor.type === 'Color') {\n      // The blender exporter exports specular color here instead of in materialNode.Specular\n      parameters.specular = new Color().fromArray(materialNode.SpecularColor.value)\n    }\n\n    const scope = this\n    connections.get(ID).children.forEach(function (child) {\n      const type = child.relationship\n\n      switch (type) {\n        case 'Bump':\n          parameters.bumpMap = scope.getTexture(textureMap, child.ID)\n          break\n\n        case 'Maya|TEX_ao_map':\n          parameters.aoMap = scope.getTexture(textureMap, child.ID)\n          break\n\n        case 'DiffuseColor':\n        case 'Maya|TEX_color_map':\n          parameters.map = scope.getTexture(textureMap, child.ID)\n          if (parameters.map !== undefined) {\n            if ('colorSpace' in parameters.map) parameters.map.colorSpace = 'srgb'\n            else parameters.map.encoding = 3001 // sRGBEncoding\n          }\n\n          break\n\n        case 'DisplacementColor':\n          parameters.displacementMap = scope.getTexture(textureMap, child.ID)\n          break\n\n        case 'EmissiveColor':\n          parameters.emissiveMap = scope.getTexture(textureMap, child.ID)\n          if (parameters.emissiveMap !== undefined) {\n            if ('colorSpace' in parameters.emissiveMap) parameters.emissiveMap.colorSpace = 'srgb'\n            else parameters.emissiveMap.encoding = 3001 // sRGBEncoding\n          }\n\n          break\n\n        case 'NormalMap':\n        case 'Maya|TEX_normal_map':\n          parameters.normalMap = scope.getTexture(textureMap, child.ID)\n          break\n\n        case 'ReflectionColor':\n          parameters.envMap = scope.getTexture(textureMap, child.ID)\n          if (parameters.envMap !== undefined) {\n            parameters.envMap.mapping = EquirectangularReflectionMapping\n\n            if ('colorSpace' in parameters.envMap) parameters.envMap.colorSpace = 'srgb'\n            else parameters.envMap.encoding = 3001 // sRGBEncoding\n          }\n\n          break\n\n        case 'SpecularColor':\n          parameters.specularMap = scope.getTexture(textureMap, child.ID)\n          if (parameters.specularMap !== undefined) {\n            if ('colorSpace' in parameters.specularMap) parameters.specularMap.colorSpace = 'srgb'\n            else parameters.specularMap.encoding = 3001 // sRGBEncoding\n          }\n\n          break\n\n        case 'TransparentColor':\n        case 'TransparencyFactor':\n          parameters.alphaMap = scope.getTexture(textureMap, child.ID)\n          parameters.transparent = true\n          break\n\n        case 'AmbientColor':\n        case 'ShininessExponent': // AKA glossiness map\n        case 'SpecularFactor': // AKA specularLevel\n        case 'VectorDisplacementColor': // NOTE: Seems to be a copy of DisplacementColor\n        default:\n          console.warn('THREE.FBXLoader: %s map is not supported in three.js, skipping texture.', type)\n          break\n      }\n    })\n\n    return parameters\n  }\n\n  // get a texture from the textureMap for use by a material.\n  getTexture(textureMap, id) {\n    // if the texture is a layered texture, just use the first layer and issue a warning\n    if ('LayeredTexture' in fbxTree.Objects && id in fbxTree.Objects.LayeredTexture) {\n      console.warn('THREE.FBXLoader: layered textures are not supported in three.js. Discarding all but first layer.')\n      id = connections.get(id).children[0].ID\n    }\n\n    return textureMap.get(id)\n  }\n\n  // Parse nodes in FBXTree.Objects.Deformer\n  // Deformer node can contain skinning or Vertex Cache animation data, however only skinning is supported here\n  // Generates map of Skeleton-like objects for use later when generating and binding skeletons.\n  parseDeformers() {\n    const skeletons = {}\n    const morphTargets = {}\n\n    if ('Deformer' in fbxTree.Objects) {\n      const DeformerNodes = fbxTree.Objects.Deformer\n\n      for (const nodeID in DeformerNodes) {\n        const deformerNode = DeformerNodes[nodeID]\n\n        const relationships = connections.get(parseInt(nodeID))\n\n        if (deformerNode.attrType === 'Skin') {\n          const skeleton = this.parseSkeleton(relationships, DeformerNodes)\n          skeleton.ID = nodeID\n\n          if (relationships.parents.length > 1) {\n            console.warn('THREE.FBXLoader: skeleton attached to more than one geometry is not supported.')\n          }\n          skeleton.geometryID = relationships.parents[0].ID\n\n          skeletons[nodeID] = skeleton\n        } else if (deformerNode.attrType === 'BlendShape') {\n          const morphTarget = {\n            id: nodeID,\n          }\n\n          morphTarget.rawTargets = this.parseMorphTargets(relationships, DeformerNodes)\n          morphTarget.id = nodeID\n\n          if (relationships.parents.length > 1) {\n            console.warn('THREE.FBXLoader: morph target attached to more than one geometry is not supported.')\n          }\n\n          morphTargets[nodeID] = morphTarget\n        }\n      }\n    }\n\n    return {\n      skeletons: skeletons,\n      morphTargets: morphTargets,\n    }\n  }\n\n  // Parse single nodes in FBXTree.Objects.Deformer\n  // The top level skeleton node has type 'Skin' and sub nodes have type 'Cluster'\n  // Each skin node represents a skeleton and each cluster node represents a bone\n  parseSkeleton(relationships, deformerNodes) {\n    const rawBones = []\n\n    relationships.children.forEach(function (child) {\n      const boneNode = deformerNodes[child.ID]\n\n      if (boneNode.attrType !== 'Cluster') return\n\n      const rawBone = {\n        ID: child.ID,\n        indices: [],\n        weights: [],\n        transformLink: new Matrix4().fromArray(boneNode.TransformLink.a),\n        // transform: new Matrix4().fromArray( boneNode.Transform.a ),\n        // linkMode: boneNode.Mode,\n      }\n\n      if ('Indexes' in boneNode) {\n        rawBone.indices = boneNode.Indexes.a\n        rawBone.weights = boneNode.Weights.a\n      }\n\n      rawBones.push(rawBone)\n    })\n\n    return {\n      rawBones: rawBones,\n      bones: [],\n    }\n  }\n\n  // The top level morph deformer node has type \"BlendShape\" and sub nodes have type \"BlendShapeChannel\"\n  parseMorphTargets(relationships, deformerNodes) {\n    const rawMorphTargets = []\n\n    for (let i = 0; i < relationships.children.length; i++) {\n      const child = relationships.children[i]\n\n      const morphTargetNode = deformerNodes[child.ID]\n\n      const rawMorphTarget = {\n        name: morphTargetNode.attrName,\n        initialWeight: morphTargetNode.DeformPercent,\n        id: morphTargetNode.id,\n        fullWeights: morphTargetNode.FullWeights.a,\n      }\n\n      if (morphTargetNode.attrType !== 'BlendShapeChannel') return\n\n      rawMorphTarget.geoID = connections.get(parseInt(child.ID)).children.filter(function (child) {\n        return child.relationship === undefined\n      })[0].ID\n\n      rawMorphTargets.push(rawMorphTarget)\n    }\n\n    return rawMorphTargets\n  }\n\n  // create the main Group() to be returned by the loader\n  parseScene(deformers, geometryMap, materialMap) {\n    sceneGraph = new Group()\n\n    const modelMap = this.parseModels(deformers.skeletons, geometryMap, materialMap)\n\n    const modelNodes = fbxTree.Objects.Model\n\n    const scope = this\n    modelMap.forEach(function (model) {\n      const modelNode = modelNodes[model.ID]\n      scope.setLookAtProperties(model, modelNode)\n\n      const parentConnections = connections.get(model.ID).parents\n\n      parentConnections.forEach(function (connection) {\n        const parent = modelMap.get(connection.ID)\n        if (parent !== undefined) parent.add(model)\n      })\n\n      if (model.parent === null) {\n        sceneGraph.add(model)\n      }\n    })\n\n    this.bindSkeleton(deformers.skeletons, geometryMap, modelMap)\n\n    this.createAmbientLight()\n\n    sceneGraph.traverse(function (node) {\n      if (node.userData.transformData) {\n        if (node.parent) {\n          node.userData.transformData.parentMatrix = node.parent.matrix\n          node.userData.transformData.parentMatrixWorld = node.parent.matrixWorld\n        }\n\n        const transform = generateTransform(node.userData.transformData)\n\n        node.applyMatrix4(transform)\n        node.updateWorldMatrix()\n      }\n    })\n\n    const animations = new AnimationParser().parse()\n\n    // if all the models where already combined in a single group, just return that\n    if (sceneGraph.children.length === 1 && sceneGraph.children[0].isGroup) {\n      sceneGraph.children[0].animations = animations\n      sceneGraph = sceneGraph.children[0]\n    }\n\n    sceneGraph.animations = animations\n  }\n\n  // parse nodes in FBXTree.Objects.Model\n  parseModels(skeletons, geometryMap, materialMap) {\n    const modelMap = new Map()\n    const modelNodes = fbxTree.Objects.Model\n\n    for (const nodeID in modelNodes) {\n      const id = parseInt(nodeID)\n      const node = modelNodes[nodeID]\n      const relationships = connections.get(id)\n\n      let model = this.buildSkeleton(relationships, skeletons, id, node.attrName)\n\n      if (!model) {\n        switch (node.attrType) {\n          case 'Camera':\n            model = this.createCamera(relationships)\n            break\n          case 'Light':\n            model = this.createLight(relationships)\n            break\n          case 'Mesh':\n            model = this.createMesh(relationships, geometryMap, materialMap)\n            break\n          case 'NurbsCurve':\n            model = this.createCurve(relationships, geometryMap)\n            break\n          case 'LimbNode':\n          case 'Root':\n            model = new Bone()\n            break\n          case 'Null':\n          default:\n            model = new Group()\n            break\n        }\n\n        model.name = node.attrName ? PropertyBinding.sanitizeNodeName(node.attrName) : ''\n\n        model.ID = id\n      }\n\n      this.getTransformData(model, node)\n      modelMap.set(id, model)\n    }\n\n    return modelMap\n  }\n\n  buildSkeleton(relationships, skeletons, id, name) {\n    let bone = null\n\n    relationships.parents.forEach(function (parent) {\n      for (const ID in skeletons) {\n        const skeleton = skeletons[ID]\n\n        skeleton.rawBones.forEach(function (rawBone, i) {\n          if (rawBone.ID === parent.ID) {\n            const subBone = bone\n            bone = new Bone()\n\n            bone.matrixWorld.copy(rawBone.transformLink)\n\n            // set name and id here - otherwise in cases where \"subBone\" is created it will not have a name / id\n\n            bone.name = name ? PropertyBinding.sanitizeNodeName(name) : ''\n            bone.ID = id\n\n            skeleton.bones[i] = bone\n\n            // In cases where a bone is shared between multiple meshes\n            // duplicate the bone here and and it as a child of the first bone\n            if (subBone !== null) {\n              bone.add(subBone)\n            }\n          }\n        })\n      }\n    })\n\n    return bone\n  }\n\n  // create a PerspectiveCamera or OrthographicCamera\n  createCamera(relationships) {\n    let model\n    let cameraAttribute\n\n    relationships.children.forEach(function (child) {\n      const attr = fbxTree.Objects.NodeAttribute[child.ID]\n\n      if (attr !== undefined) {\n        cameraAttribute = attr\n      }\n    })\n\n    if (cameraAttribute === undefined) {\n      model = new Object3D()\n    } else {\n      let type = 0\n      if (cameraAttribute.CameraProjectionType !== undefined && cameraAttribute.CameraProjectionType.value === 1) {\n        type = 1\n      }\n\n      let nearClippingPlane = 1\n      if (cameraAttribute.NearPlane !== undefined) {\n        nearClippingPlane = cameraAttribute.NearPlane.value / 1000\n      }\n\n      let farClippingPlane = 1000\n      if (cameraAttribute.FarPlane !== undefined) {\n        farClippingPlane = cameraAttribute.FarPlane.value / 1000\n      }\n\n      let width = window.innerWidth\n      let height = window.innerHeight\n\n      if (cameraAttribute.AspectWidth !== undefined && cameraAttribute.AspectHeight !== undefined) {\n        width = cameraAttribute.AspectWidth.value\n        height = cameraAttribute.AspectHeight.value\n      }\n\n      const aspect = width / height\n\n      let fov = 45\n      if (cameraAttribute.FieldOfView !== undefined) {\n        fov = cameraAttribute.FieldOfView.value\n      }\n\n      const focalLength = cameraAttribute.FocalLength ? cameraAttribute.FocalLength.value : null\n\n      switch (type) {\n        case 0: // Perspective\n          model = new PerspectiveCamera(fov, aspect, nearClippingPlane, farClippingPlane)\n          if (focalLength !== null) model.setFocalLength(focalLength)\n          break\n\n        case 1: // Orthographic\n          model = new OrthographicCamera(\n            -width / 2,\n            width / 2,\n            height / 2,\n            -height / 2,\n            nearClippingPlane,\n            farClippingPlane,\n          )\n          break\n\n        default:\n          console.warn('THREE.FBXLoader: Unknown camera type ' + type + '.')\n          model = new Object3D()\n          break\n      }\n    }\n\n    return model\n  }\n\n  // Create a DirectionalLight, PointLight or SpotLight\n  createLight(relationships) {\n    let model\n    let lightAttribute\n\n    relationships.children.forEach(function (child) {\n      const attr = fbxTree.Objects.NodeAttribute[child.ID]\n\n      if (attr !== undefined) {\n        lightAttribute = attr\n      }\n    })\n\n    if (lightAttribute === undefined) {\n      model = new Object3D()\n    } else {\n      let type\n\n      // LightType can be undefined for Point lights\n      if (lightAttribute.LightType === undefined) {\n        type = 0\n      } else {\n        type = lightAttribute.LightType.value\n      }\n\n      let color = 0xffffff\n\n      if (lightAttribute.Color !== undefined) {\n        color = new Color().fromArray(lightAttribute.Color.value)\n      }\n\n      let intensity = lightAttribute.Intensity === undefined ? 1 : lightAttribute.Intensity.value / 100\n\n      // light disabled\n      if (lightAttribute.CastLightOnObject !== undefined && lightAttribute.CastLightOnObject.value === 0) {\n        intensity = 0\n      }\n\n      let distance = 0\n      if (lightAttribute.FarAttenuationEnd !== undefined) {\n        if (lightAttribute.EnableFarAttenuation !== undefined && lightAttribute.EnableFarAttenuation.value === 0) {\n          distance = 0\n        } else {\n          distance = lightAttribute.FarAttenuationEnd.value\n        }\n      }\n\n      // TODO: could this be calculated linearly from FarAttenuationStart to FarAttenuationEnd?\n      const decay = 1\n\n      switch (type) {\n        case 0: // Point\n          model = new PointLight(color, intensity, distance, decay)\n          break\n\n        case 1: // Directional\n          model = new DirectionalLight(color, intensity)\n          break\n\n        case 2: // Spot\n          let angle = Math.PI / 3\n\n          if (lightAttribute.InnerAngle !== undefined) {\n            angle = MathUtils.degToRad(lightAttribute.InnerAngle.value)\n          }\n\n          let penumbra = 0\n          if (lightAttribute.OuterAngle !== undefined) {\n            // TODO: this is not correct - FBX calculates outer and inner angle in degrees\n            // with OuterAngle > InnerAngle && OuterAngle <= Math.PI\n            // while three.js uses a penumbra between (0, 1) to attenuate the inner angle\n            penumbra = MathUtils.degToRad(lightAttribute.OuterAngle.value)\n            penumbra = Math.max(penumbra, 1)\n          }\n\n          model = new SpotLight(color, intensity, distance, angle, penumbra, decay)\n          break\n\n        default:\n          console.warn(\n            'THREE.FBXLoader: Unknown light type ' + lightAttribute.LightType.value + ', defaulting to a PointLight.',\n          )\n          model = new PointLight(color, intensity)\n          break\n      }\n\n      if (lightAttribute.CastShadows !== undefined && lightAttribute.CastShadows.value === 1) {\n        model.castShadow = true\n      }\n    }\n\n    return model\n  }\n\n  createMesh(relationships, geometryMap, materialMap) {\n    let model\n    let geometry = null\n    let material = null\n    const materials = []\n\n    // get geometry and materials(s) from connections\n    relationships.children.forEach(function (child) {\n      if (geometryMap.has(child.ID)) {\n        geometry = geometryMap.get(child.ID)\n      }\n\n      if (materialMap.has(child.ID)) {\n        materials.push(materialMap.get(child.ID))\n      }\n    })\n\n    if (materials.length > 1) {\n      material = materials\n    } else if (materials.length > 0) {\n      material = materials[0]\n    } else {\n      material = new MeshPhongMaterial({ color: 0xcccccc })\n      materials.push(material)\n    }\n\n    if ('color' in geometry.attributes) {\n      materials.forEach(function (material) {\n        material.vertexColors = true\n      })\n    }\n\n    if (geometry.FBX_Deformer) {\n      model = new SkinnedMesh(geometry, material)\n      model.normalizeSkinWeights()\n    } else {\n      model = new Mesh(geometry, material)\n    }\n\n    return model\n  }\n\n  createCurve(relationships, geometryMap) {\n    const geometry = relationships.children.reduce(function (geo, child) {\n      if (geometryMap.has(child.ID)) geo = geometryMap.get(child.ID)\n\n      return geo\n    }, null)\n\n    // FBX does not list materials for Nurbs lines, so we'll just put our own in here.\n    const material = new LineBasicMaterial({ color: 0x3300ff, linewidth: 1 })\n    return new Line(geometry, material)\n  }\n\n  // parse the model node for transform data\n  getTransformData(model, modelNode) {\n    const transformData = {}\n\n    if ('InheritType' in modelNode) transformData.inheritType = parseInt(modelNode.InheritType.value)\n\n    if ('RotationOrder' in modelNode) transformData.eulerOrder = getEulerOrder(modelNode.RotationOrder.value)\n    else transformData.eulerOrder = 'ZYX'\n\n    if ('Lcl_Translation' in modelNode) transformData.translation = modelNode.Lcl_Translation.value\n\n    if ('PreRotation' in modelNode) transformData.preRotation = modelNode.PreRotation.value\n    if ('Lcl_Rotation' in modelNode) transformData.rotation = modelNode.Lcl_Rotation.value\n    if ('PostRotation' in modelNode) transformData.postRotation = modelNode.PostRotation.value\n\n    if ('Lcl_Scaling' in modelNode) transformData.scale = modelNode.Lcl_Scaling.value\n\n    if ('ScalingOffset' in modelNode) transformData.scalingOffset = modelNode.ScalingOffset.value\n    if ('ScalingPivot' in modelNode) transformData.scalingPivot = modelNode.ScalingPivot.value\n\n    if ('RotationOffset' in modelNode) transformData.rotationOffset = modelNode.RotationOffset.value\n    if ('RotationPivot' in modelNode) transformData.rotationPivot = modelNode.RotationPivot.value\n\n    model.userData.transformData = transformData\n  }\n\n  setLookAtProperties(model, modelNode) {\n    if ('LookAtProperty' in modelNode) {\n      const children = connections.get(model.ID).children\n\n      children.forEach(function (child) {\n        if (child.relationship === 'LookAtProperty') {\n          const lookAtTarget = fbxTree.Objects.Model[child.ID]\n\n          if ('Lcl_Translation' in lookAtTarget) {\n            const pos = lookAtTarget.Lcl_Translation.value\n\n            // DirectionalLight, SpotLight\n            if (model.target !== undefined) {\n              model.target.position.fromArray(pos)\n              sceneGraph.add(model.target)\n            } else {\n              // Cameras and other Object3Ds\n\n              model.lookAt(new Vector3().fromArray(pos))\n            }\n          }\n        }\n      })\n    }\n  }\n\n  bindSkeleton(skeletons, geometryMap, modelMap) {\n    const bindMatrices = this.parsePoseNodes()\n\n    for (const ID in skeletons) {\n      const skeleton = skeletons[ID]\n\n      const parents = connections.get(parseInt(skeleton.ID)).parents\n\n      parents.forEach(function (parent) {\n        if (geometryMap.has(parent.ID)) {\n          const geoID = parent.ID\n          const geoRelationships = connections.get(geoID)\n\n          geoRelationships.parents.forEach(function (geoConnParent) {\n            if (modelMap.has(geoConnParent.ID)) {\n              const model = modelMap.get(geoConnParent.ID)\n\n              model.bind(new Skeleton(skeleton.bones), bindMatrices[geoConnParent.ID])\n            }\n          })\n        }\n      })\n    }\n  }\n\n  parsePoseNodes() {\n    const bindMatrices = {}\n\n    if ('Pose' in fbxTree.Objects) {\n      const BindPoseNode = fbxTree.Objects.Pose\n\n      for (const nodeID in BindPoseNode) {\n        if (BindPoseNode[nodeID].attrType === 'BindPose' && BindPoseNode[nodeID].NbPoseNodes > 0) {\n          const poseNodes = BindPoseNode[nodeID].PoseNode\n\n          if (Array.isArray(poseNodes)) {\n            poseNodes.forEach(function (poseNode) {\n              bindMatrices[poseNode.Node] = new Matrix4().fromArray(poseNode.Matrix.a)\n            })\n          } else {\n            bindMatrices[poseNodes.Node] = new Matrix4().fromArray(poseNodes.Matrix.a)\n          }\n        }\n      }\n    }\n\n    return bindMatrices\n  }\n\n  // Parse ambient color in FBXTree.GlobalSettings - if it's not set to black (default), create an ambient light\n  createAmbientLight() {\n    if ('GlobalSettings' in fbxTree && 'AmbientColor' in fbxTree.GlobalSettings) {\n      const ambientColor = fbxTree.GlobalSettings.AmbientColor.value\n      const r = ambientColor[0]\n      const g = ambientColor[1]\n      const b = ambientColor[2]\n\n      if (r !== 0 || g !== 0 || b !== 0) {\n        const color = new Color(r, g, b)\n        sceneGraph.add(new AmbientLight(color, 1))\n      }\n    }\n  }\n}\n\n// parse Geometry data from FBXTree and return map of BufferGeometries\nclass GeometryParser {\n  // Parse nodes in FBXTree.Objects.Geometry\n  parse(deformers) {\n    const geometryMap = new Map()\n\n    if ('Geometry' in fbxTree.Objects) {\n      const geoNodes = fbxTree.Objects.Geometry\n\n      for (const nodeID in geoNodes) {\n        const relationships = connections.get(parseInt(nodeID))\n        const geo = this.parseGeometry(relationships, geoNodes[nodeID], deformers)\n\n        geometryMap.set(parseInt(nodeID), geo)\n      }\n    }\n\n    return geometryMap\n  }\n\n  // Parse single node in FBXTree.Objects.Geometry\n  parseGeometry(relationships, geoNode, deformers) {\n    switch (geoNode.attrType) {\n      case 'Mesh':\n        return this.parseMeshGeometry(relationships, geoNode, deformers)\n        break\n\n      case 'NurbsCurve':\n        return this.parseNurbsGeometry(geoNode)\n        break\n    }\n  }\n\n  // Parse single node mesh geometry in FBXTree.Objects.Geometry\n  parseMeshGeometry(relationships, geoNode, deformers) {\n    const skeletons = deformers.skeletons\n    const morphTargets = []\n\n    const modelNodes = relationships.parents.map(function (parent) {\n      return fbxTree.Objects.Model[parent.ID]\n    })\n\n    // don't create geometry if it is not associated with any models\n    if (modelNodes.length === 0) return\n\n    const skeleton = relationships.children.reduce(function (skeleton, child) {\n      if (skeletons[child.ID] !== undefined) skeleton = skeletons[child.ID]\n\n      return skeleton\n    }, null)\n\n    relationships.children.forEach(function (child) {\n      if (deformers.morphTargets[child.ID] !== undefined) {\n        morphTargets.push(deformers.morphTargets[child.ID])\n      }\n    })\n\n    // Assume one model and get the preRotation from that\n    // if there is more than one model associated with the geometry this may cause problems\n    const modelNode = modelNodes[0]\n\n    const transformData = {}\n\n    if ('RotationOrder' in modelNode) transformData.eulerOrder = getEulerOrder(modelNode.RotationOrder.value)\n    if ('InheritType' in modelNode) transformData.inheritType = parseInt(modelNode.InheritType.value)\n\n    if ('GeometricTranslation' in modelNode) transformData.translation = modelNode.GeometricTranslation.value\n    if ('GeometricRotation' in modelNode) transformData.rotation = modelNode.GeometricRotation.value\n    if ('GeometricScaling' in modelNode) transformData.scale = modelNode.GeometricScaling.value\n\n    const transform = generateTransform(transformData)\n\n    return this.genGeometry(geoNode, skeleton, morphTargets, transform)\n  }\n\n  // Generate a BufferGeometry from a node in FBXTree.Objects.Geometry\n  genGeometry(geoNode, skeleton, morphTargets, preTransform) {\n    const geo = new BufferGeometry()\n    if (geoNode.attrName) geo.name = geoNode.attrName\n\n    const geoInfo = this.parseGeoNode(geoNode, skeleton)\n    const buffers = this.genBuffers(geoInfo)\n\n    const positionAttribute = new Float32BufferAttribute(buffers.vertex, 3)\n\n    positionAttribute.applyMatrix4(preTransform)\n\n    geo.setAttribute('position', positionAttribute)\n\n    if (buffers.colors.length > 0) {\n      geo.setAttribute('color', new Float32BufferAttribute(buffers.colors, 3))\n    }\n\n    if (skeleton) {\n      geo.setAttribute('skinIndex', new Uint16BufferAttribute(buffers.weightsIndices, 4))\n\n      geo.setAttribute('skinWeight', new Float32BufferAttribute(buffers.vertexWeights, 4))\n\n      // used later to bind the skeleton to the model\n      geo.FBX_Deformer = skeleton\n    }\n\n    if (buffers.normal.length > 0) {\n      const normalMatrix = new Matrix3().getNormalMatrix(preTransform)\n\n      const normalAttribute = new Float32BufferAttribute(buffers.normal, 3)\n      normalAttribute.applyNormalMatrix(normalMatrix)\n\n      geo.setAttribute('normal', normalAttribute)\n    }\n\n    buffers.uvs.forEach(function (uvBuffer, i) {\n      if (UV1 === 'uv2') i++\n      const name = i === 0 ? 'uv' : `uv${i}`\n\n      geo.setAttribute(name, new Float32BufferAttribute(buffers.uvs[i], 2))\n    })\n\n    if (geoInfo.material && geoInfo.material.mappingType !== 'AllSame') {\n      // Convert the material indices of each vertex into rendering groups on the geometry.\n      let prevMaterialIndex = buffers.materialIndex[0]\n      let startIndex = 0\n\n      buffers.materialIndex.forEach(function (currentIndex, i) {\n        if (currentIndex !== prevMaterialIndex) {\n          geo.addGroup(startIndex, i - startIndex, prevMaterialIndex)\n\n          prevMaterialIndex = currentIndex\n          startIndex = i\n        }\n      })\n\n      // the loop above doesn't add the last group, do that here.\n      if (geo.groups.length > 0) {\n        const lastGroup = geo.groups[geo.groups.length - 1]\n        const lastIndex = lastGroup.start + lastGroup.count\n\n        if (lastIndex !== buffers.materialIndex.length) {\n          geo.addGroup(lastIndex, buffers.materialIndex.length - lastIndex, prevMaterialIndex)\n        }\n      }\n\n      // case where there are multiple materials but the whole geometry is only\n      // using one of them\n      if (geo.groups.length === 0) {\n        geo.addGroup(0, buffers.materialIndex.length, buffers.materialIndex[0])\n      }\n    }\n\n    this.addMorphTargets(geo, geoNode, morphTargets, preTransform)\n\n    return geo\n  }\n\n  parseGeoNode(geoNode, skeleton) {\n    const geoInfo = {}\n\n    geoInfo.vertexPositions = geoNode.Vertices !== undefined ? geoNode.Vertices.a : []\n    geoInfo.vertexIndices = geoNode.PolygonVertexIndex !== undefined ? geoNode.PolygonVertexIndex.a : []\n\n    if (geoNode.LayerElementColor) {\n      geoInfo.color = this.parseVertexColors(geoNode.LayerElementColor[0])\n    }\n\n    if (geoNode.LayerElementMaterial) {\n      geoInfo.material = this.parseMaterialIndices(geoNode.LayerElementMaterial[0])\n    }\n\n    if (geoNode.LayerElementNormal) {\n      geoInfo.normal = this.parseNormals(geoNode.LayerElementNormal[0])\n    }\n\n    if (geoNode.LayerElementUV) {\n      geoInfo.uv = []\n\n      let i = 0\n      while (geoNode.LayerElementUV[i]) {\n        if (geoNode.LayerElementUV[i].UV) {\n          geoInfo.uv.push(this.parseUVs(geoNode.LayerElementUV[i]))\n        }\n\n        i++\n      }\n    }\n\n    geoInfo.weightTable = {}\n\n    if (skeleton !== null) {\n      geoInfo.skeleton = skeleton\n\n      skeleton.rawBones.forEach(function (rawBone, i) {\n        // loop over the bone's vertex indices and weights\n        rawBone.indices.forEach(function (index, j) {\n          if (geoInfo.weightTable[index] === undefined) geoInfo.weightTable[index] = []\n\n          geoInfo.weightTable[index].push({\n            id: i,\n            weight: rawBone.weights[j],\n          })\n        })\n      })\n    }\n\n    return geoInfo\n  }\n\n  genBuffers(geoInfo) {\n    const buffers = {\n      vertex: [],\n      normal: [],\n      colors: [],\n      uvs: [],\n      materialIndex: [],\n      vertexWeights: [],\n      weightsIndices: [],\n    }\n\n    let polygonIndex = 0\n    let faceLength = 0\n    let displayedWeightsWarning = false\n\n    // these will hold data for a single face\n    let facePositionIndexes = []\n    let faceNormals = []\n    let faceColors = []\n    let faceUVs = []\n    let faceWeights = []\n    let faceWeightIndices = []\n\n    const scope = this\n    geoInfo.vertexIndices.forEach(function (vertexIndex, polygonVertexIndex) {\n      let materialIndex\n      let endOfFace = false\n\n      // Face index and vertex index arrays are combined in a single array\n      // A cube with quad faces looks like this:\n      // PolygonVertexIndex: *24 {\n      //  a: 0, 1, 3, -3, 2, 3, 5, -5, 4, 5, 7, -7, 6, 7, 1, -1, 1, 7, 5, -4, 6, 0, 2, -5\n      //  }\n      // Negative numbers mark the end of a face - first face here is 0, 1, 3, -3\n      // to find index of last vertex bit shift the index: ^ - 1\n      if (vertexIndex < 0) {\n        vertexIndex = vertexIndex ^ -1 // equivalent to ( x * -1 ) - 1\n        endOfFace = true\n      }\n\n      let weightIndices = []\n      let weights = []\n\n      facePositionIndexes.push(vertexIndex * 3, vertexIndex * 3 + 1, vertexIndex * 3 + 2)\n\n      if (geoInfo.color) {\n        const data = getData(polygonVertexIndex, polygonIndex, vertexIndex, geoInfo.color)\n\n        faceColors.push(data[0], data[1], data[2])\n      }\n\n      if (geoInfo.skeleton) {\n        if (geoInfo.weightTable[vertexIndex] !== undefined) {\n          geoInfo.weightTable[vertexIndex].forEach(function (wt) {\n            weights.push(wt.weight)\n            weightIndices.push(wt.id)\n          })\n        }\n\n        if (weights.length > 4) {\n          if (!displayedWeightsWarning) {\n            console.warn(\n              'THREE.FBXLoader: Vertex has more than 4 skinning weights assigned to vertex. Deleting additional weights.',\n            )\n            displayedWeightsWarning = true\n          }\n\n          const wIndex = [0, 0, 0, 0]\n          const Weight = [0, 0, 0, 0]\n\n          weights.forEach(function (weight, weightIndex) {\n            let currentWeight = weight\n            let currentIndex = weightIndices[weightIndex]\n\n            Weight.forEach(function (comparedWeight, comparedWeightIndex, comparedWeightArray) {\n              if (currentWeight > comparedWeight) {\n                comparedWeightArray[comparedWeightIndex] = currentWeight\n                currentWeight = comparedWeight\n\n                const tmp = wIndex[comparedWeightIndex]\n                wIndex[comparedWeightIndex] = currentIndex\n                currentIndex = tmp\n              }\n            })\n          })\n\n          weightIndices = wIndex\n          weights = Weight\n        }\n\n        // if the weight array is shorter than 4 pad with 0s\n        while (weights.length < 4) {\n          weights.push(0)\n          weightIndices.push(0)\n        }\n\n        for (let i = 0; i < 4; ++i) {\n          faceWeights.push(weights[i])\n          faceWeightIndices.push(weightIndices[i])\n        }\n      }\n\n      if (geoInfo.normal) {\n        const data = getData(polygonVertexIndex, polygonIndex, vertexIndex, geoInfo.normal)\n\n        faceNormals.push(data[0], data[1], data[2])\n      }\n\n      if (geoInfo.material && geoInfo.material.mappingType !== 'AllSame') {\n        materialIndex = getData(polygonVertexIndex, polygonIndex, vertexIndex, geoInfo.material)[0]\n      }\n\n      if (geoInfo.uv) {\n        geoInfo.uv.forEach(function (uv, i) {\n          const data = getData(polygonVertexIndex, polygonIndex, vertexIndex, uv)\n\n          if (faceUVs[i] === undefined) {\n            faceUVs[i] = []\n          }\n\n          faceUVs[i].push(data[0])\n          faceUVs[i].push(data[1])\n        })\n      }\n\n      faceLength++\n\n      if (endOfFace) {\n        scope.genFace(\n          buffers,\n          geoInfo,\n          facePositionIndexes,\n          materialIndex,\n          faceNormals,\n          faceColors,\n          faceUVs,\n          faceWeights,\n          faceWeightIndices,\n          faceLength,\n        )\n\n        polygonIndex++\n        faceLength = 0\n\n        // reset arrays for the next face\n        facePositionIndexes = []\n        faceNormals = []\n        faceColors = []\n        faceUVs = []\n        faceWeights = []\n        faceWeightIndices = []\n      }\n    })\n\n    return buffers\n  }\n\n  // Generate data for a single face in a geometry. If the face is a quad then split it into 2 tris\n  genFace(\n    buffers,\n    geoInfo,\n    facePositionIndexes,\n    materialIndex,\n    faceNormals,\n    faceColors,\n    faceUVs,\n    faceWeights,\n    faceWeightIndices,\n    faceLength,\n  ) {\n    for (let i = 2; i < faceLength; i++) {\n      buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[0]])\n      buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[1]])\n      buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[2]])\n\n      buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[(i - 1) * 3]])\n      buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[(i - 1) * 3 + 1]])\n      buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[(i - 1) * 3 + 2]])\n\n      buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[i * 3]])\n      buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[i * 3 + 1]])\n      buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[i * 3 + 2]])\n\n      if (geoInfo.skeleton) {\n        buffers.vertexWeights.push(faceWeights[0])\n        buffers.vertexWeights.push(faceWeights[1])\n        buffers.vertexWeights.push(faceWeights[2])\n        buffers.vertexWeights.push(faceWeights[3])\n\n        buffers.vertexWeights.push(faceWeights[(i - 1) * 4])\n        buffers.vertexWeights.push(faceWeights[(i - 1) * 4 + 1])\n        buffers.vertexWeights.push(faceWeights[(i - 1) * 4 + 2])\n        buffers.vertexWeights.push(faceWeights[(i - 1) * 4 + 3])\n\n        buffers.vertexWeights.push(faceWeights[i * 4])\n        buffers.vertexWeights.push(faceWeights[i * 4 + 1])\n        buffers.vertexWeights.push(faceWeights[i * 4 + 2])\n        buffers.vertexWeights.push(faceWeights[i * 4 + 3])\n\n        buffers.weightsIndices.push(faceWeightIndices[0])\n        buffers.weightsIndices.push(faceWeightIndices[1])\n        buffers.weightsIndices.push(faceWeightIndices[2])\n        buffers.weightsIndices.push(faceWeightIndices[3])\n\n        buffers.weightsIndices.push(faceWeightIndices[(i - 1) * 4])\n        buffers.weightsIndices.push(faceWeightIndices[(i - 1) * 4 + 1])\n        buffers.weightsIndices.push(faceWeightIndices[(i - 1) * 4 + 2])\n        buffers.weightsIndices.push(faceWeightIndices[(i - 1) * 4 + 3])\n\n        buffers.weightsIndices.push(faceWeightIndices[i * 4])\n        buffers.weightsIndices.push(faceWeightIndices[i * 4 + 1])\n        buffers.weightsIndices.push(faceWeightIndices[i * 4 + 2])\n        buffers.weightsIndices.push(faceWeightIndices[i * 4 + 3])\n      }\n\n      if (geoInfo.color) {\n        buffers.colors.push(faceColors[0])\n        buffers.colors.push(faceColors[1])\n        buffers.colors.push(faceColors[2])\n\n        buffers.colors.push(faceColors[(i - 1) * 3])\n        buffers.colors.push(faceColors[(i - 1) * 3 + 1])\n        buffers.colors.push(faceColors[(i - 1) * 3 + 2])\n\n        buffers.colors.push(faceColors[i * 3])\n        buffers.colors.push(faceColors[i * 3 + 1])\n        buffers.colors.push(faceColors[i * 3 + 2])\n      }\n\n      if (geoInfo.material && geoInfo.material.mappingType !== 'AllSame') {\n        buffers.materialIndex.push(materialIndex)\n        buffers.materialIndex.push(materialIndex)\n        buffers.materialIndex.push(materialIndex)\n      }\n\n      if (geoInfo.normal) {\n        buffers.normal.push(faceNormals[0])\n        buffers.normal.push(faceNormals[1])\n        buffers.normal.push(faceNormals[2])\n\n        buffers.normal.push(faceNormals[(i - 1) * 3])\n        buffers.normal.push(faceNormals[(i - 1) * 3 + 1])\n        buffers.normal.push(faceNormals[(i - 1) * 3 + 2])\n\n        buffers.normal.push(faceNormals[i * 3])\n        buffers.normal.push(faceNormals[i * 3 + 1])\n        buffers.normal.push(faceNormals[i * 3 + 2])\n      }\n\n      if (geoInfo.uv) {\n        geoInfo.uv.forEach(function (uv, j) {\n          if (buffers.uvs[j] === undefined) buffers.uvs[j] = []\n\n          buffers.uvs[j].push(faceUVs[j][0])\n          buffers.uvs[j].push(faceUVs[j][1])\n\n          buffers.uvs[j].push(faceUVs[j][(i - 1) * 2])\n          buffers.uvs[j].push(faceUVs[j][(i - 1) * 2 + 1])\n\n          buffers.uvs[j].push(faceUVs[j][i * 2])\n          buffers.uvs[j].push(faceUVs[j][i * 2 + 1])\n        })\n      }\n    }\n  }\n\n  addMorphTargets(parentGeo, parentGeoNode, morphTargets, preTransform) {\n    if (morphTargets.length === 0) return\n\n    parentGeo.morphTargetsRelative = true\n\n    parentGeo.morphAttributes.position = []\n    // parentGeo.morphAttributes.normal = []; // not implemented\n\n    const scope = this\n    morphTargets.forEach(function (morphTarget) {\n      morphTarget.rawTargets.forEach(function (rawTarget) {\n        const morphGeoNode = fbxTree.Objects.Geometry[rawTarget.geoID]\n\n        if (morphGeoNode !== undefined) {\n          scope.genMorphGeometry(parentGeo, parentGeoNode, morphGeoNode, preTransform, rawTarget.name)\n        }\n      })\n    })\n  }\n\n  // a morph geometry node is similar to a standard  node, and the node is also contained\n  // in FBXTree.Objects.Geometry, however it can only have attributes for position, normal\n  // and a special attribute Index defining which vertices of the original geometry are affected\n  // Normal and position attributes only have data for the vertices that are affected by the morph\n  genMorphGeometry(parentGeo, parentGeoNode, morphGeoNode, preTransform, name) {\n    const vertexIndices = parentGeoNode.PolygonVertexIndex !== undefined ? parentGeoNode.PolygonVertexIndex.a : []\n\n    const morphPositionsSparse = morphGeoNode.Vertices !== undefined ? morphGeoNode.Vertices.a : []\n    const indices = morphGeoNode.Indexes !== undefined ? morphGeoNode.Indexes.a : []\n\n    const length = parentGeo.attributes.position.count * 3\n    const morphPositions = new Float32Array(length)\n\n    for (let i = 0; i < indices.length; i++) {\n      const morphIndex = indices[i] * 3\n\n      morphPositions[morphIndex] = morphPositionsSparse[i * 3]\n      morphPositions[morphIndex + 1] = morphPositionsSparse[i * 3 + 1]\n      morphPositions[morphIndex + 2] = morphPositionsSparse[i * 3 + 2]\n    }\n\n    // TODO: add morph normal support\n    const morphGeoInfo = {\n      vertexIndices: vertexIndices,\n      vertexPositions: morphPositions,\n    }\n\n    const morphBuffers = this.genBuffers(morphGeoInfo)\n\n    const positionAttribute = new Float32BufferAttribute(morphBuffers.vertex, 3)\n    positionAttribute.name = name || morphGeoNode.attrName\n\n    positionAttribute.applyMatrix4(preTransform)\n\n    parentGeo.morphAttributes.position.push(positionAttribute)\n  }\n\n  // Parse normal from FBXTree.Objects.Geometry.LayerElementNormal if it exists\n  parseNormals(NormalNode) {\n    const mappingType = NormalNode.MappingInformationType\n    const referenceType = NormalNode.ReferenceInformationType\n    const buffer = NormalNode.Normals.a\n    let indexBuffer = []\n    if (referenceType === 'IndexToDirect') {\n      if ('NormalIndex' in NormalNode) {\n        indexBuffer = NormalNode.NormalIndex.a\n      } else if ('NormalsIndex' in NormalNode) {\n        indexBuffer = NormalNode.NormalsIndex.a\n      }\n    }\n\n    return {\n      dataSize: 3,\n      buffer: buffer,\n      indices: indexBuffer,\n      mappingType: mappingType,\n      referenceType: referenceType,\n    }\n  }\n\n  // Parse UVs from FBXTree.Objects.Geometry.LayerElementUV if it exists\n  parseUVs(UVNode) {\n    const mappingType = UVNode.MappingInformationType\n    const referenceType = UVNode.ReferenceInformationType\n    const buffer = UVNode.UV.a\n    let indexBuffer = []\n    if (referenceType === 'IndexToDirect') {\n      indexBuffer = UVNode.UVIndex.a\n    }\n\n    return {\n      dataSize: 2,\n      buffer: buffer,\n      indices: indexBuffer,\n      mappingType: mappingType,\n      referenceType: referenceType,\n    }\n  }\n\n  // Parse Vertex Colors from FBXTree.Objects.Geometry.LayerElementColor if it exists\n  parseVertexColors(ColorNode) {\n    const mappingType = ColorNode.MappingInformationType\n    const referenceType = ColorNode.ReferenceInformationType\n    const buffer = ColorNode.Colors.a\n    let indexBuffer = []\n    if (referenceType === 'IndexToDirect') {\n      indexBuffer = ColorNode.ColorIndex.a\n    }\n\n    return {\n      dataSize: 4,\n      buffer: buffer,\n      indices: indexBuffer,\n      mappingType: mappingType,\n      referenceType: referenceType,\n    }\n  }\n\n  // Parse mapping and material data in FBXTree.Objects.Geometry.LayerElementMaterial if it exists\n  parseMaterialIndices(MaterialNode) {\n    const mappingType = MaterialNode.MappingInformationType\n    const referenceType = MaterialNode.ReferenceInformationType\n\n    if (mappingType === 'NoMappingInformation') {\n      return {\n        dataSize: 1,\n        buffer: [0],\n        indices: [0],\n        mappingType: 'AllSame',\n        referenceType: referenceType,\n      }\n    }\n\n    const materialIndexBuffer = MaterialNode.Materials.a\n\n    // Since materials are stored as indices, there's a bit of a mismatch between FBX and what\n    // we expect.So we create an intermediate buffer that points to the index in the buffer,\n    // for conforming with the other functions we've written for other data.\n    const materialIndices = []\n\n    for (let i = 0; i < materialIndexBuffer.length; ++i) {\n      materialIndices.push(i)\n    }\n\n    return {\n      dataSize: 1,\n      buffer: materialIndexBuffer,\n      indices: materialIndices,\n      mappingType: mappingType,\n      referenceType: referenceType,\n    }\n  }\n\n  // Generate a NurbGeometry from a node in FBXTree.Objects.Geometry\n  parseNurbsGeometry(geoNode) {\n    if (NURBSCurve === undefined) {\n      console.error(\n        'THREE.FBXLoader: The loader relies on NURBSCurve for any nurbs present in the model. Nurbs will show up as empty geometry.',\n      )\n      return new BufferGeometry()\n    }\n\n    const order = parseInt(geoNode.Order)\n\n    if (isNaN(order)) {\n      console.error('THREE.FBXLoader: Invalid Order %s given for geometry ID: %s', geoNode.Order, geoNode.id)\n      return new BufferGeometry()\n    }\n\n    const degree = order - 1\n\n    const knots = geoNode.KnotVector.a\n    const controlPoints = []\n    const pointsValues = geoNode.Points.a\n\n    for (let i = 0, l = pointsValues.length; i < l; i += 4) {\n      controlPoints.push(new Vector4().fromArray(pointsValues, i))\n    }\n\n    let startKnot, endKnot\n\n    if (geoNode.Form === 'Closed') {\n      controlPoints.push(controlPoints[0])\n    } else if (geoNode.Form === 'Periodic') {\n      startKnot = degree\n      endKnot = knots.length - 1 - startKnot\n\n      for (let i = 0; i < degree; ++i) {\n        controlPoints.push(controlPoints[i])\n      }\n    }\n\n    const curve = new NURBSCurve(degree, knots, controlPoints, startKnot, endKnot)\n    const points = curve.getPoints(controlPoints.length * 12)\n\n    return new BufferGeometry().setFromPoints(points)\n  }\n}\n\n// parse animation data from FBXTree\nclass AnimationParser {\n  // take raw animation clips and turn them into three.js animation clips\n  parse() {\n    const animationClips = []\n\n    const rawClips = this.parseClips()\n\n    if (rawClips !== undefined) {\n      for (const key in rawClips) {\n        const rawClip = rawClips[key]\n\n        const clip = this.addClip(rawClip)\n\n        animationClips.push(clip)\n      }\n    }\n\n    return animationClips\n  }\n\n  parseClips() {\n    // since the actual transformation data is stored in FBXTree.Objects.AnimationCurve,\n    // if this is undefined we can safely assume there are no animations\n    if (fbxTree.Objects.AnimationCurve === undefined) return undefined\n\n    const curveNodesMap = this.parseAnimationCurveNodes()\n\n    this.parseAnimationCurves(curveNodesMap)\n\n    const layersMap = this.parseAnimationLayers(curveNodesMap)\n    const rawClips = this.parseAnimStacks(layersMap)\n\n    return rawClips\n  }\n\n  // parse nodes in FBXTree.Objects.AnimationCurveNode\n  // each AnimationCurveNode holds data for an animation transform for a model (e.g. left arm rotation )\n  // and is referenced by an AnimationLayer\n  parseAnimationCurveNodes() {\n    const rawCurveNodes = fbxTree.Objects.AnimationCurveNode\n\n    const curveNodesMap = new Map()\n\n    for (const nodeID in rawCurveNodes) {\n      const rawCurveNode = rawCurveNodes[nodeID]\n\n      if (rawCurveNode.attrName.match(/S|R|T|DeformPercent/) !== null) {\n        const curveNode = {\n          id: rawCurveNode.id,\n          attr: rawCurveNode.attrName,\n          curves: {},\n        }\n\n        curveNodesMap.set(curveNode.id, curveNode)\n      }\n    }\n\n    return curveNodesMap\n  }\n\n  // parse nodes in FBXTree.Objects.AnimationCurve and connect them up to\n  // previously parsed AnimationCurveNodes. Each AnimationCurve holds data for a single animated\n  // axis ( e.g. times and values of x rotation)\n  parseAnimationCurves(curveNodesMap) {\n    const rawCurves = fbxTree.Objects.AnimationCurve\n\n    // TODO: Many values are identical up to roundoff error, but won't be optimised\n    // e.g. position times: [0, 0.4, 0. 8]\n    // position values: [7.23538335023477e-7, 93.67518615722656, -0.9982695579528809, 7.23538335023477e-7, 93.67518615722656, -0.9982695579528809, 7.235384487103147e-7, 93.67520904541016, -0.9982695579528809]\n    // clearly, this should be optimised to\n    // times: [0], positions [7.23538335023477e-7, 93.67518615722656, -0.9982695579528809]\n    // this shows up in nearly every FBX file, and generally time array is length > 100\n\n    for (const nodeID in rawCurves) {\n      const animationCurve = {\n        id: rawCurves[nodeID].id,\n        times: rawCurves[nodeID].KeyTime.a.map(convertFBXTimeToSeconds),\n        values: rawCurves[nodeID].KeyValueFloat.a,\n      }\n\n      const relationships = connections.get(animationCurve.id)\n\n      if (relationships !== undefined) {\n        const animationCurveID = relationships.parents[0].ID\n        const animationCurveRelationship = relationships.parents[0].relationship\n\n        if (animationCurveRelationship.match(/X/)) {\n          curveNodesMap.get(animationCurveID).curves['x'] = animationCurve\n        } else if (animationCurveRelationship.match(/Y/)) {\n          curveNodesMap.get(animationCurveID).curves['y'] = animationCurve\n        } else if (animationCurveRelationship.match(/Z/)) {\n          curveNodesMap.get(animationCurveID).curves['z'] = animationCurve\n        } else if (animationCurveRelationship.match(/d|DeformPercent/) && curveNodesMap.has(animationCurveID)) {\n          curveNodesMap.get(animationCurveID).curves['morph'] = animationCurve\n        }\n      }\n    }\n  }\n\n  // parse nodes in FBXTree.Objects.AnimationLayer. Each layers holds references\n  // to various AnimationCurveNodes and is referenced by an AnimationStack node\n  // note: theoretically a stack can have multiple layers, however in practice there always seems to be one per stack\n  parseAnimationLayers(curveNodesMap) {\n    const rawLayers = fbxTree.Objects.AnimationLayer\n\n    const layersMap = new Map()\n\n    for (const nodeID in rawLayers) {\n      const layerCurveNodes = []\n\n      const connection = connections.get(parseInt(nodeID))\n\n      if (connection !== undefined) {\n        // all the animationCurveNodes used in the layer\n        const children = connection.children\n\n        children.forEach(function (child, i) {\n          if (curveNodesMap.has(child.ID)) {\n            const curveNode = curveNodesMap.get(child.ID)\n\n            // check that the curves are defined for at least one axis, otherwise ignore the curveNode\n            if (\n              curveNode.curves.x !== undefined ||\n              curveNode.curves.y !== undefined ||\n              curveNode.curves.z !== undefined\n            ) {\n              if (layerCurveNodes[i] === undefined) {\n                const modelID = connections.get(child.ID).parents.filter(function (parent) {\n                  return parent.relationship !== undefined\n                })[0].ID\n\n                if (modelID !== undefined) {\n                  const rawModel = fbxTree.Objects.Model[modelID.toString()]\n\n                  if (rawModel === undefined) {\n                    console.warn('THREE.FBXLoader: Encountered a unused curve.', child)\n                    return\n                  }\n\n                  const node = {\n                    modelName: rawModel.attrName ? PropertyBinding.sanitizeNodeName(rawModel.attrName) : '',\n                    ID: rawModel.id,\n                    initialPosition: [0, 0, 0],\n                    initialRotation: [0, 0, 0],\n                    initialScale: [1, 1, 1],\n                  }\n\n                  sceneGraph.traverse(function (child) {\n                    if (child.ID === rawModel.id) {\n                      node.transform = child.matrix\n\n                      if (child.userData.transformData) node.eulerOrder = child.userData.transformData.eulerOrder\n                    }\n                  })\n\n                  if (!node.transform) node.transform = new Matrix4()\n\n                  // if the animated model is pre rotated, we'll have to apply the pre rotations to every\n                  // animation value as well\n                  if ('PreRotation' in rawModel) node.preRotation = rawModel.PreRotation.value\n                  if ('PostRotation' in rawModel) node.postRotation = rawModel.PostRotation.value\n\n                  layerCurveNodes[i] = node\n                }\n              }\n\n              if (layerCurveNodes[i]) layerCurveNodes[i][curveNode.attr] = curveNode\n            } else if (curveNode.curves.morph !== undefined) {\n              if (layerCurveNodes[i] === undefined) {\n                const deformerID = connections.get(child.ID).parents.filter(function (parent) {\n                  return parent.relationship !== undefined\n                })[0].ID\n\n                const morpherID = connections.get(deformerID).parents[0].ID\n                const geoID = connections.get(morpherID).parents[0].ID\n\n                // assuming geometry is not used in more than one model\n                const modelID = connections.get(geoID).parents[0].ID\n\n                const rawModel = fbxTree.Objects.Model[modelID]\n\n                const node = {\n                  modelName: rawModel.attrName ? PropertyBinding.sanitizeNodeName(rawModel.attrName) : '',\n                  morphName: fbxTree.Objects.Deformer[deformerID].attrName,\n                }\n\n                layerCurveNodes[i] = node\n              }\n\n              layerCurveNodes[i][curveNode.attr] = curveNode\n            }\n          }\n        })\n\n        layersMap.set(parseInt(nodeID), layerCurveNodes)\n      }\n    }\n\n    return layersMap\n  }\n\n  // parse nodes in FBXTree.Objects.AnimationStack. These are the top level node in the animation\n  // hierarchy. Each Stack node will be used to create a AnimationClip\n  parseAnimStacks(layersMap) {\n    const rawStacks = fbxTree.Objects.AnimationStack\n\n    // connect the stacks (clips) up to the layers\n    const rawClips = {}\n\n    for (const nodeID in rawStacks) {\n      const children = connections.get(parseInt(nodeID)).children\n\n      if (children.length > 1) {\n        // it seems like stacks will always be associated with a single layer. But just in case there are files\n        // where there are multiple layers per stack, we'll display a warning\n        console.warn(\n          'THREE.FBXLoader: Encountered an animation stack with multiple layers, this is currently not supported. Ignoring subsequent layers.',\n        )\n      }\n\n      const layer = layersMap.get(children[0].ID)\n\n      rawClips[nodeID] = {\n        name: rawStacks[nodeID].attrName,\n        layer: layer,\n      }\n    }\n\n    return rawClips\n  }\n\n  addClip(rawClip) {\n    let tracks = []\n\n    const scope = this\n    rawClip.layer.forEach(function (rawTracks) {\n      tracks = tracks.concat(scope.generateTracks(rawTracks))\n    })\n\n    return new AnimationClip(rawClip.name, -1, tracks)\n  }\n\n  generateTracks(rawTracks) {\n    const tracks = []\n\n    let initialPosition = new Vector3()\n    let initialRotation = new Quaternion()\n    let initialScale = new Vector3()\n\n    if (rawTracks.transform) rawTracks.transform.decompose(initialPosition, initialRotation, initialScale)\n\n    initialPosition = initialPosition.toArray()\n    initialRotation = new Euler().setFromQuaternion(initialRotation, rawTracks.eulerOrder).toArray()\n    initialScale = initialScale.toArray()\n\n    if (rawTracks.T !== undefined && Object.keys(rawTracks.T.curves).length > 0) {\n      const positionTrack = this.generateVectorTrack(\n        rawTracks.modelName,\n        rawTracks.T.curves,\n        initialPosition,\n        'position',\n      )\n      if (positionTrack !== undefined) tracks.push(positionTrack)\n    }\n\n    if (rawTracks.R !== undefined && Object.keys(rawTracks.R.curves).length > 0) {\n      const rotationTrack = this.generateRotationTrack(\n        rawTracks.modelName,\n        rawTracks.R.curves,\n        initialRotation,\n        rawTracks.preRotation,\n        rawTracks.postRotation,\n        rawTracks.eulerOrder,\n      )\n      if (rotationTrack !== undefined) tracks.push(rotationTrack)\n    }\n\n    if (rawTracks.S !== undefined && Object.keys(rawTracks.S.curves).length > 0) {\n      const scaleTrack = this.generateVectorTrack(rawTracks.modelName, rawTracks.S.curves, initialScale, 'scale')\n      if (scaleTrack !== undefined) tracks.push(scaleTrack)\n    }\n\n    if (rawTracks.DeformPercent !== undefined) {\n      const morphTrack = this.generateMorphTrack(rawTracks)\n      if (morphTrack !== undefined) tracks.push(morphTrack)\n    }\n\n    return tracks\n  }\n\n  generateVectorTrack(modelName, curves, initialValue, type) {\n    const times = this.getTimesForAllAxes(curves)\n    const values = this.getKeyframeTrackValues(times, curves, initialValue)\n\n    return new VectorKeyframeTrack(modelName + '.' + type, times, values)\n  }\n\n  generateRotationTrack(modelName, curves, initialValue, preRotation, postRotation, eulerOrder) {\n    if (curves.x !== undefined) {\n      this.interpolateRotations(curves.x)\n      curves.x.values = curves.x.values.map(MathUtils.degToRad)\n    }\n\n    if (curves.y !== undefined) {\n      this.interpolateRotations(curves.y)\n      curves.y.values = curves.y.values.map(MathUtils.degToRad)\n    }\n\n    if (curves.z !== undefined) {\n      this.interpolateRotations(curves.z)\n      curves.z.values = curves.z.values.map(MathUtils.degToRad)\n    }\n\n    const times = this.getTimesForAllAxes(curves)\n    const values = this.getKeyframeTrackValues(times, curves, initialValue)\n\n    if (preRotation !== undefined) {\n      preRotation = preRotation.map(MathUtils.degToRad)\n      preRotation.push(eulerOrder)\n\n      preRotation = new Euler().fromArray(preRotation)\n      preRotation = new Quaternion().setFromEuler(preRotation)\n    }\n\n    if (postRotation !== undefined) {\n      postRotation = postRotation.map(MathUtils.degToRad)\n      postRotation.push(eulerOrder)\n\n      postRotation = new Euler().fromArray(postRotation)\n      postRotation = new Quaternion().setFromEuler(postRotation).invert()\n    }\n\n    const quaternion = new Quaternion()\n    const euler = new Euler()\n\n    const quaternionValues = []\n\n    for (let i = 0; i < values.length; i += 3) {\n      euler.set(values[i], values[i + 1], values[i + 2], eulerOrder)\n\n      quaternion.setFromEuler(euler)\n\n      if (preRotation !== undefined) quaternion.premultiply(preRotation)\n      if (postRotation !== undefined) quaternion.multiply(postRotation)\n\n      quaternion.toArray(quaternionValues, (i / 3) * 4)\n    }\n\n    return new QuaternionKeyframeTrack(modelName + '.quaternion', times, quaternionValues)\n  }\n\n  generateMorphTrack(rawTracks) {\n    const curves = rawTracks.DeformPercent.curves.morph\n    const values = curves.values.map(function (val) {\n      return val / 100\n    })\n\n    const morphNum = sceneGraph.getObjectByName(rawTracks.modelName).morphTargetDictionary[rawTracks.morphName]\n\n    return new NumberKeyframeTrack(\n      rawTracks.modelName + '.morphTargetInfluences[' + morphNum + ']',\n      curves.times,\n      values,\n    )\n  }\n\n  // For all animated objects, times are defined separately for each axis\n  // Here we'll combine the times into one sorted array without duplicates\n  getTimesForAllAxes(curves) {\n    let times = []\n\n    // first join together the times for each axis, if defined\n    if (curves.x !== undefined) times = times.concat(curves.x.times)\n    if (curves.y !== undefined) times = times.concat(curves.y.times)\n    if (curves.z !== undefined) times = times.concat(curves.z.times)\n\n    // then sort them\n    times = times.sort(function (a, b) {\n      return a - b\n    })\n\n    // and remove duplicates\n    if (times.length > 1) {\n      let targetIndex = 1\n      let lastValue = times[0]\n      for (let i = 1; i < times.length; i++) {\n        const currentValue = times[i]\n        if (currentValue !== lastValue) {\n          times[targetIndex] = currentValue\n          lastValue = currentValue\n          targetIndex++\n        }\n      }\n\n      times = times.slice(0, targetIndex)\n    }\n\n    return times\n  }\n\n  getKeyframeTrackValues(times, curves, initialValue) {\n    const prevValue = initialValue\n\n    const values = []\n\n    let xIndex = -1\n    let yIndex = -1\n    let zIndex = -1\n\n    times.forEach(function (time) {\n      if (curves.x) xIndex = curves.x.times.indexOf(time)\n      if (curves.y) yIndex = curves.y.times.indexOf(time)\n      if (curves.z) zIndex = curves.z.times.indexOf(time)\n\n      // if there is an x value defined for this frame, use that\n      if (xIndex !== -1) {\n        const xValue = curves.x.values[xIndex]\n        values.push(xValue)\n        prevValue[0] = xValue\n      } else {\n        // otherwise use the x value from the previous frame\n        values.push(prevValue[0])\n      }\n\n      if (yIndex !== -1) {\n        const yValue = curves.y.values[yIndex]\n        values.push(yValue)\n        prevValue[1] = yValue\n      } else {\n        values.push(prevValue[1])\n      }\n\n      if (zIndex !== -1) {\n        const zValue = curves.z.values[zIndex]\n        values.push(zValue)\n        prevValue[2] = zValue\n      } else {\n        values.push(prevValue[2])\n      }\n    })\n\n    return values\n  }\n\n  // Rotations are defined as Euler angles which can have values  of any size\n  // These will be converted to quaternions which don't support values greater than\n  // PI, so we'll interpolate large rotations\n  interpolateRotations(curve) {\n    for (let i = 1; i < curve.values.length; i++) {\n      const initialValue = curve.values[i - 1]\n      const valuesSpan = curve.values[i] - initialValue\n\n      const absoluteSpan = Math.abs(valuesSpan)\n\n      if (absoluteSpan >= 180) {\n        const numSubIntervals = absoluteSpan / 180\n\n        const step = valuesSpan / numSubIntervals\n        let nextValue = initialValue + step\n\n        const initialTime = curve.times[i - 1]\n        const timeSpan = curve.times[i] - initialTime\n        const interval = timeSpan / numSubIntervals\n        let nextTime = initialTime + interval\n\n        const interpolatedTimes = []\n        const interpolatedValues = []\n\n        while (nextTime < curve.times[i]) {\n          interpolatedTimes.push(nextTime)\n          nextTime += interval\n\n          interpolatedValues.push(nextValue)\n          nextValue += step\n        }\n\n        curve.times = inject(curve.times, i, interpolatedTimes)\n        curve.values = inject(curve.values, i, interpolatedValues)\n      }\n    }\n  }\n}\n\n// parse an FBX file in ASCII format\nclass TextParser {\n  getPrevNode() {\n    return this.nodeStack[this.currentIndent - 2]\n  }\n\n  getCurrentNode() {\n    return this.nodeStack[this.currentIndent - 1]\n  }\n\n  getCurrentProp() {\n    return this.currentProp\n  }\n\n  pushStack(node) {\n    this.nodeStack.push(node)\n    this.currentIndent += 1\n  }\n\n  popStack() {\n    this.nodeStack.pop()\n    this.currentIndent -= 1\n  }\n\n  setCurrentProp(val, name) {\n    this.currentProp = val\n    this.currentPropName = name\n  }\n\n  parse(text) {\n    this.currentIndent = 0\n\n    this.allNodes = new FBXTree()\n    this.nodeStack = []\n    this.currentProp = []\n    this.currentPropName = ''\n\n    const scope = this\n\n    const split = text.split(/[\\r\\n]+/)\n\n    split.forEach(function (line, i) {\n      const matchComment = line.match(/^[\\s\\t]*;/)\n      const matchEmpty = line.match(/^[\\s\\t]*$/)\n\n      if (matchComment || matchEmpty) return\n\n      const matchBeginning = line.match('^\\\\t{' + scope.currentIndent + '}(\\\\w+):(.*){', '')\n      const matchProperty = line.match('^\\\\t{' + scope.currentIndent + '}(\\\\w+):[\\\\s\\\\t\\\\r\\\\n](.*)')\n      const matchEnd = line.match('^\\\\t{' + (scope.currentIndent - 1) + '}}')\n\n      if (matchBeginning) {\n        scope.parseNodeBegin(line, matchBeginning)\n      } else if (matchProperty) {\n        scope.parseNodeProperty(line, matchProperty, split[++i])\n      } else if (matchEnd) {\n        scope.popStack()\n      } else if (line.match(/^[^\\s\\t}]/)) {\n        // large arrays are split over multiple lines terminated with a ',' character\n        // if this is encountered the line needs to be joined to the previous line\n        scope.parseNodePropertyContinued(line)\n      }\n    })\n\n    return this.allNodes\n  }\n\n  parseNodeBegin(line, property) {\n    const nodeName = property[1].trim().replace(/^\"/, '').replace(/\"$/, '')\n\n    const nodeAttrs = property[2].split(',').map(function (attr) {\n      return attr.trim().replace(/^\"/, '').replace(/\"$/, '')\n    })\n\n    const node = { name: nodeName }\n    const attrs = this.parseNodeAttr(nodeAttrs)\n\n    const currentNode = this.getCurrentNode()\n\n    // a top node\n    if (this.currentIndent === 0) {\n      this.allNodes.add(nodeName, node)\n    } else {\n      // a subnode\n\n      // if the subnode already exists, append it\n      if (nodeName in currentNode) {\n        // special case Pose needs PoseNodes as an array\n        if (nodeName === 'PoseNode') {\n          currentNode.PoseNode.push(node)\n        } else if (currentNode[nodeName].id !== undefined) {\n          currentNode[nodeName] = {}\n          currentNode[nodeName][currentNode[nodeName].id] = currentNode[nodeName]\n        }\n\n        if (attrs.id !== '') currentNode[nodeName][attrs.id] = node\n      } else if (typeof attrs.id === 'number') {\n        currentNode[nodeName] = {}\n        currentNode[nodeName][attrs.id] = node\n      } else if (nodeName !== 'Properties70') {\n        if (nodeName === 'PoseNode') currentNode[nodeName] = [node]\n        else currentNode[nodeName] = node\n      }\n    }\n\n    if (typeof attrs.id === 'number') node.id = attrs.id\n    if (attrs.name !== '') node.attrName = attrs.name\n    if (attrs.type !== '') node.attrType = attrs.type\n\n    this.pushStack(node)\n  }\n\n  parseNodeAttr(attrs) {\n    let id = attrs[0]\n\n    if (attrs[0] !== '') {\n      id = parseInt(attrs[0])\n\n      if (isNaN(id)) {\n        id = attrs[0]\n      }\n    }\n\n    let name = '',\n      type = ''\n\n    if (attrs.length > 1) {\n      name = attrs[1].replace(/^(\\w+)::/, '')\n      type = attrs[2]\n    }\n\n    return { id: id, name: name, type: type }\n  }\n\n  parseNodeProperty(line, property, contentLine) {\n    let propName = property[1].replace(/^\"/, '').replace(/\"$/, '').trim()\n    let propValue = property[2].replace(/^\"/, '').replace(/\"$/, '').trim()\n\n    // for special case: base64 image data follows \"Content: ,\" line\n    //\tContent: ,\n    //\t \"/9j/4RDaRXhpZgAATU0A...\"\n    if (propName === 'Content' && propValue === ',') {\n      propValue = contentLine.replace(/\"/g, '').replace(/,$/, '').trim()\n    }\n\n    const currentNode = this.getCurrentNode()\n    const parentName = currentNode.name\n\n    if (parentName === 'Properties70') {\n      this.parseNodeSpecialProperty(line, propName, propValue)\n      return\n    }\n\n    // Connections\n    if (propName === 'C') {\n      const connProps = propValue.split(',').slice(1)\n      const from = parseInt(connProps[0])\n      const to = parseInt(connProps[1])\n\n      let rest = propValue.split(',').slice(3)\n\n      rest = rest.map(function (elem) {\n        return elem.trim().replace(/^\"/, '')\n      })\n\n      propName = 'connections'\n      propValue = [from, to]\n      append(propValue, rest)\n\n      if (currentNode[propName] === undefined) {\n        currentNode[propName] = []\n      }\n    }\n\n    // Node\n    if (propName === 'Node') currentNode.id = propValue\n\n    // connections\n    if (propName in currentNode && Array.isArray(currentNode[propName])) {\n      currentNode[propName].push(propValue)\n    } else {\n      if (propName !== 'a') currentNode[propName] = propValue\n      else currentNode.a = propValue\n    }\n\n    this.setCurrentProp(currentNode, propName)\n\n    // convert string to array, unless it ends in ',' in which case more will be added to it\n    if (propName === 'a' && propValue.slice(-1) !== ',') {\n      currentNode.a = parseNumberArray(propValue)\n    }\n  }\n\n  parseNodePropertyContinued(line) {\n    const currentNode = this.getCurrentNode()\n\n    currentNode.a += line\n\n    // if the line doesn't end in ',' we have reached the end of the property value\n    // so convert the string to an array\n    if (line.slice(-1) !== ',') {\n      currentNode.a = parseNumberArray(currentNode.a)\n    }\n  }\n\n  // parse \"Property70\"\n  parseNodeSpecialProperty(line, propName, propValue) {\n    // split this\n    // P: \"Lcl Scaling\", \"Lcl Scaling\", \"\", \"A\",1,1,1\n    // into array like below\n    // [\"Lcl Scaling\", \"Lcl Scaling\", \"\", \"A\", \"1,1,1\" ]\n    const props = propValue.split('\",').map(function (prop) {\n      return prop.trim().replace(/^\\\"/, '').replace(/\\s/, '_')\n    })\n\n    const innerPropName = props[0]\n    const innerPropType1 = props[1]\n    const innerPropType2 = props[2]\n    const innerPropFlag = props[3]\n    let innerPropValue = props[4]\n\n    // cast values where needed, otherwise leave as strings\n    switch (innerPropType1) {\n      case 'int':\n      case 'enum':\n      case 'bool':\n      case 'ULongLong':\n      case 'double':\n      case 'Number':\n      case 'FieldOfView':\n        innerPropValue = parseFloat(innerPropValue)\n        break\n\n      case 'Color':\n      case 'ColorRGB':\n      case 'Vector3D':\n      case 'Lcl_Translation':\n      case 'Lcl_Rotation':\n      case 'Lcl_Scaling':\n        innerPropValue = parseNumberArray(innerPropValue)\n        break\n    }\n\n    // CAUTION: these props must append to parent's parent\n    this.getPrevNode()[innerPropName] = {\n      type: innerPropType1,\n      type2: innerPropType2,\n      flag: innerPropFlag,\n      value: innerPropValue,\n    }\n\n    this.setCurrentProp(this.getPrevNode(), innerPropName)\n  }\n}\n\n// Parse an FBX file in Binary format\nclass BinaryParser {\n  parse(buffer) {\n    const reader = new BinaryReader(buffer)\n    reader.skip(23) // skip magic 23 bytes\n\n    const version = reader.getUint32()\n\n    if (version < 6400) {\n      throw new Error('THREE.FBXLoader: FBX version not supported, FileVersion: ' + version)\n    }\n\n    const allNodes = new FBXTree()\n\n    while (!this.endOfContent(reader)) {\n      const node = this.parseNode(reader, version)\n      if (node !== null) allNodes.add(node.name, node)\n    }\n\n    return allNodes\n  }\n\n  // Check if reader has reached the end of content.\n  endOfContent(reader) {\n    // footer size: 160bytes + 16-byte alignment padding\n    // - 16bytes: magic\n    // - padding til 16-byte alignment (at least 1byte?)\n    //\t(seems like some exporters embed fixed 15 or 16bytes?)\n    // - 4bytes: magic\n    // - 4bytes: version\n    // - 120bytes: zero\n    // - 16bytes: magic\n    if (reader.size() % 16 === 0) {\n      return ((reader.getOffset() + 160 + 16) & ~0xf) >= reader.size()\n    } else {\n      return reader.getOffset() + 160 + 16 >= reader.size()\n    }\n  }\n\n  // recursively parse nodes until the end of the file is reached\n  parseNode(reader, version) {\n    const node = {}\n\n    // The first three data sizes depends on version.\n    const endOffset = version >= 7500 ? reader.getUint64() : reader.getUint32()\n    const numProperties = version >= 7500 ? reader.getUint64() : reader.getUint32()\n\n    version >= 7500 ? reader.getUint64() : reader.getUint32() // the returned propertyListLen is not used\n\n    const nameLen = reader.getUint8()\n    const name = reader.getString(nameLen)\n\n    // Regards this node as NULL-record if endOffset is zero\n    if (endOffset === 0) return null\n\n    const propertyList = []\n\n    for (let i = 0; i < numProperties; i++) {\n      propertyList.push(this.parseProperty(reader))\n    }\n\n    // Regards the first three elements in propertyList as id, attrName, and attrType\n    const id = propertyList.length > 0 ? propertyList[0] : ''\n    const attrName = propertyList.length > 1 ? propertyList[1] : ''\n    const attrType = propertyList.length > 2 ? propertyList[2] : ''\n\n    // check if this node represents just a single property\n    // like (name, 0) set or (name2, [0, 1, 2]) set of {name: 0, name2: [0, 1, 2]}\n    node.singleProperty = numProperties === 1 && reader.getOffset() === endOffset ? true : false\n\n    while (endOffset > reader.getOffset()) {\n      const subNode = this.parseNode(reader, version)\n\n      if (subNode !== null) this.parseSubNode(name, node, subNode)\n    }\n\n    node.propertyList = propertyList // raw property list used by parent\n\n    if (typeof id === 'number') node.id = id\n    if (attrName !== '') node.attrName = attrName\n    if (attrType !== '') node.attrType = attrType\n    if (name !== '') node.name = name\n\n    return node\n  }\n\n  parseSubNode(name, node, subNode) {\n    // special case: child node is single property\n    if (subNode.singleProperty === true) {\n      const value = subNode.propertyList[0]\n\n      if (Array.isArray(value)) {\n        node[subNode.name] = subNode\n\n        subNode.a = value\n      } else {\n        node[subNode.name] = value\n      }\n    } else if (name === 'Connections' && subNode.name === 'C') {\n      const array = []\n\n      subNode.propertyList.forEach(function (property, i) {\n        // first Connection is FBX type (OO, OP, etc.). We'll discard these\n        if (i !== 0) array.push(property)\n      })\n\n      if (node.connections === undefined) {\n        node.connections = []\n      }\n\n      node.connections.push(array)\n    } else if (subNode.name === 'Properties70') {\n      const keys = Object.keys(subNode)\n\n      keys.forEach(function (key) {\n        node[key] = subNode[key]\n      })\n    } else if (name === 'Properties70' && subNode.name === 'P') {\n      let innerPropName = subNode.propertyList[0]\n      let innerPropType1 = subNode.propertyList[1]\n      const innerPropType2 = subNode.propertyList[2]\n      const innerPropFlag = subNode.propertyList[3]\n      let innerPropValue\n\n      if (innerPropName.indexOf('Lcl ') === 0) innerPropName = innerPropName.replace('Lcl ', 'Lcl_')\n      if (innerPropType1.indexOf('Lcl ') === 0) innerPropType1 = innerPropType1.replace('Lcl ', 'Lcl_')\n\n      if (\n        innerPropType1 === 'Color' ||\n        innerPropType1 === 'ColorRGB' ||\n        innerPropType1 === 'Vector' ||\n        innerPropType1 === 'Vector3D' ||\n        innerPropType1.indexOf('Lcl_') === 0\n      ) {\n        innerPropValue = [subNode.propertyList[4], subNode.propertyList[5], subNode.propertyList[6]]\n      } else {\n        innerPropValue = subNode.propertyList[4]\n      }\n\n      // this will be copied to parent, see above\n      node[innerPropName] = {\n        type: innerPropType1,\n        type2: innerPropType2,\n        flag: innerPropFlag,\n        value: innerPropValue,\n      }\n    } else if (node[subNode.name] === undefined) {\n      if (typeof subNode.id === 'number') {\n        node[subNode.name] = {}\n        node[subNode.name][subNode.id] = subNode\n      } else {\n        node[subNode.name] = subNode\n      }\n    } else {\n      if (subNode.name === 'PoseNode') {\n        if (!Array.isArray(node[subNode.name])) {\n          node[subNode.name] = [node[subNode.name]]\n        }\n\n        node[subNode.name].push(subNode)\n      } else if (node[subNode.name][subNode.id] === undefined) {\n        node[subNode.name][subNode.id] = subNode\n      }\n    }\n  }\n\n  parseProperty(reader) {\n    const type = reader.getString(1)\n    let length\n\n    switch (type) {\n      case 'C':\n        return reader.getBoolean()\n\n      case 'D':\n        return reader.getFloat64()\n\n      case 'F':\n        return reader.getFloat32()\n\n      case 'I':\n        return reader.getInt32()\n\n      case 'L':\n        return reader.getInt64()\n\n      case 'R':\n        length = reader.getUint32()\n        return reader.getArrayBuffer(length)\n\n      case 'S':\n        length = reader.getUint32()\n        return reader.getString(length)\n\n      case 'Y':\n        return reader.getInt16()\n\n      case 'b':\n      case 'c':\n      case 'd':\n      case 'f':\n      case 'i':\n      case 'l':\n        const arrayLength = reader.getUint32()\n        const encoding = reader.getUint32() // 0: non-compressed, 1: compressed\n        const compressedLength = reader.getUint32()\n\n        if (encoding === 0) {\n          switch (type) {\n            case 'b':\n            case 'c':\n              return reader.getBooleanArray(arrayLength)\n\n            case 'd':\n              return reader.getFloat64Array(arrayLength)\n\n            case 'f':\n              return reader.getFloat32Array(arrayLength)\n\n            case 'i':\n              return reader.getInt32Array(arrayLength)\n\n            case 'l':\n              return reader.getInt64Array(arrayLength)\n          }\n        }\n\n        const data = unzlibSync(new Uint8Array(reader.getArrayBuffer(compressedLength)))\n        const reader2 = new BinaryReader(data.buffer)\n\n        switch (type) {\n          case 'b':\n          case 'c':\n            return reader2.getBooleanArray(arrayLength)\n\n          case 'd':\n            return reader2.getFloat64Array(arrayLength)\n\n          case 'f':\n            return reader2.getFloat32Array(arrayLength)\n\n          case 'i':\n            return reader2.getInt32Array(arrayLength)\n\n          case 'l':\n            return reader2.getInt64Array(arrayLength)\n        }\n\n      default:\n        throw new Error('THREE.FBXLoader: Unknown property type ' + type)\n    }\n  }\n}\n\nclass BinaryReader {\n  constructor(buffer, littleEndian) {\n    this.dv = new DataView(buffer)\n    this.offset = 0\n    this.littleEndian = littleEndian !== undefined ? littleEndian : true\n  }\n\n  getOffset() {\n    return this.offset\n  }\n\n  size() {\n    return this.dv.buffer.byteLength\n  }\n\n  skip(length) {\n    this.offset += length\n  }\n\n  // seems like true/false representation depends on exporter.\n  // true: 1 or 'Y'(=0x59), false: 0 or 'T'(=0x54)\n  // then sees LSB.\n  getBoolean() {\n    return (this.getUint8() & 1) === 1\n  }\n\n  getBooleanArray(size) {\n    const a = []\n\n    for (let i = 0; i < size; i++) {\n      a.push(this.getBoolean())\n    }\n\n    return a\n  }\n\n  getUint8() {\n    const value = this.dv.getUint8(this.offset)\n    this.offset += 1\n    return value\n  }\n\n  getInt16() {\n    const value = this.dv.getInt16(this.offset, this.littleEndian)\n    this.offset += 2\n    return value\n  }\n\n  getInt32() {\n    const value = this.dv.getInt32(this.offset, this.littleEndian)\n    this.offset += 4\n    return value\n  }\n\n  getInt32Array(size) {\n    const a = []\n\n    for (let i = 0; i < size; i++) {\n      a.push(this.getInt32())\n    }\n\n    return a\n  }\n\n  getUint32() {\n    const value = this.dv.getUint32(this.offset, this.littleEndian)\n    this.offset += 4\n    return value\n  }\n\n  // JavaScript doesn't support 64-bit integer so calculate this here\n  // 1 << 32 will return 1 so using multiply operation instead here.\n  // There's a possibility that this method returns wrong value if the value\n  // is out of the range between Number.MAX_SAFE_INTEGER and Number.MIN_SAFE_INTEGER.\n  // TODO: safely handle 64-bit integer\n  getInt64() {\n    let low, high\n\n    if (this.littleEndian) {\n      low = this.getUint32()\n      high = this.getUint32()\n    } else {\n      high = this.getUint32()\n      low = this.getUint32()\n    }\n\n    // calculate negative value\n    if (high & 0x80000000) {\n      high = ~high & 0xffffffff\n      low = ~low & 0xffffffff\n\n      if (low === 0xffffffff) high = (high + 1) & 0xffffffff\n\n      low = (low + 1) & 0xffffffff\n\n      return -(high * 0x100000000 + low)\n    }\n\n    return high * 0x100000000 + low\n  }\n\n  getInt64Array(size) {\n    const a = []\n\n    for (let i = 0; i < size; i++) {\n      a.push(this.getInt64())\n    }\n\n    return a\n  }\n\n  // Note: see getInt64() comment\n  getUint64() {\n    let low, high\n\n    if (this.littleEndian) {\n      low = this.getUint32()\n      high = this.getUint32()\n    } else {\n      high = this.getUint32()\n      low = this.getUint32()\n    }\n\n    return high * 0x100000000 + low\n  }\n\n  getFloat32() {\n    const value = this.dv.getFloat32(this.offset, this.littleEndian)\n    this.offset += 4\n    return value\n  }\n\n  getFloat32Array(size) {\n    const a = []\n\n    for (let i = 0; i < size; i++) {\n      a.push(this.getFloat32())\n    }\n\n    return a\n  }\n\n  getFloat64() {\n    const value = this.dv.getFloat64(this.offset, this.littleEndian)\n    this.offset += 8\n    return value\n  }\n\n  getFloat64Array(size) {\n    const a = []\n\n    for (let i = 0; i < size; i++) {\n      a.push(this.getFloat64())\n    }\n\n    return a\n  }\n\n  getArrayBuffer(size) {\n    const value = this.dv.buffer.slice(this.offset, this.offset + size)\n    this.offset += size\n    return value\n  }\n\n  getString(size) {\n    // note: safari 9 doesn't support Uint8Array.indexOf; create intermediate array instead\n    let a = []\n\n    for (let i = 0; i < size; i++) {\n      a[i] = this.getUint8()\n    }\n\n    const nullByte = a.indexOf(0)\n    if (nullByte >= 0) a = a.slice(0, nullByte)\n\n    return decodeText(new Uint8Array(a))\n  }\n}\n\n// FBXTree holds a representation of the FBX data, returned by the TextParser ( FBX ASCII format)\n// and BinaryParser( FBX Binary format)\nclass FBXTree {\n  add(key, val) {\n    this[key] = val\n  }\n}\n\n// ************** UTILITY FUNCTIONS **************\n\nfunction isFbxFormatBinary(buffer) {\n  const CORRECT = 'Kaydara\\u0020FBX\\u0020Binary\\u0020\\u0020\\0'\n\n  return buffer.byteLength >= CORRECT.length && CORRECT === convertArrayBufferToString(buffer, 0, CORRECT.length)\n}\n\nfunction isFbxFormatASCII(text) {\n  const CORRECT = [\n    'K',\n    'a',\n    'y',\n    'd',\n    'a',\n    'r',\n    'a',\n    '\\\\',\n    'F',\n    'B',\n    'X',\n    '\\\\',\n    'B',\n    'i',\n    'n',\n    'a',\n    'r',\n    'y',\n    '\\\\',\n    '\\\\',\n  ]\n\n  let cursor = 0\n\n  function read(offset) {\n    const result = text[offset - 1]\n    text = text.slice(cursor + offset)\n    cursor++\n    return result\n  }\n\n  for (let i = 0; i < CORRECT.length; ++i) {\n    const num = read(1)\n    if (num === CORRECT[i]) {\n      return false\n    }\n  }\n\n  return true\n}\n\nfunction getFbxVersion(text) {\n  const versionRegExp = /FBXVersion: (\\d+)/\n  const match = text.match(versionRegExp)\n\n  if (match) {\n    const version = parseInt(match[1])\n    return version\n  }\n\n  throw new Error('THREE.FBXLoader: Cannot find the version number for the file given.')\n}\n\n// Converts FBX ticks into real time seconds.\nfunction convertFBXTimeToSeconds(time) {\n  return time / 46186158000\n}\n\nconst dataArray = []\n\n// extracts the data from the correct position in the FBX array based on indexing type\nfunction getData(polygonVertexIndex, polygonIndex, vertexIndex, infoObject) {\n  let index\n\n  switch (infoObject.mappingType) {\n    case 'ByPolygonVertex':\n      index = polygonVertexIndex\n      break\n    case 'ByPolygon':\n      index = polygonIndex\n      break\n    case 'ByVertice':\n      index = vertexIndex\n      break\n    case 'AllSame':\n      index = infoObject.indices[0]\n      break\n    default:\n      console.warn('THREE.FBXLoader: unknown attribute mapping type ' + infoObject.mappingType)\n  }\n\n  if (infoObject.referenceType === 'IndexToDirect') index = infoObject.indices[index]\n\n  const from = index * infoObject.dataSize\n  const to = from + infoObject.dataSize\n\n  return slice(dataArray, infoObject.buffer, from, to)\n}\n\nconst tempEuler = /* @__PURE__ */ new Euler()\nconst tempVec = /* @__PURE__ */ new Vector3()\n\n// generate transformation from FBX transform data\n// ref: https://help.autodesk.com/view/FBX/2017/ENU/?guid=__files_GUID_10CDD63C_79C1_4F2D_BB28_AD2BE65A02ED_htm\n// ref: http://docs.autodesk.com/FBX/2014/ENU/FBX-SDK-Documentation/index.html?url=cpp_ref/_transformations_2main_8cxx-example.html,topicNumber=cpp_ref__transformations_2main_8cxx_example_htmlfc10a1e1-b18d-4e72-9dc0-70d0f1959f5e\nfunction generateTransform(transformData) {\n  const lTranslationM = new Matrix4()\n  const lPreRotationM = new Matrix4()\n  const lRotationM = new Matrix4()\n  const lPostRotationM = new Matrix4()\n\n  const lScalingM = new Matrix4()\n  const lScalingPivotM = new Matrix4()\n  const lScalingOffsetM = new Matrix4()\n  const lRotationOffsetM = new Matrix4()\n  const lRotationPivotM = new Matrix4()\n\n  const lParentGX = new Matrix4()\n  const lParentLX = new Matrix4()\n  const lGlobalT = new Matrix4()\n\n  const inheritType = transformData.inheritType ? transformData.inheritType : 0\n\n  if (transformData.translation) lTranslationM.setPosition(tempVec.fromArray(transformData.translation))\n\n  if (transformData.preRotation) {\n    const array = transformData.preRotation.map(MathUtils.degToRad)\n    array.push(transformData.eulerOrder)\n    lPreRotationM.makeRotationFromEuler(tempEuler.fromArray(array))\n  }\n\n  if (transformData.rotation) {\n    const array = transformData.rotation.map(MathUtils.degToRad)\n    array.push(transformData.eulerOrder)\n    lRotationM.makeRotationFromEuler(tempEuler.fromArray(array))\n  }\n\n  if (transformData.postRotation) {\n    const array = transformData.postRotation.map(MathUtils.degToRad)\n    array.push(transformData.eulerOrder)\n    lPostRotationM.makeRotationFromEuler(tempEuler.fromArray(array))\n    lPostRotationM.invert()\n  }\n\n  if (transformData.scale) lScalingM.scale(tempVec.fromArray(transformData.scale))\n\n  // Pivots and offsets\n  if (transformData.scalingOffset) lScalingOffsetM.setPosition(tempVec.fromArray(transformData.scalingOffset))\n  if (transformData.scalingPivot) lScalingPivotM.setPosition(tempVec.fromArray(transformData.scalingPivot))\n  if (transformData.rotationOffset) lRotationOffsetM.setPosition(tempVec.fromArray(transformData.rotationOffset))\n  if (transformData.rotationPivot) lRotationPivotM.setPosition(tempVec.fromArray(transformData.rotationPivot))\n\n  // parent transform\n  if (transformData.parentMatrixWorld) {\n    lParentLX.copy(transformData.parentMatrix)\n    lParentGX.copy(transformData.parentMatrixWorld)\n  }\n\n  const lLRM = lPreRotationM.clone().multiply(lRotationM).multiply(lPostRotationM)\n  // Global Rotation\n  const lParentGRM = new Matrix4()\n  lParentGRM.extractRotation(lParentGX)\n\n  // Global Shear*Scaling\n  const lParentTM = new Matrix4()\n  lParentTM.copyPosition(lParentGX)\n\n  const lParentGRSM = lParentTM.clone().invert().multiply(lParentGX)\n  const lParentGSM = lParentGRM.clone().invert().multiply(lParentGRSM)\n  const lLSM = lScalingM\n\n  const lGlobalRS = new Matrix4()\n\n  if (inheritType === 0) {\n    lGlobalRS.copy(lParentGRM).multiply(lLRM).multiply(lParentGSM).multiply(lLSM)\n  } else if (inheritType === 1) {\n    lGlobalRS.copy(lParentGRM).multiply(lParentGSM).multiply(lLRM).multiply(lLSM)\n  } else {\n    const lParentLSM = new Matrix4().scale(new Vector3().setFromMatrixScale(lParentLX))\n    const lParentLSM_inv = lParentLSM.clone().invert()\n    const lParentGSM_noLocal = lParentGSM.clone().multiply(lParentLSM_inv)\n\n    lGlobalRS.copy(lParentGRM).multiply(lLRM).multiply(lParentGSM_noLocal).multiply(lLSM)\n  }\n\n  const lRotationPivotM_inv = lRotationPivotM.clone().invert()\n  const lScalingPivotM_inv = lScalingPivotM.clone().invert()\n  // Calculate the local transform matrix\n  let lTransform = lTranslationM\n    .clone()\n    .multiply(lRotationOffsetM)\n    .multiply(lRotationPivotM)\n    .multiply(lPreRotationM)\n    .multiply(lRotationM)\n    .multiply(lPostRotationM)\n    .multiply(lRotationPivotM_inv)\n    .multiply(lScalingOffsetM)\n    .multiply(lScalingPivotM)\n    .multiply(lScalingM)\n    .multiply(lScalingPivotM_inv)\n\n  const lLocalTWithAllPivotAndOffsetInfo = new Matrix4().copyPosition(lTransform)\n\n  const lGlobalTranslation = lParentGX.clone().multiply(lLocalTWithAllPivotAndOffsetInfo)\n  lGlobalT.copyPosition(lGlobalTranslation)\n\n  lTransform = lGlobalT.clone().multiply(lGlobalRS)\n\n  // from global to local\n  lTransform.premultiply(lParentGX.invert())\n\n  return lTransform\n}\n\n// Returns the three.js intrinsic Euler order corresponding to FBX extrinsic Euler order\n// ref: http://help.autodesk.com/view/FBX/2017/ENU/?guid=__cpp_ref_class_fbx_euler_html\nfunction getEulerOrder(order) {\n  order = order || 0\n\n  const enums = [\n    'ZYX', // -> XYZ extrinsic\n    'YZX', // -> XZY extrinsic\n    'XZY', // -> YZX extrinsic\n    'ZXY', // -> YXZ extrinsic\n    'YXZ', // -> ZXY extrinsic\n    'XYZ', // -> ZYX extrinsic\n    //'SphericXYZ', // not possible to support\n  ]\n\n  if (order === 6) {\n    console.warn('THREE.FBXLoader: unsupported Euler Order: Spherical XYZ. Animations and rotations may be incorrect.')\n    return enums[0]\n  }\n\n  return enums[order]\n}\n\n// Parses comma separated list of numbers and returns them an array.\n// Used internally by the TextParser\nfunction parseNumberArray(value) {\n  const array = value.split(',').map(function (val) {\n    return parseFloat(val)\n  })\n\n  return array\n}\n\nfunction convertArrayBufferToString(buffer, from, to) {\n  if (from === undefined) from = 0\n  if (to === undefined) to = buffer.byteLength\n\n  return decodeText(new Uint8Array(buffer, from, to))\n}\n\nfunction append(a, b) {\n  for (let i = 0, j = a.length, l = b.length; i < l; i++, j++) {\n    a[j] = b[i]\n  }\n}\n\nfunction slice(a, b, from, to) {\n  for (let i = from, j = 0; i < to; i++, j++) {\n    a[j] = b[i]\n  }\n\n  return a\n}\n\n// inject array a2 into array a1 at index\nfunction inject(a1, index, a2) {\n  return a1.slice(0, index).concat(a2).concat(a1.slice(index))\n}\n\nexport { FBXLoader }\n"],"names":["child","material","skeleton"],"mappings":"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","debugId":null}},
    {"offset": {"line": 7182, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/three-stdlib@2.36.1_three@0.182.0/node_modules/three-stdlib/loaders/KTX2Loader.js","sources":["file:///C:/coqueli/frontend/node_modules/.pnpm/three-stdlib%402.36.1_three%400.182.0/node_modules/src/loaders/KTX2Loader.js"],"sourcesContent":["/**\n * Loader for KTX 2.0 GPU Texture containers.\n *\n * KTX 2.0 is a container format for various GPU texture formats. The loader\n * supports Basis Universal GPU textures, which can be quickly transcoded to\n * a wide variety of GPU texture compression formats, as well as some\n * uncompressed DataTexture and Data3DTexture formats.\n *\n * References:\n * - KTX: http://github.khronos.org/KTX-Specification/\n * - DFD: https://www.khronos.org/registry/DataFormat/specs/1.3/dataformat.1.3.html#basicdescriptor\n */\n\nimport {\n  CompressedTexture,\n  DataTexture,\n  FileLoader,\n  FloatType,\n  HalfFloatType,\n  LinearFilter,\n  LinearMipmapLinearFilter,\n  Loader,\n  RedFormat,\n  RGB_ETC1_Format,\n  RGB_ETC2_Format,\n  RGB_PVRTC_4BPPV1_Format,\n  RGB_S3TC_DXT1_Format,\n  RGBA_ASTC_4x4_Format,\n  RGBA_ASTC_6x6_Format,\n  RGBA_BPTC_Format,\n  RGBA_ETC2_EAC_Format,\n  RGBA_PVRTC_4BPPV1_Format,\n  RGBA_S3TC_DXT5_Format,\n  RGBAFormat,\n  RGFormat,\n  UnsignedByteType,\n} from 'three'\nimport { WorkerPool } from '../utils/WorkerPool'\nimport {\n  read,\n  KHR_DF_FLAG_ALPHA_PREMULTIPLIED,\n  KHR_DF_TRANSFER_SRGB,\n  KHR_SUPERCOMPRESSION_NONE,\n  KHR_SUPERCOMPRESSION_ZSTD,\n  VK_FORMAT_UNDEFINED,\n  VK_FORMAT_R16_SFLOAT,\n  VK_FORMAT_R16G16_SFLOAT,\n  VK_FORMAT_R16G16B16A16_SFLOAT,\n  VK_FORMAT_R32_SFLOAT,\n  VK_FORMAT_R32G32_SFLOAT,\n  VK_FORMAT_R32G32B32A32_SFLOAT,\n  VK_FORMAT_R8_SRGB,\n  VK_FORMAT_R8_UNORM,\n  VK_FORMAT_R8G8_SRGB,\n  VK_FORMAT_R8G8_UNORM,\n  VK_FORMAT_R8G8B8A8_SRGB,\n  VK_FORMAT_R8G8B8A8_UNORM,\n  VK_FORMAT_ASTC_6x6_SRGB_BLOCK,\n  VK_FORMAT_ASTC_6x6_UNORM_BLOCK,\n  KHR_DF_PRIMARIES_UNSPECIFIED,\n  KHR_DF_PRIMARIES_BT709,\n  KHR_DF_PRIMARIES_DISPLAYP3,\n} from '../libs/ktx-parse'\nimport { ZSTDDecoder } from '../libs/zstddec'\nimport { CompressedCubeTexture } from '../_polyfill/CompressedCubeTexture'\nimport { CompressedArrayTexture } from '../_polyfill/CompressedArrayTexture'\nimport { Data3DTexture } from '../_polyfill/Data3DTexture'\n\nconst LinearEncoding = 3000\nconst sRGBEncoding = 3001\n\nconst NoColorSpace = ''\nconst DisplayP3ColorSpace = 'display-p3'\nconst LinearDisplayP3ColorSpace = 'display-p3-linear'\nconst LinearSRGBColorSpace = 'srgb-linear'\nconst SRGBColorSpace = 'srgb'\n\nconst _taskCache = new WeakMap()\n\nlet _activeLoaders = 0\n\nlet _zstd\n\nconst KTX2Loader = /* @__PURE__ */ (() => {\n  class KTX2Loader extends Loader {\n    /* CONSTANTS */\n\n    static BasisFormat = {\n      ETC1S: 0,\n      UASTC_4x4: 1,\n    }\n\n    static TranscoderFormat = {\n      ETC1: 0,\n      ETC2: 1,\n      BC1: 2,\n      BC3: 3,\n      BC4: 4,\n      BC5: 5,\n      BC7_M6_OPAQUE_ONLY: 6,\n      BC7_M5: 7,\n      PVRTC1_4_RGB: 8,\n      PVRTC1_4_RGBA: 9,\n      ASTC_4x4: 10,\n      ATC_RGB: 11,\n      ATC_RGBA_INTERPOLATED_ALPHA: 12,\n      RGBA32: 13,\n      RGB565: 14,\n      BGR565: 15,\n      RGBA4444: 16,\n    }\n\n    static EngineFormat = {\n      RGBAFormat: RGBAFormat,\n      RGBA_ASTC_4x4_Format: RGBA_ASTC_4x4_Format,\n      RGBA_BPTC_Format: RGBA_BPTC_Format,\n      RGBA_ETC2_EAC_Format: RGBA_ETC2_EAC_Format,\n      RGBA_PVRTC_4BPPV1_Format: RGBA_PVRTC_4BPPV1_Format,\n      RGBA_S3TC_DXT5_Format: RGBA_S3TC_DXT5_Format,\n      RGB_ETC1_Format: RGB_ETC1_Format,\n      RGB_ETC2_Format: RGB_ETC2_Format,\n      RGB_PVRTC_4BPPV1_Format: RGB_PVRTC_4BPPV1_Format,\n      RGB_S3TC_DXT1_Format: RGB_S3TC_DXT1_Format,\n    }\n\n    /* WEB WORKER */\n\n    static BasisWorker = function () {\n      let config\n      let transcoderPending\n      let BasisModule\n\n      /** @type KTX2Loader.EngineFormat */\n      const EngineFormat = _EngineFormat\n      /** @type KTX2Loader.TranscoderFormat */\n      const TranscoderFormat = _TranscoderFormat\n      /** @type KTX2Loader.BasisFormat */\n      const BasisFormat = _BasisFormat\n\n      self.addEventListener('message', function (e) {\n        const message = e.data\n\n        switch (message.type) {\n          case 'init':\n            config = message.config\n            init(message.transcoderBinary)\n            break\n\n          case 'transcode':\n            transcoderPending.then(() => {\n              try {\n                const { faces, buffers, width, height, hasAlpha, format, dfdFlags } = transcode(message.buffer)\n\n                self.postMessage(\n                  { type: 'transcode', id: message.id, faces, width, height, hasAlpha, format, dfdFlags },\n                  buffers,\n                )\n              } catch (error) {\n                console.error(error)\n\n                self.postMessage({ type: 'error', id: message.id, error: error.message })\n              }\n            })\n            break\n        }\n      })\n\n      function init(wasmBinary) {\n        transcoderPending = new Promise((resolve) => {\n          BasisModule = { wasmBinary, onRuntimeInitialized: resolve }\n          BASIS(BasisModule)\n        }).then(() => {\n          BasisModule.initializeBasis()\n\n          if (BasisModule.KTX2File === undefined) {\n            console.warn('THREE.KTX2Loader: Please update Basis Universal transcoder.')\n          }\n        })\n      }\n\n      function transcode(buffer) {\n        const ktx2File = new BasisModule.KTX2File(new Uint8Array(buffer))\n\n        function cleanup() {\n          ktx2File.close()\n          ktx2File.delete()\n        }\n\n        if (!ktx2File.isValid()) {\n          cleanup()\n          throw new Error('THREE.KTX2Loader:\tInvalid or unsupported .ktx2 file')\n        }\n\n        const basisFormat = ktx2File.isUASTC() ? BasisFormat.UASTC_4x4 : BasisFormat.ETC1S\n        const width = ktx2File.getWidth()\n        const height = ktx2File.getHeight()\n        const layerCount = ktx2File.getLayers() || 1\n        const levelCount = ktx2File.getLevels()\n        const faceCount = ktx2File.getFaces()\n        const hasAlpha = ktx2File.getHasAlpha()\n        const dfdFlags = ktx2File.getDFDFlags()\n\n        const { transcoderFormat, engineFormat } = getTranscoderFormat(basisFormat, width, height, hasAlpha)\n\n        if (!width || !height || !levelCount) {\n          cleanup()\n          throw new Error('THREE.KTX2Loader:\tInvalid texture')\n        }\n\n        if (!ktx2File.startTranscoding()) {\n          cleanup()\n          throw new Error('THREE.KTX2Loader: .startTranscoding failed')\n        }\n\n        const faces = []\n        const buffers = []\n\n        for (let face = 0; face < faceCount; face++) {\n          const mipmaps = []\n\n          for (let mip = 0; mip < levelCount; mip++) {\n            const layerMips = []\n\n            let mipWidth, mipHeight\n\n            for (let layer = 0; layer < layerCount; layer++) {\n              const levelInfo = ktx2File.getImageLevelInfo(mip, layer, face)\n\n              if (\n                face === 0 &&\n                mip === 0 &&\n                layer === 0 &&\n                (levelInfo.origWidth % 4 !== 0 || levelInfo.origHeight % 4 !== 0)\n              ) {\n                console.warn('THREE.KTX2Loader: ETC1S and UASTC textures should use multiple-of-four dimensions.')\n              }\n\n              if (levelCount > 1) {\n                mipWidth = levelInfo.origWidth\n                mipHeight = levelInfo.origHeight\n              } else {\n                // Handles non-multiple-of-four dimensions in textures without mipmaps. Textures with\n                // mipmaps must use multiple-of-four dimensions, for some texture formats and APIs.\n                // See mrdoob/three.js#25908.\n                mipWidth = levelInfo.width\n                mipHeight = levelInfo.height\n              }\n\n              const dst = new Uint8Array(ktx2File.getImageTranscodedSizeInBytes(mip, layer, 0, transcoderFormat))\n              const status = ktx2File.transcodeImage(dst, mip, layer, face, transcoderFormat, 0, -1, -1)\n\n              if (!status) {\n                cleanup()\n                throw new Error('THREE.KTX2Loader: .transcodeImage failed.')\n              }\n\n              layerMips.push(dst)\n            }\n\n            const mipData = concat(layerMips)\n\n            mipmaps.push({ data: mipData, width: mipWidth, height: mipHeight })\n            buffers.push(mipData.buffer)\n          }\n\n          faces.push({ mipmaps, width, height, format: engineFormat })\n        }\n\n        cleanup()\n\n        return { faces, buffers, width, height, hasAlpha, format: engineFormat, dfdFlags }\n      }\n\n      //\n\n      // Optimal choice of a transcoder target format depends on the Basis format (ETC1S or UASTC),\n      // device capabilities, and texture dimensions. The list below ranks the formats separately\n      // for ETC1S and UASTC.\n      //\n      // In some cases, transcoding UASTC to RGBA32 might be preferred for higher quality (at\n      // significant memory cost) compared to ETC1/2, BC1/3, and PVRTC. The transcoder currently\n      // chooses RGBA32 only as a last resort and does not expose that option to the caller.\n      const FORMAT_OPTIONS = [\n        {\n          if: 'astcSupported',\n          basisFormat: [BasisFormat.UASTC_4x4],\n          transcoderFormat: [TranscoderFormat.ASTC_4x4, TranscoderFormat.ASTC_4x4],\n          engineFormat: [EngineFormat.RGBA_ASTC_4x4_Format, EngineFormat.RGBA_ASTC_4x4_Format],\n          priorityETC1S: Infinity,\n          priorityUASTC: 1,\n          needsPowerOfTwo: false,\n        },\n        {\n          if: 'bptcSupported',\n          basisFormat: [BasisFormat.ETC1S, BasisFormat.UASTC_4x4],\n          transcoderFormat: [TranscoderFormat.BC7_M5, TranscoderFormat.BC7_M5],\n          engineFormat: [EngineFormat.RGBA_BPTC_Format, EngineFormat.RGBA_BPTC_Format],\n          priorityETC1S: 3,\n          priorityUASTC: 2,\n          needsPowerOfTwo: false,\n        },\n        {\n          if: 'dxtSupported',\n          basisFormat: [BasisFormat.ETC1S, BasisFormat.UASTC_4x4],\n          transcoderFormat: [TranscoderFormat.BC1, TranscoderFormat.BC3],\n          engineFormat: [EngineFormat.RGB_S3TC_DXT1_Format, EngineFormat.RGBA_S3TC_DXT5_Format],\n          priorityETC1S: 4,\n          priorityUASTC: 5,\n          needsPowerOfTwo: false,\n        },\n        {\n          if: 'etc2Supported',\n          basisFormat: [BasisFormat.ETC1S, BasisFormat.UASTC_4x4],\n          transcoderFormat: [TranscoderFormat.ETC1, TranscoderFormat.ETC2],\n          engineFormat: [EngineFormat.RGB_ETC2_Format, EngineFormat.RGBA_ETC2_EAC_Format],\n          priorityETC1S: 1,\n          priorityUASTC: 3,\n          needsPowerOfTwo: false,\n        },\n        {\n          if: 'etc1Supported',\n          basisFormat: [BasisFormat.ETC1S, BasisFormat.UASTC_4x4],\n          transcoderFormat: [TranscoderFormat.ETC1],\n          engineFormat: [EngineFormat.RGB_ETC1_Format],\n          priorityETC1S: 2,\n          priorityUASTC: 4,\n          needsPowerOfTwo: false,\n        },\n        {\n          if: 'pvrtcSupported',\n          basisFormat: [BasisFormat.ETC1S, BasisFormat.UASTC_4x4],\n          transcoderFormat: [TranscoderFormat.PVRTC1_4_RGB, TranscoderFormat.PVRTC1_4_RGBA],\n          engineFormat: [EngineFormat.RGB_PVRTC_4BPPV1_Format, EngineFormat.RGBA_PVRTC_4BPPV1_Format],\n          priorityETC1S: 5,\n          priorityUASTC: 6,\n          needsPowerOfTwo: true,\n        },\n      ]\n\n      const ETC1S_OPTIONS = FORMAT_OPTIONS.sort(function (a, b) {\n        return a.priorityETC1S - b.priorityETC1S\n      })\n      const UASTC_OPTIONS = FORMAT_OPTIONS.sort(function (a, b) {\n        return a.priorityUASTC - b.priorityUASTC\n      })\n\n      function getTranscoderFormat(basisFormat, width, height, hasAlpha) {\n        let transcoderFormat\n        let engineFormat\n\n        const options = basisFormat === BasisFormat.ETC1S ? ETC1S_OPTIONS : UASTC_OPTIONS\n\n        for (let i = 0; i < options.length; i++) {\n          const opt = options[i]\n\n          if (!config[opt.if]) continue\n          if (!opt.basisFormat.includes(basisFormat)) continue\n          if (hasAlpha && opt.transcoderFormat.length < 2) continue\n          if (opt.needsPowerOfTwo && !(isPowerOfTwo(width) && isPowerOfTwo(height))) continue\n\n          transcoderFormat = opt.transcoderFormat[hasAlpha ? 1 : 0]\n          engineFormat = opt.engineFormat[hasAlpha ? 1 : 0]\n\n          return { transcoderFormat, engineFormat }\n        }\n\n        console.warn('THREE.KTX2Loader: No suitable compressed texture format found. Decoding to RGBA32.')\n\n        transcoderFormat = TranscoderFormat.RGBA32\n        engineFormat = EngineFormat.RGBAFormat\n\n        return { transcoderFormat, engineFormat }\n      }\n\n      function isPowerOfTwo(value) {\n        if (value <= 2) return true\n\n        return (value & (value - 1)) === 0 && value !== 0\n      }\n\n      /** Concatenates N byte arrays. */\n      function concat(arrays) {\n        if (arrays.length === 1) return arrays[0]\n\n        let totalByteLength = 0\n\n        for (let i = 0; i < arrays.length; i++) {\n          const array = arrays[i]\n          totalByteLength += array.byteLength\n        }\n\n        const result = new Uint8Array(totalByteLength)\n\n        let byteOffset = 0\n\n        for (let i = 0; i < arrays.length; i++) {\n          const array = arrays[i]\n          result.set(array, byteOffset)\n\n          byteOffset += array.byteLength\n        }\n\n        return result\n      }\n    }\n\n    constructor(manager) {\n      super(manager)\n\n      this.transcoderPath = ''\n      this.transcoderBinary = null\n      this.transcoderPending = null\n\n      this.workerPool = new WorkerPool()\n      this.workerSourceURL = ''\n      this.workerConfig = null\n\n      if (typeof MSC_TRANSCODER !== 'undefined') {\n        console.warn(\n          'THREE.KTX2Loader: Please update to latest \"basis_transcoder\".' +\n            ' \"msc_basis_transcoder\" is no longer supported in three.js r125+.',\n        )\n      }\n    }\n\n    setTranscoderPath(path) {\n      this.transcoderPath = path\n\n      return this\n    }\n\n    setWorkerLimit(num) {\n      this.workerPool.setWorkerLimit(num)\n\n      return this\n    }\n\n    detectSupport(renderer) {\n      this.workerConfig = {\n        astcSupported: renderer.extensions.has('WEBGL_compressed_texture_astc'),\n        etc1Supported: renderer.extensions.has('WEBGL_compressed_texture_etc1'),\n        etc2Supported: renderer.extensions.has('WEBGL_compressed_texture_etc'),\n        dxtSupported: renderer.extensions.has('WEBGL_compressed_texture_s3tc'),\n        bptcSupported: renderer.extensions.has('EXT_texture_compression_bptc'),\n        pvrtcSupported:\n          renderer.extensions.has('WEBGL_compressed_texture_pvrtc') ||\n          renderer.extensions.has('WEBKIT_WEBGL_compressed_texture_pvrtc'),\n      }\n\n      if (renderer.capabilities.isWebGL2) {\n        // https://github.com/mrdoob/three.js/pull/22928\n        this.workerConfig.etc1Supported = false\n      }\n\n      return this\n    }\n\n    init() {\n      if (!this.transcoderPending) {\n        // Load transcoder wrapper.\n        const jsLoader = new FileLoader(this.manager)\n        jsLoader.setPath(this.transcoderPath)\n        jsLoader.setWithCredentials(this.withCredentials)\n        const jsContent = jsLoader.loadAsync('basis_transcoder.js')\n\n        // Load transcoder WASM binary.\n        const binaryLoader = new FileLoader(this.manager)\n        binaryLoader.setPath(this.transcoderPath)\n        binaryLoader.setResponseType('arraybuffer')\n        binaryLoader.setWithCredentials(this.withCredentials)\n        const binaryContent = binaryLoader.loadAsync('basis_transcoder.wasm')\n\n        this.transcoderPending = Promise.all([jsContent, binaryContent]).then(([jsContent, binaryContent]) => {\n          const fn = KTX2Loader.BasisWorker.toString()\n\n          const body = [\n            '/* constants */',\n            'let _EngineFormat = ' + JSON.stringify(KTX2Loader.EngineFormat),\n            'let _TranscoderFormat = ' + JSON.stringify(KTX2Loader.TranscoderFormat),\n            'let _BasisFormat = ' + JSON.stringify(KTX2Loader.BasisFormat),\n            '/* basis_transcoder.js */',\n            jsContent,\n            '/* worker */',\n            fn.substring(fn.indexOf('{') + 1, fn.lastIndexOf('}')),\n          ].join('\\n')\n\n          this.workerSourceURL = URL.createObjectURL(new Blob([body]))\n          this.transcoderBinary = binaryContent\n\n          this.workerPool.setWorkerCreator(() => {\n            const worker = new Worker(this.workerSourceURL)\n            const transcoderBinary = this.transcoderBinary.slice(0)\n\n            worker.postMessage({ type: 'init', config: this.workerConfig, transcoderBinary }, [transcoderBinary])\n\n            return worker\n          })\n        })\n\n        if (_activeLoaders > 0) {\n          // Each instance loads a transcoder and allocates workers, increasing network and memory cost.\n\n          console.warn(\n            'THREE.KTX2Loader: Multiple active KTX2 loaders may cause performance issues.' +\n              ' Use a single KTX2Loader instance, or call .dispose() on old instances.',\n          )\n        }\n\n        _activeLoaders++\n      }\n\n      return this.transcoderPending\n    }\n\n    load(url, onLoad, onProgress, onError) {\n      if (this.workerConfig === null) {\n        throw new Error('THREE.KTX2Loader: Missing initialization with `.detectSupport( renderer )`.')\n      }\n\n      const loader = new FileLoader(this.manager)\n\n      loader.setResponseType('arraybuffer')\n      loader.setWithCredentials(this.withCredentials)\n\n      loader.load(\n        url,\n        (buffer) => {\n          // Check for an existing task using this buffer. A transferred buffer cannot be transferred\n          // again from this thread.\n          if (_taskCache.has(buffer)) {\n            const cachedTask = _taskCache.get(buffer)\n\n            return cachedTask.promise.then(onLoad).catch(onError)\n          }\n\n          this._createTexture(buffer)\n            .then((texture) => (onLoad ? onLoad(texture) : null))\n            .catch(onError)\n        },\n        onProgress,\n        onError,\n      )\n    }\n\n    _createTextureFrom(transcodeResult, container) {\n      const { faces, width, height, format, type, error, dfdFlags } = transcodeResult\n\n      if (type === 'error') return Promise.reject(error)\n\n      let texture\n\n      if (container.faceCount === 6) {\n        texture = new CompressedCubeTexture(faces, format, UnsignedByteType)\n      } else {\n        const mipmaps = faces[0].mipmaps\n\n        texture =\n          container.layerCount > 1\n            ? new CompressedArrayTexture(mipmaps, width, height, container.layerCount, format, UnsignedByteType)\n            : new CompressedTexture(mipmaps, width, height, format, UnsignedByteType)\n      }\n\n      texture.minFilter = faces[0].mipmaps.length === 1 ? LinearFilter : LinearMipmapLinearFilter\n      texture.magFilter = LinearFilter\n      texture.generateMipmaps = false\n      texture.needsUpdate = true\n\n      const colorSpace = parseColorSpace(container)\n      if ('colorSpace' in texture) texture.colorSpace = colorSpace\n      else texture.encoding = colorSpace === SRGBColorSpace ? sRGBEncoding : LinearEncoding\n\n      texture.premultiplyAlpha = !!(dfdFlags & KHR_DF_FLAG_ALPHA_PREMULTIPLIED)\n\n      return texture\n    }\n\n    /**\n     * @param {ArrayBuffer} buffer\n     * @param {object?} config\n     * @return {Promise<CompressedTexture|CompressedArrayTexture|DataTexture|Data3DTexture>}\n     */\n    async _createTexture(buffer, config = {}) {\n      const container = read(new Uint8Array(buffer))\n\n      if (container.vkFormat !== VK_FORMAT_UNDEFINED) {\n        return createRawTexture(container)\n      }\n\n      //\n\n      const taskConfig = config\n      const texturePending = this.init()\n        .then(() => {\n          return this.workerPool.postMessage({ type: 'transcode', buffer, taskConfig: taskConfig }, [buffer])\n        })\n        .then((e) => this._createTextureFrom(e.data, container))\n\n      // Cache the task result.\n      _taskCache.set(buffer, { promise: texturePending })\n\n      return texturePending\n    }\n\n    dispose() {\n      this.workerPool.dispose()\n      if (this.workerSourceURL) URL.revokeObjectURL(this.workerSourceURL)\n\n      _activeLoaders--\n\n      return this\n    }\n  }\n\n  return KTX2Loader\n})()\n\n//\n// Parsing for non-Basis textures. These textures are may have supercompression\n// like Zstd, but they do not require transcoding.\n\nconst UNCOMPRESSED_FORMATS = new Set([RGBAFormat, RGFormat, RedFormat])\n\nconst FORMAT_MAP = {\n  [VK_FORMAT_R32G32B32A32_SFLOAT]: RGBAFormat,\n  [VK_FORMAT_R16G16B16A16_SFLOAT]: RGBAFormat,\n  [VK_FORMAT_R8G8B8A8_UNORM]: RGBAFormat,\n  [VK_FORMAT_R8G8B8A8_SRGB]: RGBAFormat,\n\n  [VK_FORMAT_R32G32_SFLOAT]: RGFormat,\n  [VK_FORMAT_R16G16_SFLOAT]: RGFormat,\n  [VK_FORMAT_R8G8_UNORM]: RGFormat,\n  [VK_FORMAT_R8G8_SRGB]: RGFormat,\n\n  [VK_FORMAT_R32_SFLOAT]: RedFormat,\n  [VK_FORMAT_R16_SFLOAT]: RedFormat,\n  [VK_FORMAT_R8_SRGB]: RedFormat,\n  [VK_FORMAT_R8_UNORM]: RedFormat,\n\n  [VK_FORMAT_ASTC_6x6_SRGB_BLOCK]: RGBA_ASTC_6x6_Format,\n  [VK_FORMAT_ASTC_6x6_UNORM_BLOCK]: RGBA_ASTC_6x6_Format,\n}\n\nconst TYPE_MAP = {\n  [VK_FORMAT_R32G32B32A32_SFLOAT]: FloatType,\n  [VK_FORMAT_R16G16B16A16_SFLOAT]: HalfFloatType,\n  [VK_FORMAT_R8G8B8A8_UNORM]: UnsignedByteType,\n  [VK_FORMAT_R8G8B8A8_SRGB]: UnsignedByteType,\n\n  [VK_FORMAT_R32G32_SFLOAT]: FloatType,\n  [VK_FORMAT_R16G16_SFLOAT]: HalfFloatType,\n  [VK_FORMAT_R8G8_UNORM]: UnsignedByteType,\n  [VK_FORMAT_R8G8_SRGB]: UnsignedByteType,\n\n  [VK_FORMAT_R32_SFLOAT]: FloatType,\n  [VK_FORMAT_R16_SFLOAT]: HalfFloatType,\n  [VK_FORMAT_R8_SRGB]: UnsignedByteType,\n  [VK_FORMAT_R8_UNORM]: UnsignedByteType,\n\n  [VK_FORMAT_ASTC_6x6_SRGB_BLOCK]: UnsignedByteType,\n  [VK_FORMAT_ASTC_6x6_UNORM_BLOCK]: UnsignedByteType,\n}\n\nasync function createRawTexture(container) {\n  const { vkFormat } = container\n\n  if (FORMAT_MAP[vkFormat] === undefined) {\n    throw new Error('THREE.KTX2Loader: Unsupported vkFormat.')\n  }\n\n  //\n\n  let zstd\n\n  if (container.supercompressionScheme === KHR_SUPERCOMPRESSION_ZSTD) {\n    if (!_zstd) {\n      _zstd = new Promise(async (resolve) => {\n        const zstd = new ZSTDDecoder()\n        await zstd.init()\n        resolve(zstd)\n      })\n    }\n\n    zstd = await _zstd\n  }\n\n  //\n\n  const mipmaps = []\n\n  for (let levelIndex = 0; levelIndex < container.levels.length; levelIndex++) {\n    const levelWidth = Math.max(1, container.pixelWidth >> levelIndex)\n    const levelHeight = Math.max(1, container.pixelHeight >> levelIndex)\n    const levelDepth = container.pixelDepth ? Math.max(1, container.pixelDepth >> levelIndex) : 0\n\n    const level = container.levels[levelIndex]\n\n    let levelData\n\n    if (container.supercompressionScheme === KHR_SUPERCOMPRESSION_NONE) {\n      levelData = level.levelData\n    } else if (container.supercompressionScheme === KHR_SUPERCOMPRESSION_ZSTD) {\n      levelData = zstd.decode(level.levelData, level.uncompressedByteLength)\n    } else {\n      throw new Error('THREE.KTX2Loader: Unsupported supercompressionScheme.')\n    }\n\n    let data\n\n    if (TYPE_MAP[vkFormat] === FloatType) {\n      data = new Float32Array(\n        levelData.buffer,\n        levelData.byteOffset,\n        levelData.byteLength / Float32Array.BYTES_PER_ELEMENT,\n      )\n    } else if (TYPE_MAP[vkFormat] === HalfFloatType) {\n      data = new Uint16Array(\n        levelData.buffer,\n        levelData.byteOffset,\n        levelData.byteLength / Uint16Array.BYTES_PER_ELEMENT,\n      )\n    } else {\n      data = levelData\n    }\n\n    mipmaps.push({\n      data: data,\n      width: levelWidth,\n      height: levelHeight,\n      depth: levelDepth,\n    })\n  }\n\n  let texture\n\n  if (UNCOMPRESSED_FORMATS.has(FORMAT_MAP[vkFormat])) {\n    texture =\n      container.pixelDepth === 0\n        ? new DataTexture(mipmaps[0].data, container.pixelWidth, container.pixelHeight)\n        : new Data3DTexture(mipmaps[0].data, container.pixelWidth, container.pixelHeight, container.pixelDepth)\n  } else {\n    if (container.pixelDepth > 0) throw new Error('THREE.KTX2Loader: Unsupported pixelDepth.')\n\n    texture = new CompressedTexture(mipmaps, container.pixelWidth, container.pixelHeight)\n  }\n\n  texture.mipmaps = mipmaps\n\n  texture.type = TYPE_MAP[vkFormat]\n  texture.format = FORMAT_MAP[vkFormat]\n  texture.needsUpdate = true\n\n  const colorSpace = parseColorSpace(container)\n  if ('colorSpace' in texture) texture.colorSpace = colorSpace\n  else texture.encoding = colorSpace === SRGBColorSpace ? sRGBEncoding : LinearEncoding\n\n  //\n\n  return Promise.resolve(texture)\n}\n\nfunction parseColorSpace(container) {\n  const dfd = container.dataFormatDescriptor[0]\n\n  if (dfd.colorPrimaries === KHR_DF_PRIMARIES_BT709) {\n    return dfd.transferFunction === KHR_DF_TRANSFER_SRGB ? SRGBColorSpace : LinearSRGBColorSpace\n  } else if (dfd.colorPrimaries === KHR_DF_PRIMARIES_DISPLAYP3) {\n    return dfd.transferFunction === KHR_DF_TRANSFER_SRGB ? DisplayP3ColorSpace : LinearDisplayP3ColorSpace\n  } else if (dfd.colorPrimaries === KHR_DF_PRIMARIES_UNSPECIFIED) {\n    return NoColorSpace\n  } else {\n    console.warn(`THREE.KTX2Loader: Unsupported color primaries, \"${dfd.colorPrimaries}\"`)\n    return NoColorSpace\n  }\n}\n\nexport { KTX2Loader }\n"],"names":["jsContent","binaryContent","KTX2Loader","zstd"],"mappings":"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","debugId":null}},
    {"offset": {"line": 7821, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/three-stdlib@2.36.1_three@0.182.0/node_modules/three-stdlib/loaders/RGBELoader.js","sources":["file:///C:/coqueli/frontend/node_modules/.pnpm/three-stdlib%402.36.1_three%400.182.0/node_modules/src/loaders/RGBELoader.js"],"sourcesContent":["import { DataTextureLoader, DataUtils, FloatType, HalfFloatType, LinearFilter } from 'three'\n\n// https://github.com/mrdoob/three.js/issues/5552\n// http://en.wikipedia.org/wiki/RGBE_image_format\n\nclass RGBELoader extends DataTextureLoader {\n  constructor(manager) {\n    super(manager)\n\n    this.type = HalfFloatType\n  }\n\n  // adapted from http://www.graphics.cornell.edu/~bjw/rgbe.html\n\n  parse(buffer) {\n    const /* default error routine.  change this to change error handling */\n      rgbe_read_error = 1,\n      rgbe_write_error = 2,\n      rgbe_format_error = 3,\n      rgbe_memory_error = 4,\n      rgbe_error = function (rgbe_error_code, msg) {\n        switch (rgbe_error_code) {\n          case rgbe_read_error:\n            throw new Error('THREE.RGBELoader: Read Error: ' + (msg || ''))\n          case rgbe_write_error:\n            throw new Error('THREE.RGBELoader: Write Error: ' + (msg || ''))\n          case rgbe_format_error:\n            throw new Error('THREE.RGBELoader: Bad File Format: ' + (msg || ''))\n          default:\n          case rgbe_memory_error:\n            throw new Error('THREE.RGBELoader: Memory Error: ' + (msg || ''))\n        }\n      },\n      /* offsets to red, green, and blue components in a data (float) pixel */\n      //RGBE_DATA_RED = 0,\n      //RGBE_DATA_GREEN = 1,\n      //RGBE_DATA_BLUE = 2,\n\n      /* number of floats per pixel, use 4 since stored in rgba image format */\n      //RGBE_DATA_SIZE = 4,\n\n      /* flags indicating which fields in an rgbe_header_info are valid */\n      RGBE_VALID_PROGRAMTYPE = 1,\n      RGBE_VALID_FORMAT = 2,\n      RGBE_VALID_DIMENSIONS = 4,\n      NEWLINE = '\\n',\n      fgets = function (buffer, lineLimit, consume) {\n        const chunkSize = 128\n\n        lineLimit = !lineLimit ? 1024 : lineLimit\n        let p = buffer.pos,\n          i = -1,\n          len = 0,\n          s = '',\n          chunk = String.fromCharCode.apply(null, new Uint16Array(buffer.subarray(p, p + chunkSize)))\n\n        while (0 > (i = chunk.indexOf(NEWLINE)) && len < lineLimit && p < buffer.byteLength) {\n          s += chunk\n          len += chunk.length\n          p += chunkSize\n          chunk += String.fromCharCode.apply(null, new Uint16Array(buffer.subarray(p, p + chunkSize)))\n        }\n\n        if (-1 < i) {\n          /*for (i=l-1; i>=0; i--) {\n\t\t\t\t\t\tbyteCode = m.charCodeAt(i);\n\t\t\t\t\t\tif (byteCode > 0x7f && byteCode <= 0x7ff) byteLen++;\n\t\t\t\t\t\telse if (byteCode > 0x7ff && byteCode <= 0xffff) byteLen += 2;\n\t\t\t\t\t\tif (byteCode >= 0xDC00 && byteCode <= 0xDFFF) i--; //trail surrogate\n\t\t\t\t\t}*/\n          if (false !== consume) buffer.pos += len + i + 1\n          return s + chunk.slice(0, i)\n        }\n\n        return false\n      },\n      /* minimal header reading.  modify if you want to parse more information */\n      RGBE_ReadHeader = function (buffer) {\n        // regexes to parse header info fields\n        const magic_token_re = /^#\\?(\\S+)/,\n          gamma_re = /^\\s*GAMMA\\s*=\\s*(\\d+(\\.\\d+)?)\\s*$/,\n          exposure_re = /^\\s*EXPOSURE\\s*=\\s*(\\d+(\\.\\d+)?)\\s*$/,\n          format_re = /^\\s*FORMAT=(\\S+)\\s*$/,\n          dimensions_re = /^\\s*\\-Y\\s+(\\d+)\\s+\\+X\\s+(\\d+)\\s*$/,\n          // RGBE format header struct\n          header = {\n            valid: 0 /* indicate which fields are valid */,\n\n            string: '' /* the actual header string */,\n\n            comments: '' /* comments found in header */,\n\n            programtype: 'RGBE' /* listed at beginning of file to identify it after \"#?\". defaults to \"RGBE\" */,\n\n            format: '' /* RGBE format, default 32-bit_rle_rgbe */,\n\n            gamma: 1.0 /* image has already been gamma corrected with given gamma. defaults to 1.0 (no correction) */,\n\n            exposure: 1.0 /* a value of 1.0 in an image corresponds to <exposure> watts/steradian/m^2. defaults to 1.0 */,\n\n            width: 0,\n            height: 0 /* image dimensions, width/height */,\n          }\n\n        let line, match\n\n        if (buffer.pos >= buffer.byteLength || !(line = fgets(buffer))) {\n          rgbe_error(rgbe_read_error, 'no header found')\n        }\n\n        /* if you want to require the magic token then uncomment the next line */\n        if (!(match = line.match(magic_token_re))) {\n          rgbe_error(rgbe_format_error, 'bad initial token')\n        }\n\n        header.valid |= RGBE_VALID_PROGRAMTYPE\n        header.programtype = match[1]\n        header.string += line + '\\n'\n\n        while (true) {\n          line = fgets(buffer)\n          if (false === line) break\n          header.string += line + '\\n'\n\n          if ('#' === line.charAt(0)) {\n            header.comments += line + '\\n'\n            continue // comment line\n          }\n\n          if ((match = line.match(gamma_re))) {\n            header.gamma = parseFloat(match[1])\n          }\n\n          if ((match = line.match(exposure_re))) {\n            header.exposure = parseFloat(match[1])\n          }\n\n          if ((match = line.match(format_re))) {\n            header.valid |= RGBE_VALID_FORMAT\n            header.format = match[1] //'32-bit_rle_rgbe';\n          }\n\n          if ((match = line.match(dimensions_re))) {\n            header.valid |= RGBE_VALID_DIMENSIONS\n            header.height = parseInt(match[1], 10)\n            header.width = parseInt(match[2], 10)\n          }\n\n          if (header.valid & RGBE_VALID_FORMAT && header.valid & RGBE_VALID_DIMENSIONS) break\n        }\n\n        if (!(header.valid & RGBE_VALID_FORMAT)) {\n          rgbe_error(rgbe_format_error, 'missing format specifier')\n        }\n\n        if (!(header.valid & RGBE_VALID_DIMENSIONS)) {\n          rgbe_error(rgbe_format_error, 'missing image size specifier')\n        }\n\n        return header\n      },\n      RGBE_ReadPixels_RLE = function (buffer, w, h) {\n        const scanline_width = w\n\n        if (\n          // run length encoding is not allowed so read flat\n          scanline_width < 8 ||\n          scanline_width > 0x7fff ||\n          // this file is not run length encoded\n          2 !== buffer[0] ||\n          2 !== buffer[1] ||\n          buffer[2] & 0x80\n        ) {\n          // return the flat buffer\n          return new Uint8Array(buffer)\n        }\n\n        if (scanline_width !== ((buffer[2] << 8) | buffer[3])) {\n          rgbe_error(rgbe_format_error, 'wrong scanline width')\n        }\n\n        const data_rgba = new Uint8Array(4 * w * h)\n\n        if (!data_rgba.length) {\n          rgbe_error(rgbe_memory_error, 'unable to allocate buffer space')\n        }\n\n        let offset = 0,\n          pos = 0\n\n        const ptr_end = 4 * scanline_width\n        const rgbeStart = new Uint8Array(4)\n        const scanline_buffer = new Uint8Array(ptr_end)\n        let num_scanlines = h\n\n        // read in each successive scanline\n        while (num_scanlines > 0 && pos < buffer.byteLength) {\n          if (pos + 4 > buffer.byteLength) {\n            rgbe_error(rgbe_read_error)\n          }\n\n          rgbeStart[0] = buffer[pos++]\n          rgbeStart[1] = buffer[pos++]\n          rgbeStart[2] = buffer[pos++]\n          rgbeStart[3] = buffer[pos++]\n\n          if (2 != rgbeStart[0] || 2 != rgbeStart[1] || ((rgbeStart[2] << 8) | rgbeStart[3]) != scanline_width) {\n            rgbe_error(rgbe_format_error, 'bad rgbe scanline format')\n          }\n\n          // read each of the four channels for the scanline into the buffer\n          // first red, then green, then blue, then exponent\n          let ptr = 0,\n            count\n\n          while (ptr < ptr_end && pos < buffer.byteLength) {\n            count = buffer[pos++]\n            const isEncodedRun = count > 128\n            if (isEncodedRun) count -= 128\n\n            if (0 === count || ptr + count > ptr_end) {\n              rgbe_error(rgbe_format_error, 'bad scanline data')\n            }\n\n            if (isEncodedRun) {\n              // a (encoded) run of the same value\n              const byteValue = buffer[pos++]\n              for (let i = 0; i < count; i++) {\n                scanline_buffer[ptr++] = byteValue\n              }\n              //ptr += count;\n            } else {\n              // a literal-run\n              scanline_buffer.set(buffer.subarray(pos, pos + count), ptr)\n              ptr += count\n              pos += count\n            }\n          }\n\n          // now convert data from buffer into rgba\n          // first red, then green, then blue, then exponent (alpha)\n          const l = scanline_width //scanline_buffer.byteLength;\n          for (let i = 0; i < l; i++) {\n            let off = 0\n            data_rgba[offset] = scanline_buffer[i + off]\n            off += scanline_width //1;\n            data_rgba[offset + 1] = scanline_buffer[i + off]\n            off += scanline_width //1;\n            data_rgba[offset + 2] = scanline_buffer[i + off]\n            off += scanline_width //1;\n            data_rgba[offset + 3] = scanline_buffer[i + off]\n            offset += 4\n          }\n\n          num_scanlines--\n        }\n\n        return data_rgba\n      }\n\n    const RGBEByteToRGBFloat = function (sourceArray, sourceOffset, destArray, destOffset) {\n      const e = sourceArray[sourceOffset + 3]\n      const scale = Math.pow(2.0, e - 128.0) / 255.0\n\n      destArray[destOffset + 0] = sourceArray[sourceOffset + 0] * scale\n      destArray[destOffset + 1] = sourceArray[sourceOffset + 1] * scale\n      destArray[destOffset + 2] = sourceArray[sourceOffset + 2] * scale\n      destArray[destOffset + 3] = 1\n    }\n\n    const RGBEByteToRGBHalf = function (sourceArray, sourceOffset, destArray, destOffset) {\n      const e = sourceArray[sourceOffset + 3]\n      const scale = Math.pow(2.0, e - 128.0) / 255.0\n\n      // clamping to 65504, the maximum representable value in float16\n      destArray[destOffset + 0] = DataUtils.toHalfFloat(Math.min(sourceArray[sourceOffset + 0] * scale, 65504))\n      destArray[destOffset + 1] = DataUtils.toHalfFloat(Math.min(sourceArray[sourceOffset + 1] * scale, 65504))\n      destArray[destOffset + 2] = DataUtils.toHalfFloat(Math.min(sourceArray[sourceOffset + 2] * scale, 65504))\n      destArray[destOffset + 3] = DataUtils.toHalfFloat(1)\n    }\n\n    const byteArray = new Uint8Array(buffer)\n    byteArray.pos = 0\n    const rgbe_header_info = RGBE_ReadHeader(byteArray)\n\n    const w = rgbe_header_info.width,\n      h = rgbe_header_info.height,\n      image_rgba_data = RGBE_ReadPixels_RLE(byteArray.subarray(byteArray.pos), w, h)\n\n    let data, type\n    let numElements\n\n    switch (this.type) {\n      case FloatType:\n        numElements = image_rgba_data.length / 4\n        const floatArray = new Float32Array(numElements * 4)\n\n        for (let j = 0; j < numElements; j++) {\n          RGBEByteToRGBFloat(image_rgba_data, j * 4, floatArray, j * 4)\n        }\n\n        data = floatArray\n        type = FloatType\n        break\n\n      case HalfFloatType:\n        numElements = image_rgba_data.length / 4\n        const halfArray = new Uint16Array(numElements * 4)\n\n        for (let j = 0; j < numElements; j++) {\n          RGBEByteToRGBHalf(image_rgba_data, j * 4, halfArray, j * 4)\n        }\n\n        data = halfArray\n        type = HalfFloatType\n        break\n\n      default:\n        throw new Error('THREE.RGBELoader: Unsupported type: ' + this.type)\n        break\n    }\n\n    return {\n      width: w,\n      height: h,\n      data: data,\n      header: rgbe_header_info.string,\n      gamma: rgbe_header_info.gamma,\n      exposure: rgbe_header_info.exposure,\n      type: type,\n    }\n  }\n\n  setDataType(value) {\n    this.type = value\n    return this\n  }\n\n  load(url, onLoad, onProgress, onError) {\n    function onLoadCallback(texture, texData) {\n      switch (texture.type) {\n        case FloatType:\n        case HalfFloatType:\n          if ('colorSpace' in texture) texture.colorSpace = 'srgb-linear'\n          else texture.encoding = 3000 // LinearEncoding\n          texture.minFilter = LinearFilter\n          texture.magFilter = LinearFilter\n          texture.generateMipmaps = false\n          texture.flipY = true\n\n          break\n      }\n\n      if (onLoad) onLoad(texture, texData)\n    }\n\n    return super.load(url, onLoadCallback, onProgress, onError)\n  }\n}\n\nexport { RGBELoader }\n"],"names":["buffer","w","h"],"mappings":"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","debugId":null}},
    {"offset": {"line": 8062, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/three-stdlib@2.36.1_three@0.182.0/node_modules/three-stdlib/loaders/EXRLoader.js","sources":["file:///C:/coqueli/frontend/node_modules/.pnpm/three-stdlib%402.36.1_three%400.182.0/node_modules/src/loaders/EXRLoader.js"],"sourcesContent":["import {\n  Texture,\n  DataTextureLoader,\n  DataUtils,\n  FloatType,\n  HalfFloatType,\n  LinearFilter,\n  RedFormat,\n  RGBAFormat,\n} from 'three'\nimport { unzlibSync } from 'fflate'\nimport { version } from '../_polyfill/constants'\n\n/**\n * OpenEXR loader currently supports uncompressed, ZIP(S), RLE, PIZ and DWA/B compression.\n * Supports reading as UnsignedByte, HalfFloat and Float type data texture.\n *\n * Referred to the original Industrial Light & Magic OpenEXR implementation and the TinyEXR / Syoyo Fujita\n * implementation, so I have preserved their copyright notices.\n */\n\n// /*\n// Copyright (c) 2014 - 2017, Syoyo Fujita\n// All rights reserved.\n\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are met:\n//     * Redistributions of source code must retain the above copyright\n//       notice, this list of conditions and the following disclaimer.\n//     * Redistributions in binary form must reproduce the above copyright\n//       notice, this list of conditions and the following disclaimer in the\n//       documentation and/or other materials provided with the distribution.\n//     * Neither the name of the Syoyo Fujita nor the\n//       names of its contributors may be used to endorse or promote products\n//       derived from this software without specific prior written permission.\n\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n// DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY\n// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n// */\n\n// // TinyEXR contains some OpenEXR code, which is licensed under ------------\n\n// ///////////////////////////////////////////////////////////////////////////\n// //\n// // Copyright (c) 2002, Industrial Light & Magic, a division of Lucas\n// // Digital Ltd. LLC\n// //\n// // All rights reserved.\n// //\n// // Redistribution and use in source and binary forms, with or without\n// // modification, are permitted provided that the following conditions are\n// // met:\n// // *       Redistributions of source code must retain the above copyright\n// // notice, this list of conditions and the following disclaimer.\n// // *       Redistributions in binary form must reproduce the above\n// // copyright notice, this list of conditions and the following disclaimer\n// // in the documentation and/or other materials provided with the\n// // distribution.\n// // *       Neither the name of Industrial Light & Magic nor the names of\n// // its contributors may be used to endorse or promote products derived\n// // from this software without specific prior written permission.\n// //\n// // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// // \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// // LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// // A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// // OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// // SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// // LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// // DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// // THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n// //\n// ///////////////////////////////////////////////////////////////////////////\n\n// // End of OpenEXR license -------------------------------------------------\n\n// https://github.com/mrdoob/three.js/pull/25771\nconst hasColorSpace = version >= 152\n\nclass EXRLoader extends DataTextureLoader {\n  constructor(manager) {\n    super(manager)\n\n    this.type = HalfFloatType\n  }\n\n  parse(buffer) {\n    const USHORT_RANGE = 1 << 16\n    const BITMAP_SIZE = USHORT_RANGE >> 3\n\n    const HUF_ENCBITS = 16 // literal (value) bit length\n    const HUF_DECBITS = 14 // decoding bit size (>= 8)\n\n    const HUF_ENCSIZE = (1 << HUF_ENCBITS) + 1 // encoding table size\n    const HUF_DECSIZE = 1 << HUF_DECBITS // decoding table size\n    const HUF_DECMASK = HUF_DECSIZE - 1\n\n    const NBITS = 16\n    const A_OFFSET = 1 << (NBITS - 1)\n    const MOD_MASK = (1 << NBITS) - 1\n\n    const SHORT_ZEROCODE_RUN = 59\n    const LONG_ZEROCODE_RUN = 63\n    const SHORTEST_LONG_RUN = 2 + LONG_ZEROCODE_RUN - SHORT_ZEROCODE_RUN\n\n    const ULONG_SIZE = 8\n    const FLOAT32_SIZE = 4\n    const INT32_SIZE = 4\n    const INT16_SIZE = 2\n    const INT8_SIZE = 1\n\n    const STATIC_HUFFMAN = 0\n    const DEFLATE = 1\n\n    const UNKNOWN = 0\n    const LOSSY_DCT = 1\n    const RLE = 2\n\n    const logBase = Math.pow(2.7182818, 2.2)\n\n    function reverseLutFromBitmap(bitmap, lut) {\n      var k = 0\n\n      for (var i = 0; i < USHORT_RANGE; ++i) {\n        if (i == 0 || bitmap[i >> 3] & (1 << (i & 7))) {\n          lut[k++] = i\n        }\n      }\n\n      var n = k - 1\n\n      while (k < USHORT_RANGE) lut[k++] = 0\n\n      return n\n    }\n\n    function hufClearDecTable(hdec) {\n      for (var i = 0; i < HUF_DECSIZE; i++) {\n        hdec[i] = {}\n        hdec[i].len = 0\n        hdec[i].lit = 0\n        hdec[i].p = null\n      }\n    }\n\n    const getBitsReturn = { l: 0, c: 0, lc: 0 }\n\n    function getBits(nBits, c, lc, uInt8Array, inOffset) {\n      while (lc < nBits) {\n        c = (c << 8) | parseUint8Array(uInt8Array, inOffset)\n        lc += 8\n      }\n\n      lc -= nBits\n\n      getBitsReturn.l = (c >> lc) & ((1 << nBits) - 1)\n      getBitsReturn.c = c\n      getBitsReturn.lc = lc\n    }\n\n    const hufTableBuffer = new Array(59)\n\n    function hufCanonicalCodeTable(hcode) {\n      for (var i = 0; i <= 58; ++i) hufTableBuffer[i] = 0\n      for (var i = 0; i < HUF_ENCSIZE; ++i) hufTableBuffer[hcode[i]] += 1\n\n      var c = 0\n\n      for (var i = 58; i > 0; --i) {\n        var nc = (c + hufTableBuffer[i]) >> 1\n        hufTableBuffer[i] = c\n        c = nc\n      }\n\n      for (var i = 0; i < HUF_ENCSIZE; ++i) {\n        var l = hcode[i]\n        if (l > 0) hcode[i] = l | (hufTableBuffer[l]++ << 6)\n      }\n    }\n\n    function hufUnpackEncTable(uInt8Array, inDataView, inOffset, ni, im, iM, hcode) {\n      var p = inOffset\n      var c = 0\n      var lc = 0\n\n      for (; im <= iM; im++) {\n        if (p.value - inOffset.value > ni) return false\n\n        getBits(6, c, lc, uInt8Array, p)\n\n        var l = getBitsReturn.l\n        c = getBitsReturn.c\n        lc = getBitsReturn.lc\n\n        hcode[im] = l\n\n        if (l == LONG_ZEROCODE_RUN) {\n          if (p.value - inOffset.value > ni) {\n            throw 'Something wrong with hufUnpackEncTable'\n          }\n\n          getBits(8, c, lc, uInt8Array, p)\n\n          var zerun = getBitsReturn.l + SHORTEST_LONG_RUN\n          c = getBitsReturn.c\n          lc = getBitsReturn.lc\n\n          if (im + zerun > iM + 1) {\n            throw 'Something wrong with hufUnpackEncTable'\n          }\n\n          while (zerun--) hcode[im++] = 0\n\n          im--\n        } else if (l >= SHORT_ZEROCODE_RUN) {\n          var zerun = l - SHORT_ZEROCODE_RUN + 2\n\n          if (im + zerun > iM + 1) {\n            throw 'Something wrong with hufUnpackEncTable'\n          }\n\n          while (zerun--) hcode[im++] = 0\n\n          im--\n        }\n      }\n\n      hufCanonicalCodeTable(hcode)\n    }\n\n    function hufLength(code) {\n      return code & 63\n    }\n\n    function hufCode(code) {\n      return code >> 6\n    }\n\n    function hufBuildDecTable(hcode, im, iM, hdecod) {\n      for (; im <= iM; im++) {\n        var c = hufCode(hcode[im])\n        var l = hufLength(hcode[im])\n\n        if (c >> l) {\n          throw 'Invalid table entry'\n        }\n\n        if (l > HUF_DECBITS) {\n          var pl = hdecod[c >> (l - HUF_DECBITS)]\n\n          if (pl.len) {\n            throw 'Invalid table entry'\n          }\n\n          pl.lit++\n\n          if (pl.p) {\n            var p = pl.p\n            pl.p = new Array(pl.lit)\n\n            for (var i = 0; i < pl.lit - 1; ++i) {\n              pl.p[i] = p[i]\n            }\n          } else {\n            pl.p = new Array(1)\n          }\n\n          pl.p[pl.lit - 1] = im\n        } else if (l) {\n          var plOffset = 0\n\n          for (var i = 1 << (HUF_DECBITS - l); i > 0; i--) {\n            var pl = hdecod[(c << (HUF_DECBITS - l)) + plOffset]\n\n            if (pl.len || pl.p) {\n              throw 'Invalid table entry'\n            }\n\n            pl.len = l\n            pl.lit = im\n\n            plOffset++\n          }\n        }\n      }\n\n      return true\n    }\n\n    const getCharReturn = { c: 0, lc: 0 }\n\n    function getChar(c, lc, uInt8Array, inOffset) {\n      c = (c << 8) | parseUint8Array(uInt8Array, inOffset)\n      lc += 8\n\n      getCharReturn.c = c\n      getCharReturn.lc = lc\n    }\n\n    const getCodeReturn = { c: 0, lc: 0 }\n\n    function getCode(po, rlc, c, lc, uInt8Array, inDataView, inOffset, outBuffer, outBufferOffset, outBufferEndOffset) {\n      if (po == rlc) {\n        if (lc < 8) {\n          getChar(c, lc, uInt8Array, inOffset)\n          c = getCharReturn.c\n          lc = getCharReturn.lc\n        }\n\n        lc -= 8\n\n        var cs = c >> lc\n        var cs = new Uint8Array([cs])[0]\n\n        if (outBufferOffset.value + cs > outBufferEndOffset) {\n          return false\n        }\n\n        var s = outBuffer[outBufferOffset.value - 1]\n\n        while (cs-- > 0) {\n          outBuffer[outBufferOffset.value++] = s\n        }\n      } else if (outBufferOffset.value < outBufferEndOffset) {\n        outBuffer[outBufferOffset.value++] = po\n      } else {\n        return false\n      }\n\n      getCodeReturn.c = c\n      getCodeReturn.lc = lc\n    }\n\n    function UInt16(value) {\n      return value & 0xffff\n    }\n\n    function Int16(value) {\n      var ref = UInt16(value)\n      return ref > 0x7fff ? ref - 0x10000 : ref\n    }\n\n    const wdec14Return = { a: 0, b: 0 }\n\n    function wdec14(l, h) {\n      var ls = Int16(l)\n      var hs = Int16(h)\n\n      var hi = hs\n      var ai = ls + (hi & 1) + (hi >> 1)\n\n      var as = ai\n      var bs = ai - hi\n\n      wdec14Return.a = as\n      wdec14Return.b = bs\n    }\n\n    function wdec16(l, h) {\n      var m = UInt16(l)\n      var d = UInt16(h)\n\n      var bb = (m - (d >> 1)) & MOD_MASK\n      var aa = (d + bb - A_OFFSET) & MOD_MASK\n\n      wdec14Return.a = aa\n      wdec14Return.b = bb\n    }\n\n    function wav2Decode(buffer, j, nx, ox, ny, oy, mx) {\n      var w14 = mx < 1 << 14\n      var n = nx > ny ? ny : nx\n      var p = 1\n      var p2\n\n      while (p <= n) p <<= 1\n\n      p >>= 1\n      p2 = p\n      p >>= 1\n\n      while (p >= 1) {\n        var py = 0\n        var ey = py + oy * (ny - p2)\n        var oy1 = oy * p\n        var oy2 = oy * p2\n        var ox1 = ox * p\n        var ox2 = ox * p2\n        var i00, i01, i10, i11\n\n        for (; py <= ey; py += oy2) {\n          var px = py\n          var ex = py + ox * (nx - p2)\n\n          for (; px <= ex; px += ox2) {\n            var p01 = px + ox1\n            var p10 = px + oy1\n            var p11 = p10 + ox1\n\n            if (w14) {\n              wdec14(buffer[px + j], buffer[p10 + j])\n\n              i00 = wdec14Return.a\n              i10 = wdec14Return.b\n\n              wdec14(buffer[p01 + j], buffer[p11 + j])\n\n              i01 = wdec14Return.a\n              i11 = wdec14Return.b\n\n              wdec14(i00, i01)\n\n              buffer[px + j] = wdec14Return.a\n              buffer[p01 + j] = wdec14Return.b\n\n              wdec14(i10, i11)\n\n              buffer[p10 + j] = wdec14Return.a\n              buffer[p11 + j] = wdec14Return.b\n            } else {\n              wdec16(buffer[px + j], buffer[p10 + j])\n\n              i00 = wdec14Return.a\n              i10 = wdec14Return.b\n\n              wdec16(buffer[p01 + j], buffer[p11 + j])\n\n              i01 = wdec14Return.a\n              i11 = wdec14Return.b\n\n              wdec16(i00, i01)\n\n              buffer[px + j] = wdec14Return.a\n              buffer[p01 + j] = wdec14Return.b\n\n              wdec16(i10, i11)\n\n              buffer[p10 + j] = wdec14Return.a\n              buffer[p11 + j] = wdec14Return.b\n            }\n          }\n\n          if (nx & p) {\n            var p10 = px + oy1\n\n            if (w14) wdec14(buffer[px + j], buffer[p10 + j])\n            else wdec16(buffer[px + j], buffer[p10 + j])\n\n            i00 = wdec14Return.a\n            buffer[p10 + j] = wdec14Return.b\n\n            buffer[px + j] = i00\n          }\n        }\n\n        if (ny & p) {\n          var px = py\n          var ex = py + ox * (nx - p2)\n\n          for (; px <= ex; px += ox2) {\n            var p01 = px + ox1\n\n            if (w14) wdec14(buffer[px + j], buffer[p01 + j])\n            else wdec16(buffer[px + j], buffer[p01 + j])\n\n            i00 = wdec14Return.a\n            buffer[p01 + j] = wdec14Return.b\n\n            buffer[px + j] = i00\n          }\n        }\n\n        p2 = p\n        p >>= 1\n      }\n\n      return py\n    }\n\n    function hufDecode(\n      encodingTable,\n      decodingTable,\n      uInt8Array,\n      inDataView,\n      inOffset,\n      ni,\n      rlc,\n      no,\n      outBuffer,\n      outOffset,\n    ) {\n      var c = 0\n      var lc = 0\n      var outBufferEndOffset = no\n      var inOffsetEnd = Math.trunc(inOffset.value + (ni + 7) / 8)\n\n      while (inOffset.value < inOffsetEnd) {\n        getChar(c, lc, uInt8Array, inOffset)\n\n        c = getCharReturn.c\n        lc = getCharReturn.lc\n\n        while (lc >= HUF_DECBITS) {\n          var index = (c >> (lc - HUF_DECBITS)) & HUF_DECMASK\n          var pl = decodingTable[index]\n\n          if (pl.len) {\n            lc -= pl.len\n\n            getCode(pl.lit, rlc, c, lc, uInt8Array, inDataView, inOffset, outBuffer, outOffset, outBufferEndOffset)\n\n            c = getCodeReturn.c\n            lc = getCodeReturn.lc\n          } else {\n            if (!pl.p) {\n              throw 'hufDecode issues'\n            }\n\n            var j\n\n            for (j = 0; j < pl.lit; j++) {\n              var l = hufLength(encodingTable[pl.p[j]])\n\n              while (lc < l && inOffset.value < inOffsetEnd) {\n                getChar(c, lc, uInt8Array, inOffset)\n\n                c = getCharReturn.c\n                lc = getCharReturn.lc\n              }\n\n              if (lc >= l) {\n                if (hufCode(encodingTable[pl.p[j]]) == ((c >> (lc - l)) & ((1 << l) - 1))) {\n                  lc -= l\n\n                  getCode(\n                    pl.p[j],\n                    rlc,\n                    c,\n                    lc,\n                    uInt8Array,\n                    inDataView,\n                    inOffset,\n                    outBuffer,\n                    outOffset,\n                    outBufferEndOffset,\n                  )\n\n                  c = getCodeReturn.c\n                  lc = getCodeReturn.lc\n\n                  break\n                }\n              }\n            }\n\n            if (j == pl.lit) {\n              throw 'hufDecode issues'\n            }\n          }\n        }\n      }\n\n      var i = (8 - ni) & 7\n\n      c >>= i\n      lc -= i\n\n      while (lc > 0) {\n        var pl = decodingTable[(c << (HUF_DECBITS - lc)) & HUF_DECMASK]\n\n        if (pl.len) {\n          lc -= pl.len\n\n          getCode(pl.lit, rlc, c, lc, uInt8Array, inDataView, inOffset, outBuffer, outOffset, outBufferEndOffset)\n\n          c = getCodeReturn.c\n          lc = getCodeReturn.lc\n        } else {\n          throw 'hufDecode issues'\n        }\n      }\n\n      return true\n    }\n\n    function hufUncompress(uInt8Array, inDataView, inOffset, nCompressed, outBuffer, nRaw) {\n      var outOffset = { value: 0 }\n      var initialInOffset = inOffset.value\n\n      var im = parseUint32(inDataView, inOffset)\n      var iM = parseUint32(inDataView, inOffset)\n\n      inOffset.value += 4\n\n      var nBits = parseUint32(inDataView, inOffset)\n\n      inOffset.value += 4\n\n      if (im < 0 || im >= HUF_ENCSIZE || iM < 0 || iM >= HUF_ENCSIZE) {\n        throw 'Something wrong with HUF_ENCSIZE'\n      }\n\n      var freq = new Array(HUF_ENCSIZE)\n      var hdec = new Array(HUF_DECSIZE)\n\n      hufClearDecTable(hdec)\n\n      var ni = nCompressed - (inOffset.value - initialInOffset)\n\n      hufUnpackEncTable(uInt8Array, inDataView, inOffset, ni, im, iM, freq)\n\n      if (nBits > 8 * (nCompressed - (inOffset.value - initialInOffset))) {\n        throw 'Something wrong with hufUncompress'\n      }\n\n      hufBuildDecTable(freq, im, iM, hdec)\n\n      hufDecode(freq, hdec, uInt8Array, inDataView, inOffset, nBits, iM, nRaw, outBuffer, outOffset)\n    }\n\n    function applyLut(lut, data, nData) {\n      for (var i = 0; i < nData; ++i) {\n        data[i] = lut[data[i]]\n      }\n    }\n\n    function predictor(source) {\n      for (var t = 1; t < source.length; t++) {\n        var d = source[t - 1] + source[t] - 128\n        source[t] = d\n      }\n    }\n\n    function interleaveScalar(source, out) {\n      var t1 = 0\n      var t2 = Math.floor((source.length + 1) / 2)\n      var s = 0\n      var stop = source.length - 1\n\n      while (true) {\n        if (s > stop) break\n        out[s++] = source[t1++]\n\n        if (s > stop) break\n        out[s++] = source[t2++]\n      }\n    }\n\n    function decodeRunLength(source) {\n      var size = source.byteLength\n      var out = new Array()\n      var p = 0\n\n      var reader = new DataView(source)\n\n      while (size > 0) {\n        var l = reader.getInt8(p++)\n\n        if (l < 0) {\n          var count = -l\n          size -= count + 1\n\n          for (var i = 0; i < count; i++) {\n            out.push(reader.getUint8(p++))\n          }\n        } else {\n          var count = l\n          size -= 2\n\n          var value = reader.getUint8(p++)\n\n          for (var i = 0; i < count + 1; i++) {\n            out.push(value)\n          }\n        }\n      }\n\n      return out\n    }\n\n    function lossyDctDecode(cscSet, rowPtrs, channelData, acBuffer, dcBuffer, outBuffer) {\n      var dataView = new DataView(outBuffer.buffer)\n\n      var width = channelData[cscSet.idx[0]].width\n      var height = channelData[cscSet.idx[0]].height\n\n      var numComp = 3\n\n      var numFullBlocksX = Math.floor(width / 8.0)\n      var numBlocksX = Math.ceil(width / 8.0)\n      var numBlocksY = Math.ceil(height / 8.0)\n      var leftoverX = width - (numBlocksX - 1) * 8\n      var leftoverY = height - (numBlocksY - 1) * 8\n\n      var currAcComp = { value: 0 }\n      var currDcComp = new Array(numComp)\n      var dctData = new Array(numComp)\n      var halfZigBlock = new Array(numComp)\n      var rowBlock = new Array(numComp)\n      var rowOffsets = new Array(numComp)\n\n      for (let comp = 0; comp < numComp; ++comp) {\n        rowOffsets[comp] = rowPtrs[cscSet.idx[comp]]\n        currDcComp[comp] = comp < 1 ? 0 : currDcComp[comp - 1] + numBlocksX * numBlocksY\n        dctData[comp] = new Float32Array(64)\n        halfZigBlock[comp] = new Uint16Array(64)\n        rowBlock[comp] = new Uint16Array(numBlocksX * 64)\n      }\n\n      for (let blocky = 0; blocky < numBlocksY; ++blocky) {\n        var maxY = 8\n\n        if (blocky == numBlocksY - 1) maxY = leftoverY\n\n        var maxX = 8\n\n        for (let blockx = 0; blockx < numBlocksX; ++blockx) {\n          if (blockx == numBlocksX - 1) maxX = leftoverX\n\n          for (let comp = 0; comp < numComp; ++comp) {\n            halfZigBlock[comp].fill(0)\n\n            // set block DC component\n            halfZigBlock[comp][0] = dcBuffer[currDcComp[comp]++]\n            // set block AC components\n            unRleAC(currAcComp, acBuffer, halfZigBlock[comp])\n\n            // UnZigZag block to float\n            unZigZag(halfZigBlock[comp], dctData[comp])\n            // decode float dct\n            dctInverse(dctData[comp])\n          }\n\n          if (numComp == 3) {\n            csc709Inverse(dctData)\n          }\n\n          for (let comp = 0; comp < numComp; ++comp) {\n            convertToHalf(dctData[comp], rowBlock[comp], blockx * 64)\n          }\n        } // blockx\n\n        let offset = 0\n\n        for (let comp = 0; comp < numComp; ++comp) {\n          const type = channelData[cscSet.idx[comp]].type\n\n          for (let y = 8 * blocky; y < 8 * blocky + maxY; ++y) {\n            offset = rowOffsets[comp][y]\n\n            for (let blockx = 0; blockx < numFullBlocksX; ++blockx) {\n              const src = blockx * 64 + (y & 0x7) * 8\n\n              dataView.setUint16(offset + 0 * INT16_SIZE * type, rowBlock[comp][src + 0], true)\n              dataView.setUint16(offset + 1 * INT16_SIZE * type, rowBlock[comp][src + 1], true)\n              dataView.setUint16(offset + 2 * INT16_SIZE * type, rowBlock[comp][src + 2], true)\n              dataView.setUint16(offset + 3 * INT16_SIZE * type, rowBlock[comp][src + 3], true)\n\n              dataView.setUint16(offset + 4 * INT16_SIZE * type, rowBlock[comp][src + 4], true)\n              dataView.setUint16(offset + 5 * INT16_SIZE * type, rowBlock[comp][src + 5], true)\n              dataView.setUint16(offset + 6 * INT16_SIZE * type, rowBlock[comp][src + 6], true)\n              dataView.setUint16(offset + 7 * INT16_SIZE * type, rowBlock[comp][src + 7], true)\n\n              offset += 8 * INT16_SIZE * type\n            }\n          }\n\n          // handle partial X blocks\n          if (numFullBlocksX != numBlocksX) {\n            for (let y = 8 * blocky; y < 8 * blocky + maxY; ++y) {\n              const offset = rowOffsets[comp][y] + 8 * numFullBlocksX * INT16_SIZE * type\n              const src = numFullBlocksX * 64 + (y & 0x7) * 8\n\n              for (let x = 0; x < maxX; ++x) {\n                dataView.setUint16(offset + x * INT16_SIZE * type, rowBlock[comp][src + x], true)\n              }\n            }\n          }\n        } // comp\n      } // blocky\n\n      var halfRow = new Uint16Array(width)\n      var dataView = new DataView(outBuffer.buffer)\n\n      // convert channels back to float, if needed\n      for (var comp = 0; comp < numComp; ++comp) {\n        channelData[cscSet.idx[comp]].decoded = true\n        var type = channelData[cscSet.idx[comp]].type\n\n        if (channelData[comp].type != 2) continue\n\n        for (var y = 0; y < height; ++y) {\n          const offset = rowOffsets[comp][y]\n\n          for (var x = 0; x < width; ++x) {\n            halfRow[x] = dataView.getUint16(offset + x * INT16_SIZE * type, true)\n          }\n\n          for (var x = 0; x < width; ++x) {\n            dataView.setFloat32(offset + x * INT16_SIZE * type, decodeFloat16(halfRow[x]), true)\n          }\n        }\n      }\n    }\n\n    function unRleAC(currAcComp, acBuffer, halfZigBlock) {\n      var acValue\n      var dctComp = 1\n\n      while (dctComp < 64) {\n        acValue = acBuffer[currAcComp.value]\n\n        if (acValue == 0xff00) {\n          dctComp = 64\n        } else if (acValue >> 8 == 0xff) {\n          dctComp += acValue & 0xff\n        } else {\n          halfZigBlock[dctComp] = acValue\n          dctComp++\n        }\n\n        currAcComp.value++\n      }\n    }\n\n    function unZigZag(src, dst) {\n      dst[0] = decodeFloat16(src[0])\n      dst[1] = decodeFloat16(src[1])\n      dst[2] = decodeFloat16(src[5])\n      dst[3] = decodeFloat16(src[6])\n      dst[4] = decodeFloat16(src[14])\n      dst[5] = decodeFloat16(src[15])\n      dst[6] = decodeFloat16(src[27])\n      dst[7] = decodeFloat16(src[28])\n      dst[8] = decodeFloat16(src[2])\n      dst[9] = decodeFloat16(src[4])\n\n      dst[10] = decodeFloat16(src[7])\n      dst[11] = decodeFloat16(src[13])\n      dst[12] = decodeFloat16(src[16])\n      dst[13] = decodeFloat16(src[26])\n      dst[14] = decodeFloat16(src[29])\n      dst[15] = decodeFloat16(src[42])\n      dst[16] = decodeFloat16(src[3])\n      dst[17] = decodeFloat16(src[8])\n      dst[18] = decodeFloat16(src[12])\n      dst[19] = decodeFloat16(src[17])\n\n      dst[20] = decodeFloat16(src[25])\n      dst[21] = decodeFloat16(src[30])\n      dst[22] = decodeFloat16(src[41])\n      dst[23] = decodeFloat16(src[43])\n      dst[24] = decodeFloat16(src[9])\n      dst[25] = decodeFloat16(src[11])\n      dst[26] = decodeFloat16(src[18])\n      dst[27] = decodeFloat16(src[24])\n      dst[28] = decodeFloat16(src[31])\n      dst[29] = decodeFloat16(src[40])\n\n      dst[30] = decodeFloat16(src[44])\n      dst[31] = decodeFloat16(src[53])\n      dst[32] = decodeFloat16(src[10])\n      dst[33] = decodeFloat16(src[19])\n      dst[34] = decodeFloat16(src[23])\n      dst[35] = decodeFloat16(src[32])\n      dst[36] = decodeFloat16(src[39])\n      dst[37] = decodeFloat16(src[45])\n      dst[38] = decodeFloat16(src[52])\n      dst[39] = decodeFloat16(src[54])\n\n      dst[40] = decodeFloat16(src[20])\n      dst[41] = decodeFloat16(src[22])\n      dst[42] = decodeFloat16(src[33])\n      dst[43] = decodeFloat16(src[38])\n      dst[44] = decodeFloat16(src[46])\n      dst[45] = decodeFloat16(src[51])\n      dst[46] = decodeFloat16(src[55])\n      dst[47] = decodeFloat16(src[60])\n      dst[48] = decodeFloat16(src[21])\n      dst[49] = decodeFloat16(src[34])\n\n      dst[50] = decodeFloat16(src[37])\n      dst[51] = decodeFloat16(src[47])\n      dst[52] = decodeFloat16(src[50])\n      dst[53] = decodeFloat16(src[56])\n      dst[54] = decodeFloat16(src[59])\n      dst[55] = decodeFloat16(src[61])\n      dst[56] = decodeFloat16(src[35])\n      dst[57] = decodeFloat16(src[36])\n      dst[58] = decodeFloat16(src[48])\n      dst[59] = decodeFloat16(src[49])\n\n      dst[60] = decodeFloat16(src[57])\n      dst[61] = decodeFloat16(src[58])\n      dst[62] = decodeFloat16(src[62])\n      dst[63] = decodeFloat16(src[63])\n    }\n\n    function dctInverse(data) {\n      const a = 0.5 * Math.cos(3.14159 / 4.0)\n      const b = 0.5 * Math.cos(3.14159 / 16.0)\n      const c = 0.5 * Math.cos(3.14159 / 8.0)\n      const d = 0.5 * Math.cos((3.0 * 3.14159) / 16.0)\n      const e = 0.5 * Math.cos((5.0 * 3.14159) / 16.0)\n      const f = 0.5 * Math.cos((3.0 * 3.14159) / 8.0)\n      const g = 0.5 * Math.cos((7.0 * 3.14159) / 16.0)\n\n      var alpha = new Array(4)\n      var beta = new Array(4)\n      var theta = new Array(4)\n      var gamma = new Array(4)\n\n      for (var row = 0; row < 8; ++row) {\n        var rowPtr = row * 8\n\n        alpha[0] = c * data[rowPtr + 2]\n        alpha[1] = f * data[rowPtr + 2]\n        alpha[2] = c * data[rowPtr + 6]\n        alpha[3] = f * data[rowPtr + 6]\n\n        beta[0] = b * data[rowPtr + 1] + d * data[rowPtr + 3] + e * data[rowPtr + 5] + g * data[rowPtr + 7]\n        beta[1] = d * data[rowPtr + 1] - g * data[rowPtr + 3] - b * data[rowPtr + 5] - e * data[rowPtr + 7]\n        beta[2] = e * data[rowPtr + 1] - b * data[rowPtr + 3] + g * data[rowPtr + 5] + d * data[rowPtr + 7]\n        beta[3] = g * data[rowPtr + 1] - e * data[rowPtr + 3] + d * data[rowPtr + 5] - b * data[rowPtr + 7]\n\n        theta[0] = a * (data[rowPtr + 0] + data[rowPtr + 4])\n        theta[3] = a * (data[rowPtr + 0] - data[rowPtr + 4])\n        theta[1] = alpha[0] + alpha[3]\n        theta[2] = alpha[1] - alpha[2]\n\n        gamma[0] = theta[0] + theta[1]\n        gamma[1] = theta[3] + theta[2]\n        gamma[2] = theta[3] - theta[2]\n        gamma[3] = theta[0] - theta[1]\n\n        data[rowPtr + 0] = gamma[0] + beta[0]\n        data[rowPtr + 1] = gamma[1] + beta[1]\n        data[rowPtr + 2] = gamma[2] + beta[2]\n        data[rowPtr + 3] = gamma[3] + beta[3]\n\n        data[rowPtr + 4] = gamma[3] - beta[3]\n        data[rowPtr + 5] = gamma[2] - beta[2]\n        data[rowPtr + 6] = gamma[1] - beta[1]\n        data[rowPtr + 7] = gamma[0] - beta[0]\n      }\n\n      for (var column = 0; column < 8; ++column) {\n        alpha[0] = c * data[16 + column]\n        alpha[1] = f * data[16 + column]\n        alpha[2] = c * data[48 + column]\n        alpha[3] = f * data[48 + column]\n\n        beta[0] = b * data[8 + column] + d * data[24 + column] + e * data[40 + column] + g * data[56 + column]\n        beta[1] = d * data[8 + column] - g * data[24 + column] - b * data[40 + column] - e * data[56 + column]\n        beta[2] = e * data[8 + column] - b * data[24 + column] + g * data[40 + column] + d * data[56 + column]\n        beta[3] = g * data[8 + column] - e * data[24 + column] + d * data[40 + column] - b * data[56 + column]\n\n        theta[0] = a * (data[column] + data[32 + column])\n        theta[3] = a * (data[column] - data[32 + column])\n\n        theta[1] = alpha[0] + alpha[3]\n        theta[2] = alpha[1] - alpha[2]\n\n        gamma[0] = theta[0] + theta[1]\n        gamma[1] = theta[3] + theta[2]\n        gamma[2] = theta[3] - theta[2]\n        gamma[3] = theta[0] - theta[1]\n\n        data[0 + column] = gamma[0] + beta[0]\n        data[8 + column] = gamma[1] + beta[1]\n        data[16 + column] = gamma[2] + beta[2]\n        data[24 + column] = gamma[3] + beta[3]\n\n        data[32 + column] = gamma[3] - beta[3]\n        data[40 + column] = gamma[2] - beta[2]\n        data[48 + column] = gamma[1] - beta[1]\n        data[56 + column] = gamma[0] - beta[0]\n      }\n    }\n\n    function csc709Inverse(data) {\n      for (var i = 0; i < 64; ++i) {\n        var y = data[0][i]\n        var cb = data[1][i]\n        var cr = data[2][i]\n\n        data[0][i] = y + 1.5747 * cr\n        data[1][i] = y - 0.1873 * cb - 0.4682 * cr\n        data[2][i] = y + 1.8556 * cb\n      }\n    }\n\n    function convertToHalf(src, dst, idx) {\n      for (var i = 0; i < 64; ++i) {\n        dst[idx + i] = DataUtils.toHalfFloat(toLinear(src[i]))\n      }\n    }\n\n    function toLinear(float) {\n      if (float <= 1) {\n        return Math.sign(float) * Math.pow(Math.abs(float), 2.2)\n      } else {\n        return Math.sign(float) * Math.pow(logBase, Math.abs(float) - 1.0)\n      }\n    }\n\n    function uncompressRAW(info) {\n      return new DataView(info.array.buffer, info.offset.value, info.size)\n    }\n\n    function uncompressRLE(info) {\n      var compressed = info.viewer.buffer.slice(info.offset.value, info.offset.value + info.size)\n\n      var rawBuffer = new Uint8Array(decodeRunLength(compressed))\n      var tmpBuffer = new Uint8Array(rawBuffer.length)\n\n      predictor(rawBuffer) // revert predictor\n\n      interleaveScalar(rawBuffer, tmpBuffer) // interleave pixels\n\n      return new DataView(tmpBuffer.buffer)\n    }\n\n    function uncompressZIP(info) {\n      var compressed = info.array.slice(info.offset.value, info.offset.value + info.size)\n      var rawBuffer = unzlibSync(compressed)\n      var tmpBuffer = new Uint8Array(rawBuffer.length)\n\n      predictor(rawBuffer) // revert predictor\n\n      interleaveScalar(rawBuffer, tmpBuffer) // interleave pixels\n\n      return new DataView(tmpBuffer.buffer)\n    }\n\n    function uncompressPIZ(info) {\n      var inDataView = info.viewer\n      var inOffset = { value: info.offset.value }\n\n      var outBuffer = new Uint16Array(info.width * info.scanlineBlockSize * (info.channels * info.type))\n      var bitmap = new Uint8Array(BITMAP_SIZE)\n\n      // Setup channel info\n      var outBufferEnd = 0\n      var pizChannelData = new Array(info.channels)\n      for (var i = 0; i < info.channels; i++) {\n        pizChannelData[i] = {}\n        pizChannelData[i]['start'] = outBufferEnd\n        pizChannelData[i]['end'] = pizChannelData[i]['start']\n        pizChannelData[i]['nx'] = info.width\n        pizChannelData[i]['ny'] = info.lines\n        pizChannelData[i]['size'] = info.type\n\n        outBufferEnd += pizChannelData[i].nx * pizChannelData[i].ny * pizChannelData[i].size\n      }\n\n      // Read range compression data\n\n      var minNonZero = parseUint16(inDataView, inOffset)\n      var maxNonZero = parseUint16(inDataView, inOffset)\n\n      if (maxNonZero >= BITMAP_SIZE) {\n        throw 'Something is wrong with PIZ_COMPRESSION BITMAP_SIZE'\n      }\n\n      if (minNonZero <= maxNonZero) {\n        for (var i = 0; i < maxNonZero - minNonZero + 1; i++) {\n          bitmap[i + minNonZero] = parseUint8(inDataView, inOffset)\n        }\n      }\n\n      // Reverse LUT\n      var lut = new Uint16Array(USHORT_RANGE)\n      var maxValue = reverseLutFromBitmap(bitmap, lut)\n\n      var length = parseUint32(inDataView, inOffset)\n\n      // Huffman decoding\n      hufUncompress(info.array, inDataView, inOffset, length, outBuffer, outBufferEnd)\n\n      // Wavelet decoding\n      for (var i = 0; i < info.channels; ++i) {\n        var cd = pizChannelData[i]\n\n        for (var j = 0; j < pizChannelData[i].size; ++j) {\n          wav2Decode(outBuffer, cd.start + j, cd.nx, cd.size, cd.ny, cd.nx * cd.size, maxValue)\n        }\n      }\n\n      // Expand the pixel data to their original range\n      applyLut(lut, outBuffer, outBufferEnd)\n\n      // Rearrange the pixel data into the format expected by the caller.\n      var tmpOffset = 0\n      var tmpBuffer = new Uint8Array(outBuffer.buffer.byteLength)\n      for (var y = 0; y < info.lines; y++) {\n        for (var c = 0; c < info.channels; c++) {\n          var cd = pizChannelData[c]\n\n          var n = cd.nx * cd.size\n          var cp = new Uint8Array(outBuffer.buffer, cd.end * INT16_SIZE, n * INT16_SIZE)\n\n          tmpBuffer.set(cp, tmpOffset)\n          tmpOffset += n * INT16_SIZE\n          cd.end += n\n        }\n      }\n\n      return new DataView(tmpBuffer.buffer)\n    }\n\n    function uncompressPXR(info) {\n      var compressed = info.array.slice(info.offset.value, info.offset.value + info.size)\n      var rawBuffer = unzlibSync(compressed)\n\n      const sz = info.lines * info.channels * info.width\n      const tmpBuffer = info.type == 1 ? new Uint16Array(sz) : new Uint32Array(sz)\n\n      let tmpBufferEnd = 0\n      let writePtr = 0\n      const ptr = new Array(4)\n\n      for (let y = 0; y < info.lines; y++) {\n        for (let c = 0; c < info.channels; c++) {\n          let pixel = 0\n\n          switch (info.type) {\n            case 1:\n              ptr[0] = tmpBufferEnd\n              ptr[1] = ptr[0] + info.width\n              tmpBufferEnd = ptr[1] + info.width\n\n              for (let j = 0; j < info.width; ++j) {\n                const diff = (rawBuffer[ptr[0]++] << 8) | rawBuffer[ptr[1]++]\n\n                pixel += diff\n\n                tmpBuffer[writePtr] = pixel\n                writePtr++\n              }\n\n              break\n\n            case 2:\n              ptr[0] = tmpBufferEnd\n              ptr[1] = ptr[0] + info.width\n              ptr[2] = ptr[1] + info.width\n              tmpBufferEnd = ptr[2] + info.width\n\n              for (let j = 0; j < info.width; ++j) {\n                const diff = (rawBuffer[ptr[0]++] << 24) | (rawBuffer[ptr[1]++] << 16) | (rawBuffer[ptr[2]++] << 8)\n\n                pixel += diff\n\n                tmpBuffer[writePtr] = pixel\n                writePtr++\n              }\n\n              break\n          }\n        }\n      }\n\n      return new DataView(tmpBuffer.buffer)\n    }\n\n    function uncompressDWA(info) {\n      var inDataView = info.viewer\n      var inOffset = { value: info.offset.value }\n      var outBuffer = new Uint8Array(info.width * info.lines * (info.channels * info.type * INT16_SIZE))\n\n      // Read compression header information\n      var dwaHeader = {\n        version: parseInt64(inDataView, inOffset),\n        unknownUncompressedSize: parseInt64(inDataView, inOffset),\n        unknownCompressedSize: parseInt64(inDataView, inOffset),\n        acCompressedSize: parseInt64(inDataView, inOffset),\n        dcCompressedSize: parseInt64(inDataView, inOffset),\n        rleCompressedSize: parseInt64(inDataView, inOffset),\n        rleUncompressedSize: parseInt64(inDataView, inOffset),\n        rleRawSize: parseInt64(inDataView, inOffset),\n        totalAcUncompressedCount: parseInt64(inDataView, inOffset),\n        totalDcUncompressedCount: parseInt64(inDataView, inOffset),\n        acCompression: parseInt64(inDataView, inOffset),\n      }\n\n      if (dwaHeader.version < 2) {\n        throw 'EXRLoader.parse: ' + EXRHeader.compression + ' version ' + dwaHeader.version + ' is unsupported'\n      }\n\n      // Read channel ruleset information\n      var channelRules = new Array()\n      var ruleSize = parseUint16(inDataView, inOffset) - INT16_SIZE\n\n      while (ruleSize > 0) {\n        var name = parseNullTerminatedString(inDataView.buffer, inOffset)\n        var value = parseUint8(inDataView, inOffset)\n        var compression = (value >> 2) & 3\n        var csc = (value >> 4) - 1\n        var index = new Int8Array([csc])[0]\n        var type = parseUint8(inDataView, inOffset)\n\n        channelRules.push({\n          name: name,\n          index: index,\n          type: type,\n          compression: compression,\n        })\n\n        ruleSize -= name.length + 3\n      }\n\n      // Classify channels\n      var channels = EXRHeader.channels\n      var channelData = new Array(info.channels)\n\n      for (var i = 0; i < info.channels; ++i) {\n        var cd = (channelData[i] = {})\n        var channel = channels[i]\n\n        cd.name = channel.name\n        cd.compression = UNKNOWN\n        cd.decoded = false\n        cd.type = channel.pixelType\n        cd.pLinear = channel.pLinear\n        cd.width = info.width\n        cd.height = info.lines\n      }\n\n      var cscSet = {\n        idx: new Array(3),\n      }\n\n      for (var offset = 0; offset < info.channels; ++offset) {\n        var cd = channelData[offset]\n\n        for (var i = 0; i < channelRules.length; ++i) {\n          var rule = channelRules[i]\n\n          if (cd.name == rule.name) {\n            cd.compression = rule.compression\n\n            if (rule.index >= 0) {\n              cscSet.idx[rule.index] = offset\n            }\n\n            cd.offset = offset\n          }\n        }\n      }\n\n      // Read DCT - AC component data\n      if (dwaHeader.acCompressedSize > 0) {\n        switch (dwaHeader.acCompression) {\n          case STATIC_HUFFMAN:\n            var acBuffer = new Uint16Array(dwaHeader.totalAcUncompressedCount)\n            hufUncompress(\n              info.array,\n              inDataView,\n              inOffset,\n              dwaHeader.acCompressedSize,\n              acBuffer,\n              dwaHeader.totalAcUncompressedCount,\n            )\n            break\n\n          case DEFLATE:\n            var compressed = info.array.slice(inOffset.value, inOffset.value + dwaHeader.totalAcUncompressedCount)\n            var data = unzlibSync(compressed)\n            var acBuffer = new Uint16Array(data.buffer)\n            inOffset.value += dwaHeader.totalAcUncompressedCount\n            break\n        }\n      }\n\n      // Read DCT - DC component data\n      if (dwaHeader.dcCompressedSize > 0) {\n        var zlibInfo = {\n          array: info.array,\n          offset: inOffset,\n          size: dwaHeader.dcCompressedSize,\n        }\n        var dcBuffer = new Uint16Array(uncompressZIP(zlibInfo).buffer)\n        inOffset.value += dwaHeader.dcCompressedSize\n      }\n\n      // Read RLE compressed data\n      if (dwaHeader.rleRawSize > 0) {\n        var compressed = info.array.slice(inOffset.value, inOffset.value + dwaHeader.rleCompressedSize)\n        var data = unzlibSync(compressed)\n        var rleBuffer = decodeRunLength(data.buffer)\n\n        inOffset.value += dwaHeader.rleCompressedSize\n      }\n\n      // Prepare outbuffer data offset\n      var outBufferEnd = 0\n      var rowOffsets = new Array(channelData.length)\n      for (var i = 0; i < rowOffsets.length; ++i) {\n        rowOffsets[i] = new Array()\n      }\n\n      for (var y = 0; y < info.lines; ++y) {\n        for (var chan = 0; chan < channelData.length; ++chan) {\n          rowOffsets[chan].push(outBufferEnd)\n          outBufferEnd += channelData[chan].width * info.type * INT16_SIZE\n        }\n      }\n\n      // Lossy DCT decode RGB channels\n      lossyDctDecode(cscSet, rowOffsets, channelData, acBuffer, dcBuffer, outBuffer)\n\n      // Decode other channels\n      for (var i = 0; i < channelData.length; ++i) {\n        var cd = channelData[i]\n\n        if (cd.decoded) continue\n\n        switch (cd.compression) {\n          case RLE:\n            var row = 0\n            var rleOffset = 0\n\n            for (var y = 0; y < info.lines; ++y) {\n              var rowOffsetBytes = rowOffsets[i][row]\n\n              for (var x = 0; x < cd.width; ++x) {\n                for (var byte = 0; byte < INT16_SIZE * cd.type; ++byte) {\n                  outBuffer[rowOffsetBytes++] = rleBuffer[rleOffset + byte * cd.width * cd.height]\n                }\n\n                rleOffset++\n              }\n\n              row++\n            }\n\n            break\n\n          case LOSSY_DCT: // skip\n\n          default:\n            throw 'EXRLoader.parse: unsupported channel compression'\n        }\n      }\n\n      return new DataView(outBuffer.buffer)\n    }\n\n    function parseNullTerminatedString(buffer, offset) {\n      var uintBuffer = new Uint8Array(buffer)\n      var endOffset = 0\n\n      while (uintBuffer[offset.value + endOffset] != 0) {\n        endOffset += 1\n      }\n\n      var stringValue = new TextDecoder().decode(uintBuffer.slice(offset.value, offset.value + endOffset))\n\n      offset.value = offset.value + endOffset + 1\n\n      return stringValue\n    }\n\n    function parseFixedLengthString(buffer, offset, size) {\n      var stringValue = new TextDecoder().decode(new Uint8Array(buffer).slice(offset.value, offset.value + size))\n\n      offset.value = offset.value + size\n\n      return stringValue\n    }\n\n    function parseRational(dataView, offset) {\n      var x = parseInt32(dataView, offset)\n      var y = parseUint32(dataView, offset)\n\n      return [x, y]\n    }\n\n    function parseTimecode(dataView, offset) {\n      var x = parseUint32(dataView, offset)\n      var y = parseUint32(dataView, offset)\n\n      return [x, y]\n    }\n\n    function parseInt32(dataView, offset) {\n      var Int32 = dataView.getInt32(offset.value, true)\n\n      offset.value = offset.value + INT32_SIZE\n\n      return Int32\n    }\n\n    function parseUint32(dataView, offset) {\n      var Uint32 = dataView.getUint32(offset.value, true)\n\n      offset.value = offset.value + INT32_SIZE\n\n      return Uint32\n    }\n\n    function parseUint8Array(uInt8Array, offset) {\n      var Uint8 = uInt8Array[offset.value]\n\n      offset.value = offset.value + INT8_SIZE\n\n      return Uint8\n    }\n\n    function parseUint8(dataView, offset) {\n      var Uint8 = dataView.getUint8(offset.value)\n\n      offset.value = offset.value + INT8_SIZE\n\n      return Uint8\n    }\n\n    const parseInt64 = function (dataView, offset) {\n      let int\n\n      if ('getBigInt64' in DataView.prototype) {\n        int = Number(dataView.getBigInt64(offset.value, true))\n      } else {\n        int = dataView.getUint32(offset.value + 4, true) + Number(dataView.getUint32(offset.value, true) << 32)\n      }\n\n      offset.value += ULONG_SIZE\n\n      return int\n    }\n\n    function parseFloat32(dataView, offset) {\n      var float = dataView.getFloat32(offset.value, true)\n\n      offset.value += FLOAT32_SIZE\n\n      return float\n    }\n\n    function decodeFloat32(dataView, offset) {\n      return DataUtils.toHalfFloat(parseFloat32(dataView, offset))\n    }\n\n    // https://stackoverflow.com/questions/5678432/decompressing-half-precision-floats-in-javascript\n    function decodeFloat16(binary) {\n      var exponent = (binary & 0x7c00) >> 10,\n        fraction = binary & 0x03ff\n\n      return (\n        (binary >> 15 ? -1 : 1) *\n        (exponent\n          ? exponent === 0x1f\n            ? fraction\n              ? NaN\n              : Infinity\n            : Math.pow(2, exponent - 15) * (1 + fraction / 0x400)\n          : 6.103515625e-5 * (fraction / 0x400))\n      )\n    }\n\n    function parseUint16(dataView, offset) {\n      var Uint16 = dataView.getUint16(offset.value, true)\n\n      offset.value += INT16_SIZE\n\n      return Uint16\n    }\n\n    function parseFloat16(buffer, offset) {\n      return decodeFloat16(parseUint16(buffer, offset))\n    }\n\n    function parseChlist(dataView, buffer, offset, size) {\n      var startOffset = offset.value\n      var channels = []\n\n      while (offset.value < startOffset + size - 1) {\n        var name = parseNullTerminatedString(buffer, offset)\n        var pixelType = parseInt32(dataView, offset)\n        var pLinear = parseUint8(dataView, offset)\n        offset.value += 3 // reserved, three chars\n        var xSampling = parseInt32(dataView, offset)\n        var ySampling = parseInt32(dataView, offset)\n\n        channels.push({\n          name: name,\n          pixelType: pixelType,\n          pLinear: pLinear,\n          xSampling: xSampling,\n          ySampling: ySampling,\n        })\n      }\n\n      offset.value += 1\n\n      return channels\n    }\n\n    function parseChromaticities(dataView, offset) {\n      var redX = parseFloat32(dataView, offset)\n      var redY = parseFloat32(dataView, offset)\n      var greenX = parseFloat32(dataView, offset)\n      var greenY = parseFloat32(dataView, offset)\n      var blueX = parseFloat32(dataView, offset)\n      var blueY = parseFloat32(dataView, offset)\n      var whiteX = parseFloat32(dataView, offset)\n      var whiteY = parseFloat32(dataView, offset)\n\n      return {\n        redX: redX,\n        redY: redY,\n        greenX: greenX,\n        greenY: greenY,\n        blueX: blueX,\n        blueY: blueY,\n        whiteX: whiteX,\n        whiteY: whiteY,\n      }\n    }\n\n    function parseCompression(dataView, offset) {\n      var compressionCodes = [\n        'NO_COMPRESSION',\n        'RLE_COMPRESSION',\n        'ZIPS_COMPRESSION',\n        'ZIP_COMPRESSION',\n        'PIZ_COMPRESSION',\n        'PXR24_COMPRESSION',\n        'B44_COMPRESSION',\n        'B44A_COMPRESSION',\n        'DWAA_COMPRESSION',\n        'DWAB_COMPRESSION',\n      ]\n\n      var compression = parseUint8(dataView, offset)\n\n      return compressionCodes[compression]\n    }\n\n    function parseBox2i(dataView, offset) {\n      var xMin = parseUint32(dataView, offset)\n      var yMin = parseUint32(dataView, offset)\n      var xMax = parseUint32(dataView, offset)\n      var yMax = parseUint32(dataView, offset)\n\n      return { xMin: xMin, yMin: yMin, xMax: xMax, yMax: yMax }\n    }\n\n    function parseLineOrder(dataView, offset) {\n      var lineOrders = ['INCREASING_Y']\n\n      var lineOrder = parseUint8(dataView, offset)\n\n      return lineOrders[lineOrder]\n    }\n\n    function parseV2f(dataView, offset) {\n      var x = parseFloat32(dataView, offset)\n      var y = parseFloat32(dataView, offset)\n\n      return [x, y]\n    }\n\n    function parseV3f(dataView, offset) {\n      var x = parseFloat32(dataView, offset)\n      var y = parseFloat32(dataView, offset)\n      var z = parseFloat32(dataView, offset)\n\n      return [x, y, z]\n    }\n\n    function parseValue(dataView, buffer, offset, type, size) {\n      if (type === 'string' || type === 'stringvector' || type === 'iccProfile') {\n        return parseFixedLengthString(buffer, offset, size)\n      } else if (type === 'chlist') {\n        return parseChlist(dataView, buffer, offset, size)\n      } else if (type === 'chromaticities') {\n        return parseChromaticities(dataView, offset)\n      } else if (type === 'compression') {\n        return parseCompression(dataView, offset)\n      } else if (type === 'box2i') {\n        return parseBox2i(dataView, offset)\n      } else if (type === 'lineOrder') {\n        return parseLineOrder(dataView, offset)\n      } else if (type === 'float') {\n        return parseFloat32(dataView, offset)\n      } else if (type === 'v2f') {\n        return parseV2f(dataView, offset)\n      } else if (type === 'v3f') {\n        return parseV3f(dataView, offset)\n      } else if (type === 'int') {\n        return parseInt32(dataView, offset)\n      } else if (type === 'rational') {\n        return parseRational(dataView, offset)\n      } else if (type === 'timecode') {\n        return parseTimecode(dataView, offset)\n      } else if (type === 'preview') {\n        offset.value += size\n        return 'skipped'\n      } else {\n        offset.value += size\n        return undefined\n      }\n    }\n\n    function parseHeader(dataView, buffer, offset) {\n      const EXRHeader = {}\n\n      if (dataView.getUint32(0, true) != 20000630) {\n        // magic\n        throw \"THREE.EXRLoader: provided file doesn't appear to be in OpenEXR format.\"\n      }\n\n      EXRHeader.version = dataView.getUint8(4)\n\n      const spec = dataView.getUint8(5) // fullMask\n\n      EXRHeader.spec = {\n        singleTile: !!(spec & 2),\n        longName: !!(spec & 4),\n        deepFormat: !!(spec & 8),\n        multiPart: !!(spec & 16),\n      }\n\n      // start of header\n\n      offset.value = 8 // start at 8 - after pre-amble\n\n      var keepReading = true\n\n      while (keepReading) {\n        var attributeName = parseNullTerminatedString(buffer, offset)\n\n        if (attributeName == 0) {\n          keepReading = false\n        } else {\n          var attributeType = parseNullTerminatedString(buffer, offset)\n          var attributeSize = parseUint32(dataView, offset)\n          var attributeValue = parseValue(dataView, buffer, offset, attributeType, attributeSize)\n\n          if (attributeValue === undefined) {\n            console.warn(`EXRLoader.parse: skipped unknown header attribute type \\'${attributeType}\\'.`)\n          } else {\n            EXRHeader[attributeName] = attributeValue\n          }\n        }\n      }\n\n      if ((spec & ~0x04) != 0) {\n        // unsupported tiled, deep-image, multi-part\n        console.error('EXRHeader:', EXRHeader)\n        throw 'THREE.EXRLoader: provided file is currently unsupported.'\n      }\n\n      return EXRHeader\n    }\n\n    function setupDecoder(EXRHeader, dataView, uInt8Array, offset, outputType) {\n      const EXRDecoder = {\n        size: 0,\n        viewer: dataView,\n        array: uInt8Array,\n        offset: offset,\n        width: EXRHeader.dataWindow.xMax - EXRHeader.dataWindow.xMin + 1,\n        height: EXRHeader.dataWindow.yMax - EXRHeader.dataWindow.yMin + 1,\n        channels: EXRHeader.channels.length,\n        bytesPerLine: null,\n        lines: null,\n        inputSize: null,\n        type: EXRHeader.channels[0].pixelType,\n        uncompress: null,\n        getter: null,\n        format: null,\n        [hasColorSpace ? 'colorSpace' : 'encoding']: null,\n      }\n\n      switch (EXRHeader.compression) {\n        case 'NO_COMPRESSION':\n          EXRDecoder.lines = 1\n          EXRDecoder.uncompress = uncompressRAW\n          break\n\n        case 'RLE_COMPRESSION':\n          EXRDecoder.lines = 1\n          EXRDecoder.uncompress = uncompressRLE\n          break\n\n        case 'ZIPS_COMPRESSION':\n          EXRDecoder.lines = 1\n          EXRDecoder.uncompress = uncompressZIP\n          break\n\n        case 'ZIP_COMPRESSION':\n          EXRDecoder.lines = 16\n          EXRDecoder.uncompress = uncompressZIP\n          break\n\n        case 'PIZ_COMPRESSION':\n          EXRDecoder.lines = 32\n          EXRDecoder.uncompress = uncompressPIZ\n          break\n\n        case 'PXR24_COMPRESSION':\n          EXRDecoder.lines = 16\n          EXRDecoder.uncompress = uncompressPXR\n          break\n\n        case 'DWAA_COMPRESSION':\n          EXRDecoder.lines = 32\n          EXRDecoder.uncompress = uncompressDWA\n          break\n\n        case 'DWAB_COMPRESSION':\n          EXRDecoder.lines = 256\n          EXRDecoder.uncompress = uncompressDWA\n          break\n\n        default:\n          throw 'EXRLoader.parse: ' + EXRHeader.compression + ' is unsupported'\n      }\n\n      EXRDecoder.scanlineBlockSize = EXRDecoder.lines\n\n      if (EXRDecoder.type == 1) {\n        // half\n        switch (outputType) {\n          case FloatType:\n            EXRDecoder.getter = parseFloat16\n            EXRDecoder.inputSize = INT16_SIZE\n            break\n\n          case HalfFloatType:\n            EXRDecoder.getter = parseUint16\n            EXRDecoder.inputSize = INT16_SIZE\n            break\n        }\n      } else if (EXRDecoder.type == 2) {\n        // float\n        switch (outputType) {\n          case FloatType:\n            EXRDecoder.getter = parseFloat32\n            EXRDecoder.inputSize = FLOAT32_SIZE\n            break\n\n          case HalfFloatType:\n            EXRDecoder.getter = decodeFloat32\n            EXRDecoder.inputSize = FLOAT32_SIZE\n        }\n      } else {\n        throw 'EXRLoader.parse: unsupported pixelType ' + EXRDecoder.type + ' for ' + EXRHeader.compression + '.'\n      }\n\n      EXRDecoder.blockCount = (EXRHeader.dataWindow.yMax + 1) / EXRDecoder.scanlineBlockSize\n\n      for (var i = 0; i < EXRDecoder.blockCount; i++) parseInt64(dataView, offset) // scanlineOffset\n\n      // we should be passed the scanline offset table, ready to start reading pixel data.\n\n      // RGB images will be converted to RGBA format, preventing software emulation in select devices.\n      EXRDecoder.outputChannels = EXRDecoder.channels == 3 ? 4 : EXRDecoder.channels\n      const size = EXRDecoder.width * EXRDecoder.height * EXRDecoder.outputChannels\n\n      switch (outputType) {\n        case FloatType:\n          EXRDecoder.byteArray = new Float32Array(size)\n\n          // Fill initially with 1s for the alpha value if the texture is not RGBA, RGB values will be overwritten\n          if (EXRDecoder.channels < EXRDecoder.outputChannels) EXRDecoder.byteArray.fill(1, 0, size)\n\n          break\n\n        case HalfFloatType:\n          EXRDecoder.byteArray = new Uint16Array(size)\n\n          if (EXRDecoder.channels < EXRDecoder.outputChannels) EXRDecoder.byteArray.fill(0x3c00, 0, size) // Uint16Array holds half float data, 0x3C00 is 1\n\n          break\n\n        default:\n          console.error('THREE.EXRLoader: unsupported type: ', outputType)\n          break\n      }\n\n      EXRDecoder.bytesPerLine = EXRDecoder.width * EXRDecoder.inputSize * EXRDecoder.channels\n\n      if (EXRDecoder.outputChannels == 4) EXRDecoder.format = RGBAFormat\n      else EXRDecoder.format = RedFormat\n\n      if (hasColorSpace) EXRDecoder.colorSpace = 'srgb-linear'\n      else EXRDecoder.encoding = 3000 // LinearEncoding\n\n      return EXRDecoder\n    }\n\n    // start parsing file [START]\n\n    const bufferDataView = new DataView(buffer)\n    const uInt8Array = new Uint8Array(buffer)\n    const offset = { value: 0 }\n\n    // get header information and validate format.\n    const EXRHeader = parseHeader(bufferDataView, buffer, offset)\n\n    // get input compression information and prepare decoding.\n    const EXRDecoder = setupDecoder(EXRHeader, bufferDataView, uInt8Array, offset, this.type)\n\n    const tmpOffset = { value: 0 }\n    const channelOffsets = { R: 0, G: 1, B: 2, A: 3, Y: 0 }\n\n    for (\n      let scanlineBlockIdx = 0;\n      scanlineBlockIdx < EXRDecoder.height / EXRDecoder.scanlineBlockSize;\n      scanlineBlockIdx++\n    ) {\n      const line = parseUint32(bufferDataView, offset) // line_no\n      EXRDecoder.size = parseUint32(bufferDataView, offset) // data_len\n      EXRDecoder.lines =\n        line + EXRDecoder.scanlineBlockSize > EXRDecoder.height\n          ? EXRDecoder.height - line\n          : EXRDecoder.scanlineBlockSize\n\n      const isCompressed = EXRDecoder.size < EXRDecoder.lines * EXRDecoder.bytesPerLine\n      const viewer = isCompressed ? EXRDecoder.uncompress(EXRDecoder) : uncompressRAW(EXRDecoder)\n\n      offset.value += EXRDecoder.size\n\n      for (let line_y = 0; line_y < EXRDecoder.scanlineBlockSize; line_y++) {\n        const true_y = line_y + scanlineBlockIdx * EXRDecoder.scanlineBlockSize\n        if (true_y >= EXRDecoder.height) break\n\n        for (let channelID = 0; channelID < EXRDecoder.channels; channelID++) {\n          const cOff = channelOffsets[EXRHeader.channels[channelID].name]\n\n          for (let x = 0; x < EXRDecoder.width; x++) {\n            tmpOffset.value =\n              (line_y * (EXRDecoder.channels * EXRDecoder.width) + channelID * EXRDecoder.width + x) *\n              EXRDecoder.inputSize\n            const outIndex =\n              (EXRDecoder.height - 1 - true_y) * (EXRDecoder.width * EXRDecoder.outputChannels) +\n              x * EXRDecoder.outputChannels +\n              cOff\n            EXRDecoder.byteArray[outIndex] = EXRDecoder.getter(viewer, tmpOffset)\n          }\n        }\n      }\n    }\n\n    return {\n      header: EXRHeader,\n      width: EXRDecoder.width,\n      height: EXRDecoder.height,\n      data: EXRDecoder.byteArray,\n      format: EXRDecoder.format,\n      [hasColorSpace ? 'colorSpace' : 'encoding']: EXRDecoder[hasColorSpace ? 'colorSpace' : 'encoding'],\n      type: this.type,\n    }\n  }\n\n  setDataType(value) {\n    this.type = value\n    return this\n  }\n\n  load(url, onLoad, onProgress, onError) {\n    function onLoadCallback(texture, texData) {\n      if (hasColorSpace) texture.colorSpace = texData.colorSpace\n      else texture.encoding = texData.encoding\n      texture.minFilter = LinearFilter\n      texture.magFilter = LinearFilter\n      texture.generateMipmaps = false\n      texture.flipY = false\n\n      if (onLoad) onLoad(texture, texData)\n    }\n\n    return super.load(url, onLoadCallback, onProgress, onError)\n  }\n}\n\nexport { EXRLoader }\n"],"names":["uInt8Array","buffer","comp","offset","type","y","x","tmpOffset","EXRHeader","EXRDecoder"],"mappings":"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","debugId":null}}]
}